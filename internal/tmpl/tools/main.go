//go:build tools
// +build tools

// This tool generates documented TypeScript code for functions available in the Go template engine.
// The tool searches for functions with a directive in the comments and extracts the function signature,
// description, and category. It also resolves imported functions and overriden functions.
package main

import (
	"bytes"
	"cmp"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log/slog"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"slices"
	"strings"
	"text/template"

	"github.com/bartventer/log"
	"golang.org/x/tools/go/packages"
)

var (
	outputFlag       = flag.String("output", "", "Output file path")
	genDirectiveFlag = flag.String("directive", ":tsgen", "Directive to identify functions to generate")
	srcPkgPathFlag   = flag.String("pkg", "", "Package path to search for functions")
)

type directiveSuffix uint

const (
	directiveSuffixDefault directiveSuffix = iota
	directiveSuffixCategory
	directiveSuffixName // overrides the function name.
)

func (s directiveSuffix) String() string {
	return [...]string{
		"",
		"category",
		"name",
	}[s]
}

type functionSpec struct {
	Name        string // name of the function as defined in the Go code.
	Description string // documentation of the function.
	Signature   string // function signature.
	Category    string // category of the function.
	URL         string // URL to the function documentation on pkg.go.dev.
}

func (d functionSpec) String() string {
	var sb strings.Builder
	sb.WriteString("{ name: '")
	sb.WriteString(d.Name)
	if d.Description != "" {
		sb.WriteString("', description: '")
		sb.WriteString(d.Description)
	}
	sb.WriteString("', signature: '")
	sb.WriteString(d.Signature)
	sb.WriteString("', category: '")
	sb.WriteString(d.Category)
	if d.URL != "" {
		sb.WriteString("', url: '")
		sb.WriteString(d.URL)
	}
	sb.WriteString("' }")
	return sb.String()
}

const typescriptTmplFuncs = `/**
 * Code generated by {{ printf "%s/%s" .Package .File }}; DO NOT EDIT.
 *
 * @file {{ .OutputFile }}
 * @summary TypeScript code for functions available in the Go template engine.
 * @description This file contains a list of functions available in the Go template engine, including built-in and custom functions.
 * @description The functions are categorized into groups such as Text, Time, Filepath, Math, etc.
 * 
 * @see https://pkg.go.dev/{{ .Package }}
 * @see https://pkg.go.dev/text/template
 */

/** URL to the Go template engine documentation. */
export const FUNCTIONS_DOCUMENTATION_URL = "https://pkg.go.dev/{{ .Package }}" as const;

/** List of function categories available in the Go template engine. */
export const templateFunctionCategories = [
	{{- range .Categories }}
	"{{ . }}",
	{{- end }}
] as const;

/** FunctionCategory represents a category of functions available in the Go template engine. */
export type TemplateFunctionCategory = typeof templateFunctionCategories[number];

/** TemplateBaseFunction represents a function with a name, signature, and category. */
interface TemplateBaseFunction {
	name: string;
	signature: string;
	category: TemplateFunctionCategory;
}

/** TemplateDescriptiveFunction represents a function with a description. */
interface TemplateDescriptiveFunction extends TemplateBaseFunction {
	description: string;
	url?: string;
}

/** TemplateURLFunction represents a function that has a URL to its documentation. */
interface TemplateURLFunction extends TemplateBaseFunction {
	url: string;
	description?: string;
}

/** TemplateFunction represents a function available in the Go template engine. */
export type TemplateFunction = TemplateDescriptiveFunction | TemplateURLFunction;

/** List of functions (built-in and custom) available in the Go template engine. */
export const templateFunctions: TemplateFunction[] = [
	{{ range .Functions }}{{ . }},
	{{ end }}
];

/** Map of functions by name available in the Go template engine. */
export const templateFunctionsByName : ReadonlyMap<string, TemplateFunction> = new Map(
	templateFunctions.map((fn) => [fn.name, fn])
);
`

type importedFunc struct {
	Name, Symbol, Category string
}

var importedFuncMap = map[string][]importedFunc{
	"strings": {
		{"lower", "ToLower", "Text"},
		{"upper", "ToUpper", "Text"},
		{"trimSpace", "TrimSpace", "Text"},
		{"replaceAll", "ReplaceAll", "Text"},
		{"contains", "Contains", "Text"},
		{"hasPrefix", "HasPrefix", "Text"},
		{"hasSuffix", "HasSuffix", "Text"},
		{"split", "Split", "Text"},
		{"trimPrefix", "TrimPrefix", "Text"},
		{"trimSuffix", "TrimSuffix", "Text"},
	},
	"time": {
		{"now", "Now", "Time"},
	},
	"path/filepath": {
		{"dir", "Dir", "Filepath"},
		{"base", "Base", "Filepath"},
		{"abs", "Abs", "Filepath"},
		{"rel", "Rel", "Filepath"},
		{"ext", "Ext", "Filepath"},
		{"filepathJoin", "Join", "Filepath"},
	},
	"math": {
		{"mathAbs", "Abs", "Math"},
		{"pow", "Pow", "Math"},
		{"pow10", "Pow10", "Math"},
		{"max", "Max", "Math"},
		{"min", "Min", "Math"},
		{"ceil", "Ceil", "Math"},
		{"floor", "Floor", "Math"},
		{"round", "Round", "Math"},
		{"sqrt", "Sqrt", "Math"},
		{"sin", "Sin", "Math"},
		{"cos", "Cos", "Math"},
		{"tan", "Tan", "Math"},
		{"asin", "Asin", "Math"},
		{"acos", "Acos", "Math"},
		{"atan", "Atan", "Math"},
		{"atan2", "Atan2", "Math"},
		{"exp", "Exp", "Math"},
		{"log", "Log", "Math"},
		{"log10", "Log10", "Math"},
		{"log2", "Log2", "Math"},
	},
	"math/rand/v2": {
		{"randInt", "IntN", "Math"},
	},
}

type overridenFunc struct {
	Name, Category, Description, Signature string
}

var overridenFuncs = []overridenFunc{
	{
		"title",
		"Text",
		"Converts the first character of each word to uppercase.",
		"func title (s string) string",
	},
}

//nolint:cyclop // Simple command-line tool
func main() { //nolint:funlen // Simple command-line tool
	flag.Parse()
	switch {
	case *genDirectiveFlag == "":
		log.Fatal("Directive cannot be empty")
	case *srcPkgPathFlag == "":
		log.Fatal("Package path cannot be empty")
	}

	genDirective := *genDirectiveFlag
	outputPath := *outputFlag
	srcPkgPath := *srcPkgPathFlag
	workspace := os.Getenv("WORKSPACE")
	if workspace == "" {
		log.Fatal("WORKSPACE environment variable not set")
	}
	repoName := filepath.Base(workspace)

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, srcPkgPath, func(fi os.FileInfo) bool {
		return !strings.HasSuffix(fi.Name(), "_test.go")
	}, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	log.Info("Writing TypeScript code",
		"options", slog.GroupValue(
			slog.String("outputPath", outputPath),
			slog.String("genDirective", genDirective),
			slog.String("srcPkgPath", srcPkgPath),
		),
		"runtime", slog.GroupValue(
			slog.String("goVersion", runtime.Version()),
			slog.String("goOS", runtime.GOOS),
			slog.String("goArch", runtime.GOARCH),
		),
		"workspace", workspace,
		"repoName", repoName,
	)

	// Find custom functions with directive.
	var re = regexp.MustCompile(`(?m)^` + regexp.QuoteMeta(genDirective) + "$")
	data := make([]functionSpec, 0)
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				fn, ok := n.(*ast.FuncDecl)
				if !ok {
					return true
				}

				doc := fn.Doc
				if doc == nil {
					return true
				}

				text := doc.Text()
				idx := re.FindStringIndex(text)
				if idx == nil {
					return true
				}

				directivesStr := strings.TrimSpace(text[idx[0]:])
				d := extractDirectiveInfo(directivesStr, genDirective)
				d.Name = cmp.Or(d.Name, fn.Name.Name)
				d.Description = strings.Join(strings.Fields(text[:idx[0]]), " ")
				d.Signature = formatFuncType(fn.Type, d.Name)

				data = append(data, d)
				return true
			})
		}
	}

	// Merge imported functions.
	for pkg, funcs := range importedFuncMap {
		for _, fn := range funcs {
			signature := loadFuncSignature(pkg, fn)
			data = append(data, functionSpec{
				Name:      fn.Name,
				Signature: signature,
				Category:  fn.Category,
				URL:       fmt.Sprintf("https://pkg.go.dev/%s#%s", pkg, fn.Symbol),
			})
		}
	}

	// Merge overriden functions.
	for _, fn := range overridenFuncs {
		data = append(data, functionSpec{
			Name:        fn.Name,
			Description: fn.Description,
			Category:    fn.Category,
			Signature:   fn.Signature,
		})
	}

	// Sort functions by category and name.
	slices.SortFunc(data, func(d1, d2 functionSpec) int {
		return cmp.Or(
			cmp.Compare(d1.Category, d2.Category),
			cmp.Compare(d1.Name, d2.Name),
		)
	})

	categoriesMap := make(map[string]struct{})
	for _, d := range data {
		categoriesMap[d.Category] = struct{}{}
	}
	categories := make([]string, 0, len(categoriesMap))
	for k := range categoriesMap {
		categories = append(categories, k)
	}
	slices.Sort(categories)

	var buf bytes.Buffer
	tmpl := template.Must(template.New("typescript").Parse(typescriptTmplFuncs))
	err = tmpl.Execute(&buf, struct {
		Directive  string
		File       string
		Package    string
		Functions  []functionSpec
		Categories []string
		OutputFile string
	}{
		genDirective,
		os.Getenv("GOFILE"),
		"github.com/bartventer/" + repoName + "/" + strings.SplitAfterN(srcPkgPath, repoName+"/", 2)[1],
		data,
		categories,
		filepath.Base(outputPath),
	})
	if err != nil {
		log.Fatal(err)
	}

	var file *os.File
	if outputPath == "" {
		file = os.Stderr
	} else {
		file, err = os.Create(outputPath)
		if err != nil {
			log.Fatal(err)
		}
		defer file.Close()
	}

	_, err = file.Write(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	log.Info("Done", "numFunctions", len(data))
}

func extractDirectiveInfo(directivesStr, prefix string) (data functionSpec) {
	lines := strings.Split(directivesStr, "\n"+prefix+"_")
	for _, line := range lines {
		switch {
		case strings.HasPrefix(line, directiveSuffixCategory.String()):
			data.Category = strings.TrimSpace(strings.TrimPrefix(line, directiveSuffixCategory.String()))
		case strings.HasPrefix(line, directiveSuffixName.String()):
			data.Name = strings.TrimSpace(strings.TrimPrefix(line, directiveSuffixName.String()))
		}
	}
	return data
}

func formatFuncType(ft *ast.FuncType, name string) string {
	var buf bytes.Buffer
	err := printer.Fprint(&buf, token.NewFileSet(), ft)
	if err != nil {
		log.Fatal(err)
	}
	str := buf.String()
	if strings.HasPrefix(str, "func") {
		str = fmt.Sprintf("func %s%s", name, str[4:])
	}
	return str
}

func loadFuncSignature(pkgstr string, reference importedFunc) (signature string) {
	if reference.Symbol == "" {
		log.Fatalf("Symbol cannot be empty for %s", reference.Name)
	}

	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo}
	pkgs, err := packages.Load(cfg, pkgstr)
	if err != nil {
		log.Fatalf("Error loading package: %s", err)
	}

	for _, pkg := range pkgs {
		for _, syntax := range pkg.Syntax {
			for _, decl := range syntax.Decls {
				// Check for top-level function.
				if fn, ok := decl.(*ast.FuncDecl); ok {
					if fn.Name.Name == reference.Symbol {
						signature = formatFuncType(fn.Type, reference.Name)
						return signature
					}
				}
			}
		}
	}

	log.Fatalf("Function or method %s not found in package %s", reference.Symbol, pkgstr)
	return ""
}
