var A=t=>{throw TypeError(t)};var h=(t,e,o)=>e.has(t)||A("Cannot "+o);var s=(t,e,o)=>(h(t,e,"read from private field"),o?o.call(t):e.get(t)),y=(t,e,o)=>e.has(t)?A("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,o),j=(t,e,o,l)=>(h(t,e,"write to private field"),l?l.call(t,o):e.set(t,o),o),d=(t,e,o)=>(h(t,e,"access private method"),o);(function(){"use strict";var l,n,T,m,O,b,S;const t={IDB_ERROR:"IndexedDB error",STORE_PUT_ERROR:"Store put error",STORE_GET_ERROR:"Store get error"},r=class r{constructor(){y(this,b);y(this,O,null)}async put(u,w){const a=(await d(this,b,S).call(this)).transaction(s(r,n),"readwrite").objectStore(s(r,n));await new Promise((g,E)=>{const i=a.put({...w,key:u});i.onsuccess=()=>{g()},i.onerror=P=>{var p;E(new Error(((p=P.target.error)==null?void 0:p.message)||t.STORE_PUT_ERROR))}})}async get(u){const c=(await d(this,b,S).call(this)).transaction(s(r,n),"readonly").objectStore(s(r,n));return new Promise((a,g)=>{const E=c.get(u);E.onsuccess=i=>{a(i.target.result)},E.onerror=i=>{var P;g(new Error(((P=i.target.error)==null?void 0:P.message)||t.STORE_GET_ERROR))}})}async getAllKeys(){const R=(await d(this,b,S).call(this)).transaction(s(r,n),"readonly").objectStore(s(r,n));return new Promise((c,a)=>{const g=R.getAllKeys();g.onsuccess=E=>{c(E.target.result)},g.onerror=E=>{var i;a(new Error(((i=E.target.error)==null?void 0:i.message)||t.STORE_GET_ERROR))}})}async clear(){const R=(await d(this,b,S).call(this)).transaction(s(r,n),"readwrite").objectStore(s(r,n));await new Promise((c,a)=>{const g=R.clear();g.onsuccess=()=>{c()},g.onerror=E=>{var i;a(new Error(((i=E.target.error)==null?void 0:i.message)||t.STORE_PUT_ERROR))}})}};l=new WeakMap,n=new WeakMap,T=new WeakMap,m=new WeakMap,O=new WeakMap,b=new WeakSet,S=async function(){return s(this,O)?s(this,O):(j(this,O,await new Promise((u,w)=>{const R=indexedDB.open(s(r,l),s(r,T));R.onupgradeneeded=c=>{const a=c.target.result;a.objectStoreNames.contains(s(r,n))||a.createObjectStore(s(r,n),{keyPath:s(r,m)})},R.onsuccess=c=>{u(c.target.result)},R.onerror=c=>{var a;w(new Error(((a=c.target.error)==null?void 0:a.message)||t.IDB_ERROR))}})),s(this,O))},y(r,l,"PlaygroundDB"),y(r,n,"autosave"),y(r,T,1),y(r,m,"key");let e=r;const o=new e;onmessage=async q=>{const{key:u,...w}=q.data;try{await o.put(u,w)}catch(R){console.error("Autosave error:",R)}}})();
//# sourceMappingURL=autosave.worker-CXmuNWYS.js.map
