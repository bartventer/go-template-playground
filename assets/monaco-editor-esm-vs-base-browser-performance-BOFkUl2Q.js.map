{"version":3,"file":"monaco-editor-esm-vs-base-browser-performance-BOFkUl2Q.js","sources":["../../../node_modules/monaco-editor/esm/vs/base/browser/performance.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var inputLatency;\n(function (inputLatency) {\n    const totalKeydownTime = { total: 0, min: Number.MAX_VALUE, max: 0 };\n    const totalInputTime = { ...totalKeydownTime };\n    const totalRenderTime = { ...totalKeydownTime };\n    const totalInputLatencyTime = { ...totalKeydownTime };\n    let measurementsCount = 0;\n    const state = {\n        keydown: 0 /* EventPhase.Before */,\n        input: 0 /* EventPhase.Before */,\n        render: 0 /* EventPhase.Before */,\n    };\n    /**\n     * Record the start of the keydown event.\n     */\n    function onKeyDown() {\n        /** Direct Check C. See explanation in {@link recordIfFinished} */\n        recordIfFinished();\n        performance.mark('inputlatency/start');\n        performance.mark('keydown/start');\n        state.keydown = 1 /* EventPhase.InProgress */;\n        queueMicrotask(markKeyDownEnd);\n    }\n    inputLatency.onKeyDown = onKeyDown;\n    /**\n     * Mark the end of the keydown event.\n     */\n    function markKeyDownEnd() {\n        if (state.keydown === 1 /* EventPhase.InProgress */) {\n            performance.mark('keydown/end');\n            state.keydown = 2 /* EventPhase.Finished */;\n        }\n    }\n    /**\n     * Record the start of the beforeinput event.\n     */\n    function onBeforeInput() {\n        performance.mark('input/start');\n        state.input = 1 /* EventPhase.InProgress */;\n        /** Schedule Task A. See explanation in {@link recordIfFinished} */\n        scheduleRecordIfFinishedTask();\n    }\n    inputLatency.onBeforeInput = onBeforeInput;\n    /**\n     * Record the start of the input event.\n     */\n    function onInput() {\n        if (state.input === 0 /* EventPhase.Before */) {\n            // it looks like we didn't receive a `beforeinput`\n            onBeforeInput();\n        }\n        queueMicrotask(markInputEnd);\n    }\n    inputLatency.onInput = onInput;\n    function markInputEnd() {\n        if (state.input === 1 /* EventPhase.InProgress */) {\n            performance.mark('input/end');\n            state.input = 2 /* EventPhase.Finished */;\n        }\n    }\n    /**\n     * Record the start of the keyup event.\n     */\n    function onKeyUp() {\n        /** Direct Check D. See explanation in {@link recordIfFinished} */\n        recordIfFinished();\n    }\n    inputLatency.onKeyUp = onKeyUp;\n    /**\n     * Record the start of the selectionchange event.\n     */\n    function onSelectionChange() {\n        /** Direct Check E. See explanation in {@link recordIfFinished} */\n        recordIfFinished();\n    }\n    inputLatency.onSelectionChange = onSelectionChange;\n    /**\n     * Record the start of the animation frame performing the rendering.\n     */\n    function onRenderStart() {\n        // Render may be triggered during input, but we only measure the following animation frame\n        if (state.keydown === 2 /* EventPhase.Finished */ && state.input === 2 /* EventPhase.Finished */ && state.render === 0 /* EventPhase.Before */) {\n            // Only measure the first render after keyboard input\n            performance.mark('render/start');\n            state.render = 1 /* EventPhase.InProgress */;\n            queueMicrotask(markRenderEnd);\n            /** Schedule Task B. See explanation in {@link recordIfFinished} */\n            scheduleRecordIfFinishedTask();\n        }\n    }\n    inputLatency.onRenderStart = onRenderStart;\n    /**\n     * Mark the end of the animation frame performing the rendering.\n     */\n    function markRenderEnd() {\n        if (state.render === 1 /* EventPhase.InProgress */) {\n            performance.mark('render/end');\n            state.render = 2 /* EventPhase.Finished */;\n        }\n    }\n    function scheduleRecordIfFinishedTask() {\n        // Here we can safely assume that the `setTimeout` will not be\n        // artificially delayed by 4ms because we schedule it from\n        // event handlers\n        setTimeout(recordIfFinished);\n    }\n    /**\n     * Record the input latency sample if input handling and rendering are finished.\n     *\n     * The challenge here is that we want to record the latency in such a way that it includes\n     * also the layout and painting work the browser does during the animation frame task.\n     *\n     * Simply scheduling a new task (via `setTimeout`) from the animation frame task would\n     * schedule the new task at the end of the task queue (after other code that uses `setTimeout`),\n     * so we need to use multiple strategies to make sure our task runs before others:\n     *\n     * We schedule tasks (A and B):\n     *    - we schedule a task A (via a `setTimeout` call) when the input starts in `markInputStart`.\n     *      If the animation frame task is scheduled quickly by the browser, then task A has a very good\n     *      chance of being the very first task after the animation frame and thus will record the input latency.\n     *    - however, if the animation frame task is scheduled a bit later, then task A might execute\n     *      before the animation frame task. We therefore schedule another task B from `markRenderStart`.\n     *\n     * We do direct checks in browser event handlers (C, D, E):\n     *    - if the browser has multiple keydown events queued up, they will be scheduled before the `setTimeout` tasks,\n     *      so we do a direct check in the keydown event handler (C).\n     *    - depending on timing, sometimes the animation frame is scheduled even before the `keyup` event, so we\n     *      do a direct check there too (E).\n     *    - the browser oftentimes emits a `selectionchange` event after an `input`, so we do a direct check there (D).\n     */\n    function recordIfFinished() {\n        if (state.keydown === 2 /* EventPhase.Finished */ && state.input === 2 /* EventPhase.Finished */ && state.render === 2 /* EventPhase.Finished */) {\n            performance.mark('inputlatency/end');\n            performance.measure('keydown', 'keydown/start', 'keydown/end');\n            performance.measure('input', 'input/start', 'input/end');\n            performance.measure('render', 'render/start', 'render/end');\n            performance.measure('inputlatency', 'inputlatency/start', 'inputlatency/end');\n            addMeasure('keydown', totalKeydownTime);\n            addMeasure('input', totalInputTime);\n            addMeasure('render', totalRenderTime);\n            addMeasure('inputlatency', totalInputLatencyTime);\n            // console.info(\n            // \t`input latency=${performance.getEntriesByName('inputlatency')[0].duration.toFixed(1)} [` +\n            // \t`keydown=${performance.getEntriesByName('keydown')[0].duration.toFixed(1)}, ` +\n            // \t`input=${performance.getEntriesByName('input')[0].duration.toFixed(1)}, ` +\n            // \t`render=${performance.getEntriesByName('render')[0].duration.toFixed(1)}` +\n            // \t`]`\n            // );\n            measurementsCount++;\n            reset();\n        }\n    }\n    function addMeasure(entryName, cumulativeMeasurement) {\n        const duration = performance.getEntriesByName(entryName)[0].duration;\n        cumulativeMeasurement.total += duration;\n        cumulativeMeasurement.min = Math.min(cumulativeMeasurement.min, duration);\n        cumulativeMeasurement.max = Math.max(cumulativeMeasurement.max, duration);\n    }\n    /**\n     * Clear the current sample.\n     */\n    function reset() {\n        performance.clearMarks('keydown/start');\n        performance.clearMarks('keydown/end');\n        performance.clearMarks('input/start');\n        performance.clearMarks('input/end');\n        performance.clearMarks('render/start');\n        performance.clearMarks('render/end');\n        performance.clearMarks('inputlatency/start');\n        performance.clearMarks('inputlatency/end');\n        performance.clearMeasures('keydown');\n        performance.clearMeasures('input');\n        performance.clearMeasures('render');\n        performance.clearMeasures('inputlatency');\n        state.keydown = 0 /* EventPhase.Before */;\n        state.input = 0 /* EventPhase.Before */;\n        state.render = 0 /* EventPhase.Before */;\n    }\n    /**\n     * Gets all input latency samples and clears the internal buffers to start recording a new set\n     * of samples.\n     */\n    function getAndClearMeasurements() {\n        if (measurementsCount === 0) {\n            return undefined;\n        }\n        // Assemble the result\n        const result = {\n            keydown: cumulativeToFinalMeasurement(totalKeydownTime),\n            input: cumulativeToFinalMeasurement(totalInputTime),\n            render: cumulativeToFinalMeasurement(totalRenderTime),\n            total: cumulativeToFinalMeasurement(totalInputLatencyTime),\n            sampleCount: measurementsCount\n        };\n        // Clear the cumulative measurements\n        clearCumulativeMeasurement(totalKeydownTime);\n        clearCumulativeMeasurement(totalInputTime);\n        clearCumulativeMeasurement(totalRenderTime);\n        clearCumulativeMeasurement(totalInputLatencyTime);\n        measurementsCount = 0;\n        return result;\n    }\n    inputLatency.getAndClearMeasurements = getAndClearMeasurements;\n    function cumulativeToFinalMeasurement(cumulative) {\n        return {\n            average: cumulative.total / measurementsCount,\n            max: cumulative.max,\n            min: cumulative.min,\n        };\n    }\n    function clearCumulativeMeasurement(cumulative) {\n        cumulative.total = 0;\n        cumulative.min = Number.MAX_VALUE;\n        cumulative.max = 0;\n    }\n})(inputLatency || (inputLatency = {}));\n"],"names":["inputLatency","totalKeydownTime","totalInputTime","totalRenderTime","totalInputLatencyTime","measurementsCount","state","onKeyDown","recordIfFinished","markKeyDownEnd","onBeforeInput","scheduleRecordIfFinishedTask","onInput","markInputEnd","onKeyUp","onSelectionChange","onRenderStart","markRenderEnd","addMeasure","reset","entryName","cumulativeMeasurement","duration","getAndClearMeasurements","result","cumulativeToFinalMeasurement","clearCumulativeMeasurement","cumulative"],"mappings":"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","x_google_ignoreList":[0]}