{"version":3,"mappings":"AAAA,YAAAA,GAAA,MAAAC,GAAA,MAAAC,EAAA,KAAAC,GAAA,KAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,KAAAC,EAAA,KAAAC,GAAA,KAAAC,GAAA,KAAAC,EAAA,KAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,KAAAC,GAAA,KAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,KAAAC,GAAA,MAAAC,GAAA,KAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,KAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,KAAAC,GAAA,KAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,KAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,G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","names":["LinkedList","Iterable","localize","isLinux","isMacintosh","equals","equals$1","Emitter","toDisposable","Disposable","Codicon","URI","KeyChord","CancellationTokenSource","isLittleEndian","readUInt16LE","isHighSurrogate","createRegExp","escapeRegExpCharacters","distinct","onUnexpectedError","Mimes","CachedFunction","getLeadingWhitespace","toUint8","LRUCache","getNextCodePoint","assertNever","AmbiguousCharacters","InvisibleCharacters","isBasicASCII","BugIndicatingError","findFirstIdxMonotonousOrArrLen","findLastIdxMonotonous","findLastMonotonous","assertFn","checkAdjacentItems","LcsDiff","firstNonWhitespaceIndex","lastNonWhitespaceIndex","forEachAdjacent","findFirstMonotonous","pushMany","SetMap","compareBy","reverseOrder","MonotonousArray","numberComparator","forEachWithNeighbors","groupAdjacentBy","Color","HSLA","toUint32","arrayInsert","splitLines","IntervalTimer","dispose","DisposableStore","createProxyObject","getAllMethodNames","FileAccess","__vitePreload","stringDiff","StopWatch","MovingAverage","doHash","clamp","SlidingWindowAverage","matchesScheme","normalize","match","escape","Schemas","DataUri","basename","parse","posix","startsWithUTF8BOM","regExpLeadsToEndlessLoop","firstOrDefault","observableFromEvent","Event","RGBA","ResourceMap","BidirectionalMap","diffSets","isFullWidthCharacter","isEmojiImprecise","GraphemeIterator","NotSupportedError","ArrayQueue","CallbackIterable","MutableDisposable","writeUInt32BE","writeUInt16LE","readUInt32BE","basename$1","writeUInt8","readUInt8","findLast","containsRTL","containsUnusualLineTerminators","UTF8_BOM_CHARACTER","runWhenGlobalIdle","setTimeout0","RunOnceScheduler","DisposableMap","combinedDisposable","singleLetterHash","illegalArgument","UNUSUAL_LINE_TERMINATORS","htmlAttributeEncodeValue","OS","StringSHA1","prevCharLength","nextCharLength","getLeftDeleteOffset","isLowerAsciiLetter","isAsciiDigit","isUpperAsciiLetter","isObject","isString","isUndefined","isBoolean","isNumber","markAsSingleton","isLowSurrogate","findFirstMin","findLastMax","commonPrefixLength","commonSuffixLength","Scrollable","isWindows","ThemeIcon","VSBuffer","createDecorator","Registry","Extensions$1","IConfigurationService","registerSingleton","ILogService","IEnvironmentService","IThemeService","registerColor","contrastBorder","activeContrastBorder","editorFindMatchHighlight","editorBackground","editorWarningBorder","editorWarningForeground","editorInfoBorder","editorInfoForeground","editorWarningBackground","registerThemingParticipant","IMarkerService","MarkerSeverity$1","themeColorFromId","minimapError","minimapWarning","minimapInfo","IUndoRedoService","IInstantiationService","RawContextKey","FileKind","EDITOR_MODEL_DEFAULTS","USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","source","sep","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","result","flags","_defaultConfig","getWordAtText","column","text","textOffset","config","start","t1","pos","prevRegexIndex","i","regexIndex","thisMatch","_findRegexMatchEnclosingPosition","stopPos","matchIndex","MINIMAP_GUTTER_WIDTH","ConfigurationChangedEvent","values","id","ComputeOptionsMemory","BaseEditorOption","name","defaultValue","schema","value","update","applyUpdate","env","options","ApplyUpdateResult","newValue","didChange","arrayEquals","arrays.equals","key","ComputedEditorOption","input","SimpleEditorOption","boolean","EditorBooleanOption","clampedInt","minimum","maximum","r","EditorIntOption","clampedFloat","EditorFloatOption","n","min","max","validationFn","EditorStringOption","stringSet","allowedValues","renamedValues","EditorStringEnumOption","EditorEnumOption","defaultStringValue","convert","_autoIndentFromString","autoIndent","EditorAccessibilitySupport","nls.localize","EditorComments","defaults","_input","_cursorBlinkingStyleFromString","cursorBlinkingStyle","TextEditorCursorStyle","_cursorStyleFromString","cursorStyle","EditorClassName","_","classNames","EditorEmptySelectionClipboard","EditorFind","platform.isMacintosh","_EditorFontLigatures","EditorFontLigatures","_EditorFontVariations","EditorFontVariations","EditorFontInfo","EditorFontSize","EDITOR_FONT_DEFAULTS","_EditorFontWeight","EditorFontWeight","EditorGoToLocation","jsonSubset","alternativeCommandOptions","EditorHover","EditorLayoutInfoComputer","typicalViewportLineCount","extraLinesBeforeFirstLine","extraLinesBeyondLastLine","desiredRatio","minimapLineCount","memory","outerWidth","outerHeight","pixelRatio","stableMinimapLayoutInput","couldUseMemory","lineHeight","typicalHalfwidthCharacterWidth","scrollBeyondLastLine","minimapRenderCharacters","minimapScale","minimapMaxColumn","minimapSize","minimapSide","verticalScrollbarWidth","viewLineCount","remainingWidth","isViewportWrapping","baseCharHeight","minimapCanvasInnerHeight","minimapCanvasOuterHeight","minimapHeightIsEditorHeight","minimapIsSampling","minimapLineHeight","minimapCharWidth","minimapWidthMultiplier","fitBecomesFill","maxMinimapScale","effectiveMinimapHeight","configuredMinimapScale","minimapMaxWidth","minimapWidth","minimapCanvasInnerWidth","minimapCanvasOuterWidth","renderMinimap","minimapLeft","lineNumbersDigitCount","maxDigitWidth","wordWrapOverride2","wordWrapOverride1","wordWrap","wordWrapColumn","isDominatedByLongLines","showGlyphMargin","showLineNumbers","lineNumbersMinChars","padding","minimap","scrollbar","verticalScrollbarHasArrows","scrollbarArrowSize","horizontalScrollbarHeight","folding","showFoldingDecoration","lineDecorationsWidth","lineNumbersWidth","digitCount","glyphMarginWidth","glyphMarginLeft","lineNumbersLeft","decorationsLeft","contentLeft","isWordWrapMinified","wrappingColumn","minimapLayout","contentWidth","viewportColumn","verticalArrowSize","WrappingStrategy","ShowLightbulbIconMode","EditorLightbulb","EditorStickyScroll","EditorInlayHints","EditorLineDecorationsWidth","EditorLineHeight","x","EditorMinimap","_multiCursorModifierFromString","multiCursorModifier","EditorPadding","EditorParameterHints","EditorPixelRatio","PlaceholderOption","EditorQuickSuggestions","types","other","comments","strings","validatedOther","validatedComments","validatedStrings","EditorRenderLineNumbersOption","lineNumbers","renderType","renderFn","filterValidationDecorations","renderValidationDecorations","EditorRulers","columnSchema","rulers","_element","element","a","b","ReadonlyMessage","_scrollbarVisibilityFromString","visibility","EditorScrollbar","horizontalScrollbarSize","verticalScrollbarSize","inUntrustedWorkspace","unicodeHighlightConfigKeys","UnicodeHighlight","objects.equals","primitiveSet","map","InlineEditorSuggest","InlineEditorEdit","BracketPairColorization","GuideOptions","idx","EditorSuggest","SmartSelect","WordSegmenterLocales","validLocales","locale","WrappingIndentOption","EditorWrappingInfoComputer","layoutInfo","EditorDropIntoEditor","EditorPasteAs","DEFAULT_WINDOWS_FONT_FAMILY","DEFAULT_MAC_FONT_FAMILY","DEFAULT_LINUX_FONT_FAMILY","platform.isLinux","editorOptionsRegistry","register","option","EditorOptions","Position","lineNumber","newLineNumber","newColumn","deltaLineNumber","deltaColumn","aLineNumber","bLineNumber","aColumn","bColumn","obj","Range","startLineNumber","startColumn","endLineNumber","endColumn","range","position","otherRange","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","lineCount","end","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","Selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","direction","sel","len","TokenizationRegistry$1","languageIds","languageId","support","factory","_a","myData","TokenizationSupportFactoryData","v","tokenizationSupport","colorMap","_registry","_languageId","_factory","Token$1","offset","type","language","TokenizationResult","tokens","endState","EncodedTokenizationResult","HoverVerbosityAction","CompletionItemKinds","byKind","toIcon","kind","codicon","data","fromString","strict","res","InlineCompletionTriggerKind","SelectedSuggestionInfo","completionKind","isSnippetText","DocumentPasteTriggerKind","SignatureHelpTriggerKind","DocumentHighlightKind","isLocationLink","thing","symbolKindNames","getAriaLabelForSymbol","symbolName","SymbolKinds","icon","_FoldingRangeKind","FoldingRangeKind","NewSymbolNameTag","NewSymbolNameTriggerKind","Command","is","InlayHintKind","LazyTokenizationSupport","createSupport","TokenizationRegistry","TokenizationRegistryImpl","TreeSitterTokenizationRegistry","InlineEditTriggerKind","AccessibilitySupport","CodeActionTriggerType","CompletionItemInsertTextRule","CompletionItemKind","CompletionItemTag","CompletionTriggerKind","ContentWidgetPositionPreference","CursorChangeReason","DefaultEndOfLine","EditorAutoIndentStrategy","EditorOption","EndOfLinePreference","EndOfLineSequence","GlyphMarginLane","IndentAction","InjectedTextCursorStops","KeyCode","MarkerSeverity","MarkerTag","MinimapPosition","MinimapSectionHeaderStyle","MouseTargetType","OverlayWidgetPositionPreference","OverviewRulerLane","PartialAcceptTriggerKind","PositionAffinity","RenderLineNumbersType","RenderMinimap","ScrollType","ScrollbarVisibility","SelectionDirection","SymbolKind","SymbolTag","TextEditorCursorBlinkingStyle","TrackedRangeStickiness","WrappingIndent","_KeyMod","firstPart","secondPart","KeyMod","createMonacoBaseAPI","standaloneEnums.KeyCode","standaloneEnums.SelectionDirection","standaloneEnums.MarkerSeverity","standaloneEnums.MarkerTag","Token","EditorZoom","zoomLevel","GOLDEN_LINE_HEIGHT_RATIO","MINIMUM_LINE_HEIGHT","BareFontInfo","ignoreEditorZoom","fontFamily","fontWeight","fontSize","fontFeatureSettings","fontVariationSettings","letterSpacing","editorZoomLevelMultiplier","opts","fallbackFontFamily","SERIALIZED_FONT_INFO_VERSION","FontInfo","isTrusted","IModelService","ITextModelService","StandardAutoClosingPairConditional","standardToken","context","tokenIndex","standardTokenType","fromCharCode","toCharCode","charCode","character","AutoClosingPairs","autoClosingPairs","pair","appendEntry","target","_CharacterPairSupport","el","docComment","forQuotes","CharacterPairSupport","createScopedLineTokens","tokenCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","actual","firstCharOffset","lastCharOffset","ignoreBracketsInToken","_utf16LE_TextDecoder","getUTF16LE_TextDecoder","_utf16BE_TextDecoder","getUTF16BE_TextDecoder","_platformTextDecoder","getPlatformTextDecoder","platform.isLittleEndian","decodeUTF16LE","view","compatDecodeUTF16LE","resultLen","buffer.readUInt16LE","StringBuilder","capacity","bufferString","remainingSpace","strings.isHighSurrogate","str","strLen","RichEditBracket","index","open","close","forwardRegex","reversedRegex","arr","groupFuzzyBrackets","brackets","N","group","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","j","g","currentOpen","currentClose","RichEditBrackets","_brackets","getRegexForBracketPair","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","bracket","collectSuperstrings","currentIndex","dest","lengthcmp","unique","seen","pieces","createBracketOrRegExp","toReversedString","prepareBracketForRegExp","insertWordBoundaries","strings.escapeRegExpCharacters","regexStr","strings.createRegExp","reverse","stringBuilder.getPlatformTextDecoder","lastInput","lastOutput","BracketsUtils","reversedBracketRegex","reversedText","m","matchOffset","matchLength","absoluteMatchOffset","lineText","startOffset","endOffset","reversedSubstr","bracketRegex","substr","BracketElectricCharacterSupport","richEditBrackets","lastChar","bracketText","textBeforeBracket","resetGlobalRegex","reg","IndentRulesSupport","indentationRules","ret","OnEnterSupport","openRegExp","closeRegExp","previousLineText","beforeEnterText","afterEnterText","rule","def","err","ILanguageService","Extensions","EditorModesRegistry","ModesRegistry","PLAINTEXT_LANGUAGE_ID","PLAINTEXT_EXTENSION","ConfigurationExtensions","LanguageBracketsConfiguration","bracketPairs","filterValidBrackets","openingBracketInfos","closing","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","colorizedBracketPairs","p","k","BracketKindBase","openedBrackets","openingBrackets","openingColorizedBrackets","__decorate","decorators","desc","c","d","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","ILanguageConfigurationService","LanguageConfigurationService","configurationService","languageService","LanguageConfigurationRegistry","languageConfigKeys","customizedLanguageConfigKeys","e","globalConfigChanged","localConfigChanged","overrideLangName","keys","configuration","priority","computeConfig","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","getCustomizedLanguageConfig","combineLanguageConfigurations","validateBracketPairs","getIndentationAtPosition","model","indentation","strings.getLeadingWhitespace","ComposedLanguageConfiguration","entry","LanguageConfigurationContribution","configs","order","LanguageConfigurationChangeEvent","entries","disposable","underlyingConfig","conf","commentRule","blockStart","blockEnd","CharacterClassifier","_defaultValue","asciiMap","_value","CharacterSet","Uint8Matrix","rows","cols","row","col","StateMachine","edges","maxCharCode","maxState","from","chCode","to","states","currentState","_stateMachine","getStateMachine","_classifier","getClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","LinkComputer","classifier","line","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeBeforeLink","lastCharCodeInLink","stateMachine","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","computeLinks","_BasicInplaceReplace","range1","text1","range2","text2","up","numberResult","precision","n1","n2","valueSets","valueSet","BasicInplaceReplace","_EditorWorkerHost","workerServer","workerClient","EditorWorkerHost","WordCharacterClassifier","wordSeparators","intlSegmenterLocales","candidate","segment","lineContent","segments","wordClassifierCache","getMapForWordSeparators","TextModelResolvedOptions","src","newOpts","FindMatch","matches","isITextSnapshot","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","SearchData","regex","simpleSearch","ApplyEditsResult","reverseEdits","changes","trimAutoWhitespaceLineNumbers","shouldSynchronizeModel","LIMIT_FIND_COUNT","SearchParams","searchString","isRegex","matchCase","multiline","isMultilineRegexSource","canUseSimpleSearch","nextChCode","createFindMatch","rawMatches","captureMatches","LineFeedCounter","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","mid","TextModelSearch","searchParams","searchRange","limitResultCount","searchData","Searcher","deltaOffset","lfCounter","match0","lineFeedCountBeforeMatch","lineFeedCountInMatch","startPosition","endPosition","searcher","counter","searchStringLen","textLength","lastMatchIndex","isValidMatch","searchStart","searchTextStart","lineIndex","fromColumn","bestResult","leftIsWordBounday","matchStartIndex","charBefore","firstCharInMatch","rightIsWordBounday","charAfter","lastCharInMatch","searchRegex","lastIndex","strings.getNextCodePoint","UnicodeTextModelHighlighter","startLine","endLine","codePointHighlighter","CodePointHighlighter","candidates","buildRegExpCharClassExpr","ranges","hasMore","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","forLoop","lineLength","startIndex","endIndex","charCodeBefore","word","highlightReason","char","codePoint","primaryConfusable","notAmbiguousInLocales","strings.AmbiguousCharacters","codePoints","set","cp","strings.InvisibleCharacters","isAllowedInvisibleCharacter","wordContext","hasBasicASCIICharacters","hasNonConfusableNonBasicAsciiCharacter","strings.isBasicASCII","LinesDiff","moves","hitTimeout","MovedText","lineRangeMapping","OffsetRange","sortedRanges","endExclusive","length","f","OffsetRangeSet","intersection","prev","cur","LineRange$1","LineRange","lineRanges","LineRangeSet","endLineNumberExclusive","lineRange","_normalizedRanges","joinRangeStartIdx","joinRangeEndIdxExclusive","joinRange","rangeThatStartsBeforeEnd","i1","i2","current","next","lineRange1","lineRange2","r1","r2","_TextLength","position1","position2","columnCount","TextLength","PositionOffsetTransformer","lineIdx","TextEdit","edits","lastEditEnd","edit","editRange","editStart","editEnd","rangeFromPositions","strText","StringText","newRanges","previousEditEndLineNumber","lineOffset","columnOffset","newRangeStart","newRange","SingleTextEdit","AbstractText","LineRangeMapping","mapping","originalLineCount","modifiedLineCount","lastOriginalEndLineNumber","lastModifiedEndLineNumber","originalRange","modifiedRange","original","modified","origInclusiveRange","modInclusiveRange","RangeMapping","isValidLineNumber","normalizePosition","content","lines","DetailedLineRangeMapping","rangeMappings","innerChanges","previous","newText","MINIMUM_MATCHING_CHARACTER_LENGTH","LegacyLinesDiffComputer","originalLines","modifiedLines","DiffComputer","lastChange","change","m1","m2","computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LineSequence$1","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","elements","shouldIgnoreTrimWhitespace","charCodes","columns","CharSequence","s","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","diffChange","originalCharSequence","modifiedCharSequence","postProcessCharChanges","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","LineChange","charChanges","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","LineSequence","createContinueProcessingPredicate","diffResult","quitEarly","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","originalChar","modifiedChar","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","txt","strings.firstNonWhitespaceIndex","strings.lastNonWhitespaceIndex","maximumRuntime","startTime","DiffAlgorithmResult","seq1","seq2","SequenceDiff","diffs","sequenceDiffs","doc1Length","OffsetPair","last","seq1Range","seq2Range","_OffsetPair","offset1","offset2","_InfiniteTimeout","InfiniteTimeout","DateTimeout","timeout","Array2D","width","height","y","isSpace","_LineRangeFragment","chr","sumDifferences","maxLength","LineRangeFragment","DynamicProgrammingDiffing","sequence1","sequence2","equalityScore","lcsLengths","directions","lengths","s1","s2","horizontalLen","verticalLen","extendedSeqScore","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","MyersDiffAlgorithm","seqX","seqY","getXAfterSnake","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","loop","lowerBound","upperBound","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","LinesSliceCharSequence","considerWhitespaceChanges","lineStartOffset","trimmedWsLength","trimmedStartLine","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","preference","pos1","pos2","isWordChar","category","computeMovedLines","hashedOriginalLines","hashedModifiedLines","excludedChanges","computeMovesFromSimpleDeletionsToSimpleInsertions","filteredChanges","unchangedMoves","computeUnchangedMoves","joinCloseConsecutiveMoves","l","countWhere","removeMovesInSameDiff","predicate","count","t","deletions","insertions","deletion","highestSimilarity","best","insertion","similarity","original3LineHashes","possibleMappings","lastMappings","currentModifiedRange","nextMappings","lastMapping","modifiedSet","originalSet","diffOrigToMod","modifiedSections","originalTranslatedSections","modifiedIntersectedSections","modifiedLineRange","originalLineRange","monotonousChanges","move","firstTouchingChangeOrig","firstTouchingChangeMod","linesAbove","lastTouchingChangeOrig","lastTouchingChangeMod","linesBelow","extendToTop","origLine","modLine","areLinesSimilar","extendToBottom","line1","line2","commonNonSpaceCharCount","inverted","seq","countNonWsChars","longerLineLength","originalDist","modifiedDist","changesMonotonous","diffBeforeEndOfMoveOriginal","diffBeforeEndOfMoveModified","optimizeSequenceDiffs","joinSequenceDiffsByShifting","shiftSequenceDiffs","prevResult","result2","nextResult","prevDiff","diff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","deltaBefore","deltaAfter","bestDelta","bestScore","delta","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","removeShortMatches","extendDiffsToEntireWordIfAppropriate","equalMappings","additional","lastPoint","scanWord","equalMapping","w1","w2","w","equalPart","equalChars1","equalChars2","v1","v2","mergeSequenceDiffs","sequenceDiffs1","sequenceDiffs2","sd1","sd2","removeVeryShortMatchingLinesBetweenDiffs","_sequence2","shouldRepeat","shouldJoinDiffs","before","after","unchangedRange","lastResult","removeVeryShortMatchingTextBetweenLongDiffs","unchangedText","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","cap","newDiffs","newDiff","shouldMarkAsChanged","fullRange1","prefix","suffix","availableSpace","trimmedHash","indentationBefore","getIndentation","indentationAfter","DefaultLinesDiffComputer","perfectHashes","getOrCreateHash","hash","originalLinesHashes","modifiedLinesHashes","lineAlignmentResult","lineAlignments","alignments","scanForWhitespaceChanges","equalLinesCount","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","lineRangeMappingFromRangeMappings","validatePosition","validateRange","ic","moveChanges","mappings","rangeMapping","toLineRangeMapping","slice1","slice2","dontAssertStartLine","getLineRangeMapping","a1","a2","first","lineStartDelta","lineEndDelta","sequenceDiff","linesDiffComputers","_parseCaptureGroups","captureGroups","captureGroup","parsedNumber","_toIColor","_findRange","_findHexColorInformation","hexValue","parsedHexColor","_findRGBColorInformation","isAlpha","parsedRegex","_findHSLColorInformation","colorEquivalent","_findMatches","computeColors","initialValidationMatches","initialMatch","initialCaptureGroups","colorScheme","colorParameters","colorInformation","regexParameters","computeDefaultDocumentColors","markRegex","trimDashesRegex","findSectionHeaders","headers","regionHeaders","collectRegionHeaders","markHeaders","collectMarkHeaders","sectionHeader","getHeaderText","addMarkHeaderIfFound","sectionHeaders","hasSeparatorLine","PrefixSumComputer","insertIndex","insertValues","oldValues","oldPrefixSum","insertValuesLen","maxCount","sum","low","high","midStop","midStart","PrefixSumIndexOfResult","ConstantTimePrefixSumComputer","viewLinesAbove","deleteCount","insertArr","sumAbove","remainder","MirrorTextModel","uri","eol","versionId","eolLength","linesLength","lineStartValues","insertText","insertLines","newLengths","STOP_SYNC_MODEL_DELTA_TIME_MS","WorkerTextModelSyncClient","proxy","modelService","keepIdleModels","timer","modelUrl","resources","forceLargeModels","resource","resourceStr","currentTime","toRemove","toDispose","WorkerTextModelSyncServer","all","MirrorModel","BaseMirrorModel","offsetToAdd","iteratorOverMatches","wordAtText","wordenize","wordRangesIdx","wordRanges","words","lineEnding","startLineIndex","endLineIndex","resultLines","out","hasChanged","maxCharacter","_BaseEditorSimpleWorker","url","originalUrl","modifiedUrl","algorithm","EditorSimpleWorker","originalTextModel","modifiedTextModel","diffAlgorithm","identical","getLineChanges","lastEol","aRng","bRng","writeIndex","readIndex","editOffset","newEdit","modelUrls","leadingWord","wordDef","wordDefFlags","sw","wordDefRegExp","outer","array","selectionText","wordRange","BaseEditorSimpleWorker","_host","_foreignModuleFactory","moduleId","createData","foreignHostMethods","ctx","method","args","resolve","reject","onModuleCallback","foreignModule","ITextResourceConfigurationService","ITextResourcePropertiesService","ILanguageFeaturesService","ILanguageFeatureDebounceService","IdentityHash","_hashes","pool","of","NullDebounceInformation","_default","_model","FeatureDebounceInformation","_logService","_name","_min","_max","hashVal","avg","LanguageFeatureDebounceService","envService","feature","extra","info","TokenMetadata","metadata","className","fontStyle","foreground","textDecoration","countEOL","eolCount","firstLineLength","lastLineStart","SparseMultilineTokens","SparseMultilineTokensStorage","deltaRange","bDeltaLine","lastLineLength","firstCharCode","firstLineIndex","lastLineIndex","deletedLinesCount","tokenMaxDeltaLine","deletedBefore","startChar","maxDeltaLine","endChar","deltaLine","midDeltaLine","SparseLineTokens","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","isInsertingPreciselyOneWordCharacter","tokenLength","SemanticTokensProviderStyling","_legend","_themeService","_languageService","HashTable","tokenTypeIndex","tokenModifierSet","encodedLanguageId","tokenType","tokenModifiers","modifierSet","modifierIndex","tokenStyle","italicBit","boldBit","underlineBit","strikethroughBit","foregroundBits","previousResultId","resultId","editIndex","maxExpectedStart","toMultilineTokens2","styling","srcData","tokensPerArea","lastLineNumber","lastStartCharacter","tokenStartIndex","tokenEndIndex","smallTokenEndIndex","bigTokenEndIndex","destData","areaLine","prevLineNumber","prevEndCharacter","deltaCharacter","HashTableEntry","_HashTable","oldElements","oldNext","ISemanticTokensStylingService","SemanticTokensStylingService","provider","selector","candidateUri","candidateLanguage","candidateIsSynchronized","candidateNotebookUri","candidateNotebookType","filter","pattern","scheme","hasAccessToAllModels","notebookType","normalizedPattern","matchGlobPattern","isExclusive","MatchCandidate","notebookUri","recursive","_b","LanguageFeatureRegistry","_notebookInfoResolver","lastBucket","lastBucketScore","callback","notebookInfo","isBuiltinSelector","LanguageFeaturesService","_LineTokens","decoder","defaultMetadata","fullText","sliceFromTokenIndex","sliceTokenCount","SliceLineTokens","lineTextLength","desiredIndex","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","LineTokens","tokenEndOffset","adjustedTokenIndex","tokenStartOffset","getStandardTokenTypeAtPosition","lineTokens","NullState","nullTokenize","nullTokenizeEncoded","fallback","buffer","hasEOL","tokenizeToString","_tokenizeToString","tokenizeLineToHTML","viewLineTokens","tabSize","useNbsp","charIndex","tabsCharDelta","prevIsSpace","partContent","insertSpacesCount","languageIdCodec","strings.splitLines","tokenizationResult","lenJ","strings.escape","diffEditorDefaultOptions","editorConfigurationBaseNode","editorConfiguration","isConfigurationPropertySchema","editorOption","cachedEditorConfigurationKeys","getEditorConfigurationKeys","prop","isEditorConfigurationKey","isDiffEditorConfigurationKey","configurationRegistry","EditOperation","InspectTokensNLS","GoToLineNLS","QuickHelpNLS","QuickCommandNLS","QuickOutlineNLS","StandaloneCodeEditorNLS","ToggleHighContrastNLS","StandaloneServicesNLS","registeredAssociations","nonUserRegisteredAssociations","userRegisteredAssociations","registerPlatformLanguageAssociation","association","warnOnOverwrite","_registerLanguageAssociation","userConfigured","associationItem","toLanguageAssociationItem","clearPlatformLanguageAssociations","getLanguageIds","firstLine","getAssociations","item","filename","configuredLanguage","getAssociationByPath","registeredLanguage","firstlineLanguage","getAssociationByFirstline","associations","filenameMatch","patternMatch","extensionMatch","hasOwnProperty","NULL_LANGUAGE_ID","LanguageIdCodec","_LanguagesRegistry","useModesRegistry","langId","alias","mimetype","lang","resolvedLanguage","primaryMime","extension","filenamePattern","firstLineRegexStr","firstLineRegex","langAliases","langAlias","containsAliases","bestName","languageName","languageNameLower","mimeType","LanguagesRegistry","_LanguageService","LanguageSelection","LanguageService","onDidChangeLanguages","IEditorWorkerService","editorLineHighlight","editorLineHighlightBorder","editorCursorForeground","editorCursorBackground","editorMultiCursorPrimaryForeground","editorMultiCursorPrimaryBackground","editorMultiCursorSecondaryForeground","editorMultiCursorSecondaryBackground","editorWhitespaces","editorLineNumbers","deprecatedEditorIndentGuides","deprecatedEditorActiveIndentGuides","editorIndentGuide1","editorIndentGuide2","editorIndentGuide3","editorIndentGuide4","editorIndentGuide5","editorIndentGuide6","editorActiveIndentGuide1","editorActiveIndentGuide2","editorActiveIndentGuide3","editorActiveIndentGuide4","editorActiveIndentGuide5","editorActiveIndentGuide6","deprecatedEditorActiveLineNumber","editorDimmedLineNumber","editorOverviewRulerBorder","editorOverviewRulerBackground","editorUnnecessaryCodeOpacity","ghostTextForeground","rulerRangeDefault","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","overviewRulerInfo","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","theme","collector","background","lineHighlight","imeBackground","MarkerDecorationsService","_markerService","decoration","markerDecorations","changedResources","MarkerDecorations","marker","owner","markers","added","removed","oldIds","newDecorations","ids","removedMarker","rawMarker","maxColumn","minColumn","color","zIndex","inlineClassName","tag","IMarkerDecorationsService","CursorColumns","visibleColumn","strings.isFullWidthCharacter","strings.isEmojiImprecise","iterator","strings.GraphemeIterator","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","beforeDelta","indentSize","_normalizeIndentationFromWhitespace","insertSpaces","spacesCnt","tabsCnt","normalizeIndentation","BracketInfo","nestingLevel","nestingLevelOfEqualBracketType","isInvalid","BracketPairInfo","openingBracketRange","closingBracketRange","bracketPairNode","BracketPairWithMinIndentationInfo","minVisibleColumnIndentation","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","toLength","lengthZero","lengthIsZero","factor","lengthToObj","lengthGetLineCount","lengthAdd","l1","l2","sumLengths","items","lengthFn","lengthEquals","length1","length2","lengthDiffNonNegative","lineCount1","lineCount2","colCount2","colCount1","lengthLessThan","lengthLessThanEqual","lengthGreaterThanEqual","positionToLength","lengthsToRange","lengthStart","lengthEnd","colCount","lengthOfString","TextEditInfo","newLength","BeforeEditPositionMapper","TextEditInfoCache","nextEdit","nextChangeOffset","oldOffsetObj","newOffset","offsetObj","nextEditEndOffsetInCur","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","lineDelta","previousColumnDelta","columnDelta","emptyArr","_SmallImmutableSet","additionalItems","cached","keyProvider","newItem","newItems","merged","item1","item2","SmallImmutableSet","identityKeyProvider","DenseKeyProvider","existing","BaseAstNode","PairAstNode","openingBracket","child","closingBracket","missingOpeningBracketIds","openBracketIds","textModel","ListAstNode","item3","immutable","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","listHeight","_missingOpeningBracketIds","childCount","lastChild","mutable","firstChild","lastLength","unopenedBrackets","minIndentation","childOffset","node","_item1","_item2","_item3","ArrayListAstNode","_children","children","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","firstNonWsColumn","BracketAstNode","bracketInfo","bracketIds","InvalidBracketAstNode","closingBrackets","openedBracketIds","bracketId","astNode","TextBufferTokenizer","bracketTokens","NonPeekableTextBufferTokenizer","token","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","isOther","containsBracketType","regexp","FastTokenizer","regExpStr","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","curOffset","BracketTokens","denseKeyProvider","getId","openingTextId","openingBracketIds","closingText","escaped","LanguageAgnosticBracketTokens","getLanguageConfiguration","singleLanguageBracketTokens","concat23Trees","readNode","concat23TreesOfSameHeight","second","heightDiff","concat","createImmutableLists","node1","node2","append","prepend","list","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","parent","nodeToPrependOfCorrectHeight","NodeReader","lastOrUndefined","curNodeOffset","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","parseDocument","tokenizer","oldNode","Parser","level","maxCacheableLength","cachedNode","nextToken","combineTextEditInfos","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","toLengthMapping","s1ToS2Map","curItem","nextS0ToS1MapWithS1LengthOf","s1Length","remainingItem","LengthMapping","pushEdit","s0offset","s1ToS2","s0Length","s0EndOffset","s0startOffset","lengthBefore","lengthAfter","remainingLengthAfter","textEditInfos","lastOffset","textEditInfo","spaceLength","BracketPairsTree","wasUndefined","tokenChange","previousAst","previousAstClone","onlyColorizedBrackets","cb","collectBrackets","includeMinIndentation","startLength","endLength","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","push","levelPerBracketType","parentPairIsIncomplete","whileLoop","colorize","levelPerBracket","shouldContinue","openingBracketEnd","BracketPairsTextModelPart","languageConfigurationService","store","createDisposableRef","_bracket","_position","maxDuration","closingBracketInfo","bracketPair","bracketsSupport","stripBracketSearchCanceled","createTimeBasedContinueBracketSearchPredicate","continueSearchPredicate","modeBrackets","currentLanguageId","searchStartOffset","searchEndOffset","currentModeBrackets","foundBracket","foundBracketText","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","isOpen","matched","totalCallCount","searchPrevMatchingBracketInRange","hitText","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","bracketConfig","tokenLanguageId","savedCounts","counts","resetCounts","tmp","searchInRange","object","_BracketSearchCanceled","ColorizedBracketPairsDecorationProvider","ColorProvider","ownerId","filterOutValidation","onlyMinimapDecorations","independentColorPoolPerBracketType","colors","colorProvider","colorValues","escapeNewLine","TextChange","oldPosition","oldText","newPosition","buffer.writeUInt32BE","buffer.writeUInt16LE","buffer.readUInt32BE","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","prevIndex","currIndex","prevEdit","currEdit","e1","e2","mergePrev","mergeCurr","prevDeltaOffset","currDeltaOffset","preText","postText","curr","uriGetComparisonKey","SingleModelEditStackData","beforeCursorState","alternativeVersionId","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","selections","selection","necessarySize","buffer.writeUInt8","buffer.readUInt8","changeCount","SingleModelEditStackElement","label","code","MultiModelEditStackElement","editStackElement","editStackElements","isEditStackElement","EditStack","undoRedoService","lastElement","newElement","editOperations","cursorStateComputer","inverseEditOperations","op","TextModelPart","computeIndentLevel","indent","HorizontalGuidesState","IndentGuide","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","IndentGuideHorizontalLine","top","GuidesTextModelPart","minLineNumber","maxLineNumber","foldingRules","offSide","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","downLineIndentLevel","activePosition","includeSingleLinePairs","activeBracketPairRange","bracketsContainingActivePosition","bp","BracketPairGuidesClassNames","isActive","horizontalGuides","endVisibleColumn","startVisibleColumn","guideVisibleColumn","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","guides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","SpacesDiffResult","spacesDiff","aLength","bLength","aCharCode","bCharCode","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","MAX_ALLOWED_TAB_SIZE_GUESS","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","absoluteStart","absoluteEnd","cachedVersionId","SENTINEL","IntervalTree","filterOwnerId","onlyMarginDecorations","intervalSearch","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","rbTreeDelete","initialNode","nodeStart","nodeEnd","nodesOfInterest","searchForEditing","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","nodeMaxEnd","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","intervalCompare","leftest","resetSentinel","yWasRed","computeMaxEnd","maxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","TreeNode","piece","righttest","calculateSize","calculateLF","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","LineStarts","lineStarts","cr","lf","crlf","createLineStartsFast","readonly","rLength","createLineStarts","Piece","bufferIndex","lineFeedCnt","StringBuffer","PieceTreeSnapshot","BOM","PieceTreeSearchCache","limit","nodePos","nodePosition","hasInvalidVal","newArr","PieceTreeBase","chunks","eolNormalized","lastNode","averageBufferSize","tempChunk","tempChunkLen","newEOL","leftLen","accumualtedValInCurrentIndex","lfCnt","originalOffset","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","matchingNode","targetOffset","startCursor","endCursor","startOffsetInBuffer","searchText","offsetInBuffer","retStartColumn","retEndColumn","lineBreakCnt","nextLineStartOffset","nodeStartOffset","insertPosInBuffer","nodesToDel","newRightPiece","newStart","previousPos","newPieces","tmpNode","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","secondNode","nPiece","previousCharOffset","cursor","nodes","splitText","endPos","newPiece","cache","prevAccumulatedValue","accumulatedValue","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","newEnd","newEndOffset","newLineFeedCnt","size_delta","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","oldLineFeedCnt","prevAccumualtedValue","val","nextNode","prevNewLength","prevNewLFCnt","leftRet","prevNode","PieceTreeTextBuffer","preserveBOM","eolOffsetCompensation","desiredEOL","actualEOL","fromLineNumber","toLineNumber","fromOffset","toOffset","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","mightContainRTL","mightContainUnusualLineTerminators","mightContainNonBasicASCII","canReduceOperations","operations","validatedRange","textMightContainNonBasicASCII","strings.containsRTL","strings.containsUnusualLineTerminators","validText","strEOL","bufferEOL","hasTouchingRanges","rangeEnd","nextRangeStart","reverseRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","contentChanges","prevContent","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","PieceTreeTextBufferBuilder","chunk","strings.startsWithUTF8BOM","strings.UTF8_BOM_CHARACTER","allowEmptyStrings","normalizeEOL","lastChunk","newLineStarts","FixedArray","arrayFill","deleteIndex","insertCount","ContiguousMultilineTokens","ContiguousMultilineTokensBuilder","TokenizerWithStateStore","TrackingTokenizationStateStore","TokenizerWithStateStoreAndTextModel","_textModel","_languageIdCodec","builder","lineToTokenize","safeTokenize","lineStartState","curLineContent","newLineContent","firstInvalidLineNumber","nonWhitespaceColumn","likelyRelevantLines","initialState","newNonWhitespaceIndex","TokenizationStateStore","RangePriorityQueueImpl","newLineCount","startState","oldState","idxFirstMightBeIntersecting","idxFirstIsAfter","endEx","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","deadline","endTime","execute","firstInvalidLine","AttachedViews","AttachedViewImpl","handleStateChange","visibleLines","stabilized","visibleLineRanges","AttachedViewHandler","_refreshTokens","AbstractTokens","getLanguageId","TreeSitterTokens","_treeSitterService","newLanguage","rawTokens","fireTokenChangeEvent","ITreeSitterParserService","EMPTY_LINE_TOKENS","ContiguousTokensEditing","toChIndex","fromChIndex","toUint32Array","tokensCount","fromTokenIndex","fromTokenStartOffset","fromTokenEndOffset","lastEnd","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","ContiguousTokensStore","topLevelLanguageId","rawLineTokens","getDefaultMetadata","_tokens","hasDifferentLanguageId","arrays.arrayInsert","checkEquality","oldTokens","lastLineTokens","minChangedLineNumber","maxChangedLineNumber","hasChange","SparseTokensStore","isComplete","_range","_firstRange","_lastRange","insertPosition","pieceIndex","aLen","bLen","aIndex","lastEndOffset","emitToken","bIndex","bStartCharacter","bEndCharacter","bMetadata","bMask","aMask","aMergeIndex","TokenizationTextModelPart_1","TokenizationTextModelPart","_bracketPairsTextModelPart","_attachedViews","_languageConfigurationService","GrammarTokens","useTreeSitter","needsReset","syntacticTokens","changedRange","rbStartOffset","rbEndOffset","rightBiasedWord","lbStartOffset","lbEndOffset","leftBiasedWord","wordAtPosition","attachedViews","initializeTokenization","newState","firstInvalidEndStateLineNumber","_c","heuristicTokens","changedTokens","backgroundResult","validatedPosition","ModelRawFlush","LineInjectedText","injectedTexts","lastOriginalOffset","injectedText","decorations","ModelRawLineChanged","detail","ModelRawLinesDeleted","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","isUndoing","isRedoing","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","isFlush","isEolChange","TextModel_1","createTextBufferFactory","createTextBufferFactoryFromSnapshot","snapshot","createTextBuffer","model.isITextSnapshot","MODEL_ID","LONG_LINE_BOUNDARY","TextModelSnapshot","resultCnt","resultLength","invalidFunc","TextModel","guessedIndentation","model.TextModelResolvedOptions","listener","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","instantiationService","DidChangeDecorationsEmitter","affectedInjectedTextLines","DidChangeContentEmitter","bufferLineCount","bufferTextLength","strings.singleLetterHash","DecorationsTrees","emptyDisposedTextBuffer","rawChange","rangeOffset","rangeLength","textBufferDisposable","oldFullModelRange","oldModelValueLength","allDecorations","smallLineCharCount","longLineCharCount","_newOpts","trimAutoWhitespace","bracketPairColorizationOptions","strings.UNUSUAL_LINE_TERMINATORS","rawPosition","rawOffset","newAlternativeVersionId","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","rawRange","initialStartLineNumber","initialStartColumn","initialEndLineNumber","initialEndColumn","validationType","_lineNumber","_column","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","rawSearchScope","searchRanges","searchScope","d1","d2","uniqueSearchRanges","matchMapper","rawSearchStart","rawOperation","model.ValidAnnotatedEditOperation","incomingEdits","editsAreNearCursors","foundEditNearSel","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","trimRange","resultingAlternativeVersionId","resultingSelection","rangeStart","oldLineCount","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","injectedTextInEditedRange","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","newLines","lineChangeEvents","changeAccessor","_normalizeOptions","oldDecorations","newStickiness","TRACKED_RANGE_OPTIONS","decorationId","_startLineNumber","_endLineNumber","filterRange","oldRange","nodeWasInOverviewRuler","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","affinity","indentOfLine","isNodeInOverviewRuler","host","r0","overviewRulerOnly","cleanClassName","DecorationOptions","ModelDecorationOverviewRulerOptions","model.OverviewRulerLane","ModelDecorationGlyphMarginOptions","model.GlyphMarginLane","ModelDecorationMinimapOptions","ModelDecorationInjectedTextOptions","ModelDecorationOptions","strings.htmlAttributeEncodeValue","handleBeforeFire","event","ModelService_1","ModelData","onWillDispose","onDidChangeLanguage","DEFAULT_EOL","DisposedModelInfo","initialUndoRedoSnapshot","time","sharesUndoRedoStack","heapSize","sha1","ModelService","_configurationService","_resourcePropertiesService","_instantiationService","isForSimpleWidget","parsedTabSize","parsedIndentSize","newDefaultEOL","detectIndentation","largeFileOptimizations","platform.OS","editor","oldOptionsByLanguageAndResource","modelId","modelData","oldOptions","newOptions","currentOptions","disposedModelData","maxModelsHeapSize","disposedModels","disposedModel","sha1Computer","sha1IsEqual","languageSelection","maintainUndoRedoStack","maxMemory","oldLanguageId","newLanguageId","DefaultModelSHA1Computer","_DefaultModelSHA1Computer","shaComputer","ParsedTokenThemeRule","parseTokenTheme","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","ColorMap","foregroundColorId","backgroundColorId","ThemeTrieElementRule","root","ThemeTrieElement","TokenTheme","colorRegExp","toStandardTokenType","STANDARD_TOKEN_TYPE_REGEXP","mainRule","dotIndex","head","tail","generateTokensCSSForColorMap","rules","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","EditorType","LineDecoration","dec","lineDecorations","minLineColumn","ORDER","typeCmp","DecorationSegment","Stack","maxStopOffset","nextStartOffset","stopOffset","LineDecorationsNormalizer","stack","currentStartOffset","currentEndOffset","LinePart","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","continuesWithWrappedLine","fauxIndentLength","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","wsmiddotDiff","middotDiff","otherSelections","DomPosition","partIndex","CharacterMapping","partData","partCount","horizontalOffset","charOffset","domPosition","partLength","searchEntry","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","renderViewLine","sb","beforeCount","afterCount","lineDecoration","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","ResolvedRenderLineInput","fontIsMonospace","isOverflowing","overflowingCharCount","parts","renderSpaceCharCode","transformAndRemoveOverflowing","extractControlCharacters","_applyRenderWhitespace","_applyInlineDecorations","splitLargeTokens","lineContainsRTL","tokensLen","tokenContainsRTL","onlyAtSpaces","lastTokenEndIndex","lastSpaceOffset","currTokenStart","piecesCount","pieceEndIndex","isControlCharacter","lastLinePart","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokensLength","lineIsEmptyOrWhitespace","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","isInWhitespace","lastEndIndex","generateWhitespace","lastCharCode","prevCharCode","_lineDecorations","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastCharacterMappingDefined","charOffsetInPart","charHorizontalOffset","partDisplacement","part","partEndIndex","partType","partContainsRTL","partRendersWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","partWidth","_charIndex","_visibleColumn","charWidth","producedCharacters","space","to4CharHex","renderOverflowingCharCount","Viewport","left","MinimapLinesRenderingData","ViewLineData","inlineDecorations","ViewLineRenderingData","InlineDecoration","SingleLineInlineDecoration","inlineClassNameAffectsLetterSpacing","ViewModelDecoration","OverviewRulerDecorationsGroup","ViewEventHandler","events","shouldRender","AtomicTabMoveOperations","prevTabStopPosition","prevTabStopVisibleColumn","currentVisibleColumn","targetVisibleColumn","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","modelOptions","fontInfo","surroundingPairs","commentsConfiguration","electricChars","scopedLineTokens","electricCharacterSupport","autoCloseConfig","autoCloseBeforeSet","CursorState","modelState","PartialModelCursorState","viewState","PartialViewCursorState","modelSelection","SingleCursorState","modelSelections","selectionStart","selectionStartKind","selectionStartLeftoverVisibleColumns","leftoverVisibleColumns","inSelectionMode","EditOperationResult","commands","isQuote","ch","ColumnSelection","fromVisibleColumn","toVisibleColumn","reversed","isRTL","isLTR","visibleStartColumn","visibleEndColumn","prevColumnSelectData","toViewVisualColumn","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","toViewLineNumber","ReplaceCommand","insertsAutoWhitespace","helper","srcRange","ReplaceCommandThatSelectsText","ReplaceCommandWithoutChangingPosition","ReplaceCommandWithOffsetCursorState","lineNumberDeltaOffset","columnDeltaOffset","ReplaceCommandThatPreservesSelection","initialSelection","CursorPosition","MoveOperations","strings.prevCharLength","noOfColumns","normalizedPos","strings.nextCharLength","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","allowMoveOnFirstLine","firstNonBlankColumn","sticky","lastColumn","DeleteOperations","prevEditOperationType","shouldPushStackElementBefore","deleteSelection","rightOfPosition","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","autoClosedCharacters","autoClosingPairCandidates","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","found","autoClosedCharacter","deleteRange","lastIndentationColumn","toColumn","strings.getLeftDeleteOffset","newLine","lastCutRange","WordOperations","wordType","nextCharClass","intlWord","previousIntlWord","nextIntlWord","wordNavigationType","hasMulticursor","prevWordOnLine","right","strings.isLowerAsciiLetter","strings.isAsciiDigit","strings.isUpperAsciiLetter","rightRight","movedDown","nextWordOnLine","lastNonWhitespace","whitespaceHeuristics","leftIndex","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","toPosition","firstNonWhitespace","_wordSeparators","_intlSegmenterLocales","prevWord","nextWord","possiblePosition","WordPartOperations","enforceDefined","CursorMoveCommands","viewModel","cursors","useLogicalLine","currentViewStateColumn","currentModelStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_viewPosition","viewPosition","selectToLineNumber","selectToColumn","enteringLineNumber","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","unit","visibleViewRange","visibleModelRange","modelLineNumber","modelColumn","viewLineNumber","newViewLineNumber","halfLine","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","CursorMove","isCursorMoveArgs","arg","types.isObject","cursorMoveArg","types.isString","types.isUndefined","types.isBoolean","types.isNumber","ProcessedIndentRulesSupport","indentRulesSupport","IndentationLineProcessor","newIndentation","processedLine","IndentationContextProcessor","beforeRangeProcessedTokens","afterRangeProcessedTokens","previousLineProcessedTokens","slicedTokens","isLanguageDifferentFromLineStart","columnIndexWithinScope","firstCharacterOffset","lastCharacterOffset","columnWithinLine","getScopedLineTokensAtEndColumnOfLine","endColumnOfLine","emptyTokens","previousLineNumber","scopedLineTokensAtEndColumnOfPreviousLine","previousSlicedLineTokens","replaceIndentation","currentIndentation","shouldRemoveBracketsFromTokenType","bracketsRegExp","textAndMetadata","doesScopeStartAtOffsetZero","isScopedLanguageEqualToFirstLanguageOnLine","getEnterAction","richEditSupport","processedContextTokens","enterResult","indentAction","appendText","removeText","ShiftCommand_1","repeatCache","cachedStringRepeat","ShiftCommand","contentStartVisibleColumn","indentCount","shouldIndentEmptyLines","previousLineExtraSpaces","extraSpaces","indentationEndIndex","enterAction","desiredIndent","oneIndent","lastOp","SurroundSelectionCommand","charBeforeSelection","charAfterSelection","firstOperationRange","secondOperationRange","CompositionSurroundSelectionCommand","_text","_charAfter","opRange","getPrecedingValidLine","processedIndentRulesSupport","resultLineNumber","getInheritIndentForLine","honorIntentialIndent","priorLineNumber","precedingUnIgnoredLine","precedingUnIgnoredLineContent","previousLine","previousLineIndentMetadata","stopLine","getGoodIndentForLine","virtualModel","indentConverter","inheritLine","shouldApplyEnterRules","inBetweenLine","getIndentForEnter","afterEnterProcessedTokens","beforeEnterProcessedTokens","beforeEnterIndent","createVirtualModelWithModifiedTokensAtLine","languageIsDifferentFromLineStart","currentLineIndent","afterEnterAction","beforeEnter","afterEnterIndent","getIndentActionForType","cursorConfig","beforeRangeText","afterRangeText","textAroundRange","textAroundRangeWithCharacter","inheritedIndentationData","inheritedIndentation","actualCurrentIndentation","inferredIndentationEqualsActual","textAroundRangeContainsOnlyWhitespace","isChFirstNonWhitespaceCharacterAndInAutoClosingPair","getIndentMetadata","modifiedTokens","AutoIndentOperation","isDoingComposition","indentationForSelections","autoClosingPairClose","AutoClosingOpenCharTypeOperation","actualIndentation","shiftIndent","unshiftIndent","indentationEdit","TypeWithIndentationAndAutoClosingCommand","typeCommand","editOptions","includeChInEdit","firstNonWhitespaceColumn","AutoClosingOvertypeOperation","isAutoClosingOvertype","typeSelection","shouldPushStackElementBetween","AutoClosingOvertypeWithInterceptorsOperation","chIsAlreadyTyped","TypeWithAutoClosingCommand","positions","shouldAutoCloseBefore","containedPair","containedPairClose","isContainedPairPresent","lineBefore","lineAfter","characterAfter","characterBefore","neutralCharacter","candidateIsMatch","nextChar","potentialStartingBraces","potentialClosingBraces","isBeforeStartingBrace","isBeforeClosingBrace","SurroundSelectionOperation","closeCharacter","shouldSurroundChar","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","selectedText","InterceptorElectricCharOperation","electricAction","matchLine","matchLineIndentation","lineFirstNonBlankColumn","typeText","command","getTypingOperation","SimpleCharacterTypeOperation","opType","EnterOperation","keepPosition","normalIndent","increasedIndent","ir","oldEndViewColumn","oldEndColumn","PasteOperation","pasteOnNewLine","multicursorText","distributedPaste","CompositionOperation","replacePrevCharCnt","replaceNextCharCnt","positionDelta","TypeWithoutInterceptorsOperation","TabOperation","goodIndent","possibleTypeText","lineMaxColumn","action","expectedIndentAction","expectedEnterAction","visibleColumnFromColumn","BaseTypeWithAutoClosingCommand","openCharacter","insertOpenCharacter","autoIndentationEdit","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","chIsQuote","TypeOperations","compositions","insertedText","composition","hasDeletion","autoClosingOvertypeEdits","autoClosingOpenCharEdits","enterEdits","autoIndentEdits","autoClosingOverTypeEdits","surroundSelectionEdits","interceptorElectricCharOperation","CompositionOutcome","deletedText","deletedSelectionStart","deletedSelectionEnd","insertedSelectionStart","insertedSelectionEnd","EditorContextKeys","_RGBA8","RGBA8","_MinimapTokensColorTracker","colorId","backgroundLuminosity","MinimapTokensColorTracker","ColorZone","OverviewRulerZone","heightInLines","colorZone","OverviewZoneManager","getVerticalOffsetForLine","newZones","colorZonesInvalid","totalHeight","heightRatio","halfMinimumHeight","allColorZones","zone","y1","y2","ycenter","halfHeight","ViewportData","partialData","whitespaceViewportData","EditorTheme","ViewContext","eventHandler","ModelLineProjectionData","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","outputLineIndex","outputOffset","offsetInInput","inputOffset","inputOffsetInInputWithInjection","offsetInInputWithInjections","OutputPosition","normalizedOffsetInUnwrappedLine","maxOutputLineIndex","hasRightCursorStop","hasLeftCursorStop","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","baseLineNumber","InternalEditorAction","_precondition","_run","_contextKeyService","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","WrappingCharacterClassifier","wrappingIndent","wordBreak","requests","previousBreakingData","previousLineBreakData","columnsForFullWidthChar","createLineBreaksFromPreviousLineBreaks","createLineBreaks","arrPool1","arrPool2","BREAK_BEFORE","BREAK_AFTER","firstLineBreakColumn","isKeepAll","prevBreakingOffsets","prevBreakingOffsetsVisibleColumn","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","bestDistance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","strings.isLowSurrogate","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","tabCharacterWidth","numberOfAdditionalTabs","Cursor","cacheInput","cacheOutput","sStartPosition","sEndPosition","validPosition","validSStartPosition","validSEndPosition","viewSelectionStart","viewSelectionStart1","viewSelectionStart2","CursorCollection","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","removeCnt","removeIndex","sortedCursors","sortedCursorIndex","nextSelection","shouldMergeCursors","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingState","sortedCursor","CursorContext","coordinatesConverter","ViewCompositionStartEvent","ViewCompositionEndEvent","ViewConfigurationChangedEvent","ViewCursorStateChangedEvent","reason","ViewDecorationsChangedEvent","ViewFlushedEvent","ViewFocusChangedEvent","isFocused","ViewLanguageConfigurationEvent","ViewLineMappingChangedEvent","ViewLinesChangedEvent","ViewLinesDeletedEvent","ViewLinesInsertedEvent","ViewRevealRangeRequestEvent","minimalReveal","verticalType","revealHorizontal","scrollType","ViewScrollChangedEvent","ViewThemeChangedEvent","ViewTokensChangedEvent","ViewTokensColorsChangedEvent","ViewZonesChangedEvent$1","ViewModelEventDispatcher","mergeResult","ViewModelEventsCollector","outgoingEvents","viewEvents","outgoingEvent","eventHandlers","ContentSizeChangedEvent","oldContentWidth","oldContentHeight","contentHeight","FocusChangedEvent","oldHasFocus","hasFocus","ScrollChangedEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","scrollWidth","scrollLeft","scrollHeight","scrollTop","ViewZonesChangedEvent","HiddenAreasChangedEvent","CursorStateChangedEvent","oldSelections","oldModelVersionId","modelVersionId","reachedMaxCursorCount","ReadOnlyEditAttemptEvent","ModelDecorationsChangedEvent","ModelLanguageChangedEvent","ModelLanguageConfigurationChangedEvent","ModelContentChangedEvent","ModelOptionsChangedEvent","ModelTokensChangedEvent","CursorsController","eventsCollector","autoClosedAction","multiCursorLimit","CursorModelState","columnSelectData","viewPositions","revealViewRange","revealViewSelections","desiredSelections","hadFlushEvent","cursorState","selectionsFromMarkers","primaryCursor","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","autoClosedCharactersDecorations","autoClosedEnclosingDecorations","AutoClosedAction","opResult","CommandExecutor","viewSelections","newCursorState","indices","closeChar","autoClosingPairsCandidates","openChar","closeCharIndex","openCharIndex","autoClosingIndices","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","cursorChangeReason","CompositionState","compositionOutcome","charLength","newSelections","autoClosedActions","decorationRange","enclosingRanges","selectionsBefore","commandsData","loserCursorsMap","filteredOperations","selectionsAfter","groupedInverseEditOperations","minorBasedSorter","cursorSelections","losingCursors","losingCursorIndex","losingCursor","hadTrackedEditOperation","majorIdentifier","operationMinor","addEditOperation","editOperationBuilder","_selection","trackPreviousOnEmpty","previousOp","currentOp","loserMajor","CompositionLineState","startSelection","endSelection","commonPrefix","strings.commonPrefixLength","commonSuffix","strings.commonSuffixLength","PendingChanges","linesLayout","inserts","removes","EditorWhitespace","afterLineNumber","ordinal","minWidth","_LinesLayout","paddingTop","paddingBottom","hadAChange","heightInPx","newAfterLineNumber","newHeight","insert","remove","toChange","applyRemoveAndChange","whitespaces","whitespace","linesHeight","whitespacesHeight","lastWhitespaceBeforeLineNumber","halfDelta","firstWhitespaceAfterLineNumber","includeViewZones","previousLinesHeight","previousWhitespacesHeight","verticalOffset","midLineNumber","midLineNumberVerticalOffset","verticalOffset1","verticalOffset2","startLineNumberVerticalOffset","whitespaceIndex","whitespaceCount","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","bigNumbersDelta","linesOffsets","verticalCenter","centeredLineNumber","currentLineTop","currentLineBottom","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","minWhitespaceIndex","maxWhitespaceIndex","maxWhitespaceVerticalOffset","maxWhitespaceHeight","midWhitespaceIndex","midWhitespaceVerticalOffset","midWhitespaceHeight","candidateIndex","candidateTop","candidateHeight","candidateId","candidateAfterLineNumber","LinesLayout","SMOOTH_SCROLLING_TIME","EditorScrollDimensions","EditorScrollable","smoothScrollDuration","scheduleAtNextAnimationFrame","scrollPosition","dimensions","oldDimensions","contentWidthChanged","contentHeightChanged","ViewLayout","scrollDimensions","currentScrollPosition","maxLineWidth","wrappingInfo","extraHorizontalSpace","whitespaceMinWidth","maxMinWidth","firstLineNumberInViewport","whitespaceAboveFirstLine","visibleBox","deltaScrollLeft","deltaScrollTop","ViewModelDecorations","editorId","linesCollection","modelDecoration","modelRange","viewRange","cacheIsValid","modelDecorations","decorationsInViewport","decorationsInViewportLen","decorationOptions","isModelDecorationVisible","viewModelDecoration","inlineDecoration","intersectedStartLineNumber","intersectedEndLineNumber","isModelDecorationInComment","isModelDecorationInString","testTokensInRange","isFirstLine","isEndLine","tokenIdx","createModelLineProjection","lineBreakData","isVisible","IdentityModelLineProjection","HiddenModelLineProjection","ModelLineProjection","startOffsetInInputWithInjections","endOffsetInInputWithInjections","spaces","_modelLineNumber","outputLineIdx","globalStartIndex","needed","inlineDecorationsPerOutputLine","currentInjectedOffset","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","lineWithInjections","globalIndex","deltaStartIndex","outputColumn","inputColumn","outputPosition","baseViewLineNumber","_IdentityModelLineProjection","_outputLineIndex","_fromOuputLineIndex","_toOutputLineIndex","_inputColumn","_outputColumn","_HiddenModelLineProjection","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","_makeSpaces","ViewModelLinesFromProjectedModel","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","wrappingStrategy","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","linesContent","injectedTextDecorations","lineBreaksComputer","injectedTextQueue","arrays.ArrayQueue","lineInjectedText","linesBreaks","hiddenAreas","areaId","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","isInHiddenArea","decId","_ranges","validatedRanges","normalizeLineRanges","oldRanges","hasDifference","hasVisibleLine","lineChanged","newOutputLineCount","_modelColumn","newTabSize","equalFontInfo","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","equalWordBreak","onlyWrappingColumnChanged","outputFromLineNumber","outputToLineNumber","viewEvents.ViewLinesDeletedEvent","_toLineNumber","lineBreaks","totalOutputLineCount","insertPrefixSumValues","outputLineCount","viewEvents.ViewLinesInsertedEvent","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","viewEvents.ViewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","modelPosition","modelMinPosition","modelMaxPosition","viewStartPosition","viewEndPosition","ViewLineInfo","viewLineInfo","minViewColumn","maxViewColumn","viewStartLineNumber","viewEndLineNumber","startViewLine","endViewLine","lastVisibleModelPos","viewLines","curModelLine","lastVisibleModelPos2","ViewLineInfoGroupedByModelRange","activeViewPosition","modelActivePosition","resultPerViewLine","modelRangeStartLineNumber","bracketGuidesPerModelLine","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","viewLineEndIndex","viewIndents","blockAtIndex","startModelLineIndex","startRemainder","fromViewLineIndex","remainingViewLineCount","lastLine","expectedModelPosition","computedModelColumn","expectedModelRange","validViewStart","validViewEnd","allowZeroLineNumber","belowHiddenRanges","inputLineNumber","lineIndexChanged","finalResult","finalResultLen","prevDecId","currentRangeStart","currentRangeEnd","modelLineWrappedLineIdx","allowZero","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","_versionId","_minLineNumber","_maxLineNumber","_viewRange","MAX_LANE","GlyphMarginLanesModel","maxLine","bytes","lane","persist","bit","lanes","ViewModel","_attachedView","_transactionalTarget","HiddenAreasModel","ViewportStart","viewEvents.ViewScrollChangedEvent","viewEvents.ViewTokensColorsChangedEvent","viewEvents.ViewThemeChangedEvent","linesViewportData","viewVisibleRange","modelVisibleRanges","viewEvents.ViewFocusChangedEvent","viewEvents.ViewCompositionStartEvent","viewEvents.ViewCompositionEndEvent","previousViewportStartViewPosition","previousViewportStartModelPosition","StableViewport","stableViewport","viewEvents.ViewFlushedEvent","viewEvents.ViewLineMappingChangedEvent","viewEvents.ViewDecorationsChangedEvent","viewEvents.ViewConfigurationChangedEvent","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","textModelEvents.InternalModelContentChangeEvent","lineBreakQueue","linesDeletedEvent","insertedLineBreaks","linesInsertedEvent","changedLineBreakData","linesChangedEvent","viewportStartWasValid","viewPositionTop","viewRanges","viewEvents.ViewTokensChangedEvent","viewEvents.ViewLanguageConfigurationEvent","mergedRanges","firstModelLineInViewPort","linesAround","startViewLineNumber","endViewLineNumber","visibleRange","hiddenStartLineNumber","hiddenEndLineNumber","compatViewState","firstViewLineNumber","firstPosition","firstPositionDeltaTop","lineData","OverviewRulerDecorations","opts1","opts2","resultModelPosition","viewAnchorPosition","modelAnchor","resultOffset","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","hasEmptyRange","hasNonEmptyRange","modelLineNumbers","prevModelLineNumber","useDefaultFontFamily","platform.isWindows","viewEvents.ViewRevealRangeRequestEvent","viewEvents.ViewZonesChangedEvent","viewportStartLineTrackedRange","_viewLineNumber","_isValid","_modelTrackedRange","_startLineDelta","viewportStartLineTop","prevGroup","prevData","prevLane","prevEndLineNumber","rangeArraysEqual","mergeLineRangeArray","arr1","arr2","viewportStartModelPosition","startLineDelta","viewLayout","TextModelText","lastLineLen","TreeViewsDnDService","uuid","DraggedTreeItemsIdentifier","ITreeViewsDnDService","fixBracketsInLine","StaticTokenizerSource","processNode","closingTokenText","fileIconDirectoryRegex","getIconClasses","fileKind","classes","cssEscape","dotSegments","detectedLanguageId","detectLanguageId","mime","TrimTrailingWhitespaceCommand","trimInRegexesAndStrings","ops","trimTrailingWhitespace","rLen","cursorIndex","cursorLen","minEditColumn","fromColumnType","reverseEndianness","b0","b1","b2","b3","toLittleEndianBuffer","uint8Arr","encodeSemanticTokensDto","semanticTokens","encodeSemanticTokensDtoSize"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178],"sources":["../../../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../../../node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../../../node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages.js","../../../node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js","../../../node_modules/monaco-editor/esm/vs/editor/common/config/editorZoom.js","../../../node_modules/monaco-editor/esm/vs/editor/common/config/fontInfo.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/model.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatures.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js","../../../node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../../../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStyling.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js","../../../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/config/diffEditor.js","../../../node_modules/monaco-editor/esm/vs/editor/common/config/editorConfigurationSchema.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../../../node_modules/monaco-editor/esm/vs/editor/common/standaloneStrings.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../../../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","../../../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","../../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","../../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js","../../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","../../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","../../../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","../../../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../../../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../../../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linePart.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewEventHandler.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../../../node_modules/monaco-editor/esm/vs/editor/common/commands/replaceCommand.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentationLineProcessor.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/enterAction.js","../../../node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js","../../../node_modules/monaco-editor/esm/vs/editor/common/commands/surroundSelectionCommand.js","../../../node_modules/monaco-editor/esm/vs/editor/common/languages/autoIndent.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeEditOperations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../../../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/overviewZoneManager.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js","../../../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewContext.js","../../../node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js","../../../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewEvents.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModelEventDispatcher.js","../../../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/glyphLanesModel.js","../../../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelText.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js","../../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js","../../../node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js","../../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    // Ensure the regex has the 'g' flag, otherwise this will loop forever\n    wordDefinition = ensureValidWordDefinition(wordDefinition);\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport * as objects from '../../../base/common/objects.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { USUAL_WORD_SEPARATORS } from '../core/wordHelper.js';\nimport * as nls from '../../../nls.js';\n/**\n * @internal\n * The width of the minimap gutter, in pixels.\n */\nexport const MINIMAP_GUTTER_WIDTH = 8;\n//#endregion\n/**\n * An event describing that the configuration of the editor has changed.\n */\nexport class ConfigurationChangedEvent {\n    /**\n     * @internal\n     */\n    constructor(values) {\n        this._values = values;\n    }\n    hasChanged(id) {\n        return this._values[id];\n    }\n}\n/**\n * @internal\n */\nexport class ComputeOptionsMemory {\n    constructor() {\n        this.stableMinimapLayoutInput = null;\n        this.stableFitMaxMinimapScale = 0;\n        this.stableFitRemainingWidth = 0;\n    }\n}\n/**\n * @internal\n */\nclass BaseEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\nexport class ApplyUpdateResult {\n    constructor(newValue, didChange) {\n        this.newValue = newValue;\n        this.didChange = didChange;\n    }\n}\nfunction applyUpdate(value, update) {\n    if (typeof value !== 'object' || typeof update !== 'object' || !value || !update) {\n        return new ApplyUpdateResult(update, value !== update);\n    }\n    if (Array.isArray(value) || Array.isArray(update)) {\n        const arrayEquals = Array.isArray(value) && Array.isArray(update) && arrays.equals(value, update);\n        return new ApplyUpdateResult(update, !arrayEquals);\n    }\n    let didChange = false;\n    for (const key in update) {\n        if (update.hasOwnProperty(key)) {\n            const result = applyUpdate(value[key], update[key]);\n            if (result.didChange) {\n                value[key] = result.newValue;\n                didChange = true;\n            }\n        }\n    }\n    return new ApplyUpdateResult(value, didChange);\n}\n/**\n * @internal\n */\nclass ComputedEditorOption {\n    constructor(id) {\n        this.schema = undefined;\n        this.id = id;\n        this.name = '_never_';\n        this.defaultValue = undefined;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    validate(input) {\n        return this.defaultValue;\n    }\n}\nclass SimpleEditorOption {\n    constructor(id, name, defaultValue, schema) {\n        this.id = id;\n        this.name = name;\n        this.defaultValue = defaultValue;\n        this.schema = schema;\n    }\n    applyUpdate(value, update) {\n        return applyUpdate(value, update);\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        return input;\n    }\n    compute(env, options, value) {\n        return value;\n    }\n}\n/**\n * @internal\n */\nexport function boolean(value, defaultValue) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    if (value === 'false') {\n        // treat the string 'false' as false\n        return false;\n    }\n    return Boolean(value);\n}\nclass EditorBooleanOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'boolean';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return boolean(input, this.defaultValue);\n    }\n}\n/**\n * @internal\n */\nexport function clampedInt(value, defaultValue, minimum, maximum) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    let r = parseInt(value, 10);\n    if (isNaN(r)) {\n        return defaultValue;\n    }\n    r = Math.max(minimum, r);\n    r = Math.min(maximum, r);\n    return r | 0;\n}\nclass EditorIntOption extends SimpleEditorOption {\n    static clampedInt(value, defaultValue, minimum, maximum) {\n        return clampedInt(value, defaultValue, minimum, maximum);\n    }\n    constructor(id, name, defaultValue, minimum, maximum, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'integer';\n            schema.default = defaultValue;\n            schema.minimum = minimum;\n            schema.maximum = maximum;\n        }\n        super(id, name, defaultValue, schema);\n        this.minimum = minimum;\n        this.maximum = maximum;\n    }\n    validate(input) {\n        return EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);\n    }\n}\n/**\n * @internal\n */\nexport function clampedFloat(value, defaultValue, minimum, maximum) {\n    if (typeof value === 'undefined') {\n        return defaultValue;\n    }\n    const r = EditorFloatOption.float(value, defaultValue);\n    return EditorFloatOption.clamp(r, minimum, maximum);\n}\nclass EditorFloatOption extends SimpleEditorOption {\n    static clamp(n, min, max) {\n        if (n < min) {\n            return min;\n        }\n        if (n > max) {\n            return max;\n        }\n        return n;\n    }\n    static float(value, defaultValue) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        if (typeof value === 'undefined') {\n            return defaultValue;\n        }\n        const r = parseFloat(value);\n        return (isNaN(r) ? defaultValue : r);\n    }\n    constructor(id, name, defaultValue, validationFn, schema) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'number';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this.validationFn = validationFn;\n    }\n    validate(input) {\n        return this.validationFn(EditorFloatOption.float(input, this.defaultValue));\n    }\n}\nclass EditorStringOption extends SimpleEditorOption {\n    static string(value, defaultValue) {\n        if (typeof value !== 'string') {\n            return defaultValue;\n        }\n        return value;\n    }\n    constructor(id, name, defaultValue, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n    }\n    validate(input) {\n        return EditorStringOption.string(input, this.defaultValue);\n    }\n}\n/**\n * @internal\n */\nexport function stringSet(value, defaultValue, allowedValues, renamedValues) {\n    if (typeof value !== 'string') {\n        return defaultValue;\n    }\n    if (renamedValues && value in renamedValues) {\n        return renamedValues[value];\n    }\n    if (allowedValues.indexOf(value) === -1) {\n        return defaultValue;\n    }\n    return value;\n}\nclass EditorStringEnumOption extends SimpleEditorOption {\n    constructor(id, name, defaultValue, allowedValues, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n    }\n    validate(input) {\n        return stringSet(input, this.defaultValue, this._allowedValues);\n    }\n}\nclass EditorEnumOption extends BaseEditorOption {\n    constructor(id, name, defaultValue, defaultStringValue, allowedValues, convert, schema = undefined) {\n        if (typeof schema !== 'undefined') {\n            schema.type = 'string';\n            schema.enum = allowedValues;\n            schema.default = defaultStringValue;\n        }\n        super(id, name, defaultValue, schema);\n        this._allowedValues = allowedValues;\n        this._convert = convert;\n    }\n    validate(input) {\n        if (typeof input !== 'string') {\n            return this.defaultValue;\n        }\n        if (this._allowedValues.indexOf(input) === -1) {\n            return this.defaultValue;\n        }\n        return this._convert(input);\n    }\n}\n//#endregion\n//#region autoIndent\nfunction _autoIndentFromString(autoIndent) {\n    switch (autoIndent) {\n        case 'none': return 0 /* EditorAutoIndentStrategy.None */;\n        case 'keep': return 1 /* EditorAutoIndentStrategy.Keep */;\n        case 'brackets': return 2 /* EditorAutoIndentStrategy.Brackets */;\n        case 'advanced': return 3 /* EditorAutoIndentStrategy.Advanced */;\n        case 'full': return 4 /* EditorAutoIndentStrategy.Full */;\n    }\n}\n//#endregion\n//#region accessibilitySupport\nclass EditorAccessibilitySupport extends BaseEditorOption {\n    constructor() {\n        super(2 /* EditorOption.accessibilitySupport */, 'accessibilitySupport', 0 /* AccessibilitySupport.Unknown */, {\n            type: 'string',\n            enum: ['auto', 'on', 'off'],\n            enumDescriptions: [\n                nls.localize('accessibilitySupport.auto', \"Use platform APIs to detect when a Screen Reader is attached.\"),\n                nls.localize('accessibilitySupport.on', \"Optimize for usage with a Screen Reader.\"),\n                nls.localize('accessibilitySupport.off', \"Assume a screen reader is not attached.\"),\n            ],\n            default: 'auto',\n            tags: ['accessibility'],\n            description: nls.localize('accessibilitySupport', \"Controls if the UI should run in a mode where it is optimized for screen readers.\")\n        });\n    }\n    validate(input) {\n        switch (input) {\n            case 'auto': return 0 /* AccessibilitySupport.Unknown */;\n            case 'off': return 1 /* AccessibilitySupport.Disabled */;\n            case 'on': return 2 /* AccessibilitySupport.Enabled */;\n        }\n        return this.defaultValue;\n    }\n    compute(env, options, value) {\n        if (value === 0 /* AccessibilitySupport.Unknown */) {\n            // The editor reads the `accessibilitySupport` from the environment\n            return env.accessibilitySupport;\n        }\n        return value;\n    }\n}\nclass EditorComments extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertSpace: true,\n            ignoreEmptyLines: true,\n        };\n        super(23 /* EditorOption.comments */, 'comments', defaults, {\n            'editor.comments.insertSpace': {\n                type: 'boolean',\n                default: defaults.insertSpace,\n                description: nls.localize('comments.insertSpace', \"Controls whether a space character is inserted when commenting.\")\n            },\n            'editor.comments.ignoreEmptyLines': {\n                type: 'boolean',\n                default: defaults.ignoreEmptyLines,\n                description: nls.localize('comments.ignoreEmptyLines', 'Controls if empty lines should be ignored with toggle, add or remove actions for line comments.')\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),\n            ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines),\n        };\n    }\n}\nfunction _cursorBlinkingStyleFromString(cursorBlinkingStyle) {\n    switch (cursorBlinkingStyle) {\n        case 'blink': return 1 /* TextEditorCursorBlinkingStyle.Blink */;\n        case 'smooth': return 2 /* TextEditorCursorBlinkingStyle.Smooth */;\n        case 'phase': return 3 /* TextEditorCursorBlinkingStyle.Phase */;\n        case 'expand': return 4 /* TextEditorCursorBlinkingStyle.Expand */;\n        case 'solid': return 5 /* TextEditorCursorBlinkingStyle.Solid */;\n    }\n}\n//#endregion\n//#region cursorStyle\n/**\n * The style in which the editor's cursor should be rendered.\n */\nexport var TextEditorCursorStyle;\n(function (TextEditorCursorStyle) {\n    /**\n     * As a vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\n    /**\n     * As a block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\n    /**\n     * As a horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\n    /**\n     * As a thin vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\n    /**\n     * As an outlined block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\n    /**\n     * As a thin horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\nfunction _cursorStyleFromString(cursorStyle) {\n    switch (cursorStyle) {\n        case 'line': return TextEditorCursorStyle.Line;\n        case 'block': return TextEditorCursorStyle.Block;\n        case 'underline': return TextEditorCursorStyle.Underline;\n        case 'line-thin': return TextEditorCursorStyle.LineThin;\n        case 'block-outline': return TextEditorCursorStyle.BlockOutline;\n        case 'underline-thin': return TextEditorCursorStyle.UnderlineThin;\n    }\n}\n//#endregion\n//#region editorClassName\nclass EditorClassName extends ComputedEditorOption {\n    constructor() {\n        super(143 /* EditorOption.editorClassName */);\n    }\n    compute(env, options, _) {\n        const classNames = ['monaco-editor'];\n        if (options.get(39 /* EditorOption.extraEditorClassName */)) {\n            classNames.push(options.get(39 /* EditorOption.extraEditorClassName */));\n        }\n        if (env.extraEditorClassName) {\n            classNames.push(env.extraEditorClassName);\n        }\n        if (options.get(74 /* EditorOption.mouseStyle */) === 'default') {\n            classNames.push('mouse-default');\n        }\n        else if (options.get(74 /* EditorOption.mouseStyle */) === 'copy') {\n            classNames.push('mouse-copy');\n        }\n        if (options.get(112 /* EditorOption.showUnused */)) {\n            classNames.push('showUnused');\n        }\n        if (options.get(141 /* EditorOption.showDeprecated */)) {\n            classNames.push('showDeprecated');\n        }\n        return classNames.join(' ');\n    }\n}\n//#endregion\n//#region emptySelectionClipboard\nclass EditorEmptySelectionClipboard extends EditorBooleanOption {\n    constructor() {\n        super(37 /* EditorOption.emptySelectionClipboard */, 'emptySelectionClipboard', true, { description: nls.localize('emptySelectionClipboard', \"Controls whether copying without a selection copies the current line.\") });\n    }\n    compute(env, options, value) {\n        return value && env.emptySelectionClipboard;\n    }\n}\nclass EditorFind extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            cursorMoveOnType: true,\n            seedSearchStringFromSelection: 'always',\n            autoFindInSelection: 'never',\n            globalFindClipboard: false,\n            addExtraSpaceOnTop: true,\n            loop: true\n        };\n        super(41 /* EditorOption.find */, 'find', defaults, {\n            'editor.find.cursorMoveOnType': {\n                type: 'boolean',\n                default: defaults.cursorMoveOnType,\n                description: nls.localize('find.cursorMoveOnType', \"Controls whether the cursor should jump to find matches while typing.\")\n            },\n            'editor.find.seedSearchStringFromSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'selection'],\n                default: defaults.seedSearchStringFromSelection,\n                enumDescriptions: [\n                    nls.localize('editor.find.seedSearchStringFromSelection.never', 'Never seed search string from the editor selection.'),\n                    nls.localize('editor.find.seedSearchStringFromSelection.always', 'Always seed search string from the editor selection, including word at cursor position.'),\n                    nls.localize('editor.find.seedSearchStringFromSelection.selection', 'Only seed search string from the editor selection.')\n                ],\n                description: nls.localize('find.seedSearchStringFromSelection', \"Controls whether the search string in the Find Widget is seeded from the editor selection.\")\n            },\n            'editor.find.autoFindInSelection': {\n                type: 'string',\n                enum: ['never', 'always', 'multiline'],\n                default: defaults.autoFindInSelection,\n                enumDescriptions: [\n                    nls.localize('editor.find.autoFindInSelection.never', 'Never turn on Find in Selection automatically (default).'),\n                    nls.localize('editor.find.autoFindInSelection.always', 'Always turn on Find in Selection automatically.'),\n                    nls.localize('editor.find.autoFindInSelection.multiline', 'Turn on Find in Selection automatically when multiple lines of content are selected.')\n                ],\n                description: nls.localize('find.autoFindInSelection', \"Controls the condition for turning on Find in Selection automatically.\")\n            },\n            'editor.find.globalFindClipboard': {\n                type: 'boolean',\n                default: defaults.globalFindClipboard,\n                description: nls.localize('find.globalFindClipboard', \"Controls whether the Find Widget should read or modify the shared find clipboard on macOS.\"),\n                included: platform.isMacintosh\n            },\n            'editor.find.addExtraSpaceOnTop': {\n                type: 'boolean',\n                default: defaults.addExtraSpaceOnTop,\n                description: nls.localize('find.addExtraSpaceOnTop', \"Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.\")\n            },\n            'editor.find.loop': {\n                type: 'boolean',\n                default: defaults.loop,\n                description: nls.localize('find.loop', \"Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),\n            seedSearchStringFromSelection: typeof _input.seedSearchStringFromSelection === 'boolean'\n                ? (_input.seedSearchStringFromSelection ? 'always' : 'never')\n                : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ['never', 'always', 'selection']),\n            autoFindInSelection: typeof _input.autoFindInSelection === 'boolean'\n                ? (_input.autoFindInSelection ? 'always' : 'never')\n                : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ['never', 'always', 'multiline']),\n            globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),\n            addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),\n            loop: boolean(input.loop, this.defaultValue.loop),\n        };\n    }\n}\n//#endregion\n//#region fontLigatures\n/**\n * @internal\n */\nexport class EditorFontLigatures extends BaseEditorOption {\n    static { this.OFF = '\"liga\" off, \"calt\" off'; }\n    static { this.ON = '\"liga\" on, \"calt\" on'; }\n    constructor() {\n        super(51 /* EditorOption.fontLigatures */, 'fontLigatures', EditorFontLigatures.OFF, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                    description: nls.localize('fontLigatures', \"Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.\"),\n                },\n                {\n                    type: 'string',\n                    description: nls.localize('fontFeatureSettings', \"Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.\")\n                }\n            ],\n            description: nls.localize('fontLigaturesGeneral', \"Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property.\"),\n            default: false\n        });\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            if (input === 'false' || input.length === 0) {\n                return EditorFontLigatures.OFF;\n            }\n            if (input === 'true') {\n                return EditorFontLigatures.ON;\n            }\n            return input;\n        }\n        if (Boolean(input)) {\n            return EditorFontLigatures.ON;\n        }\n        return EditorFontLigatures.OFF;\n    }\n}\n//#endregion\n//#region fontVariations\n/**\n * @internal\n */\nexport class EditorFontVariations extends BaseEditorOption {\n    // Text is laid out using default settings.\n    static { this.OFF = 'normal'; }\n    // Translate `fontWeight` config to the `font-variation-settings` CSS property.\n    static { this.TRANSLATE = 'translate'; }\n    constructor() {\n        super(54 /* EditorOption.fontVariations */, 'fontVariations', EditorFontVariations.OFF, {\n            anyOf: [\n                {\n                    type: 'boolean',\n                    description: nls.localize('fontVariations', \"Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.\"),\n                },\n                {\n                    type: 'string',\n                    description: nls.localize('fontVariationSettings', \"Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.\")\n                }\n            ],\n            description: nls.localize('fontVariationsGeneral', \"Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property.\"),\n            default: false\n        });\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            if (input === 'false') {\n                return EditorFontVariations.OFF;\n            }\n            if (input === 'true') {\n                return EditorFontVariations.TRANSLATE;\n            }\n            return input;\n        }\n        if (Boolean(input)) {\n            return EditorFontVariations.TRANSLATE;\n        }\n        return EditorFontVariations.OFF;\n    }\n    compute(env, options, value) {\n        // The value is computed from the fontWeight if it is true.\n        // So take the result from env.fontInfo\n        return env.fontInfo.fontVariationSettings;\n    }\n}\n//#endregion\n//#region fontInfo\nclass EditorFontInfo extends ComputedEditorOption {\n    constructor() {\n        super(50 /* EditorOption.fontInfo */);\n    }\n    compute(env, options, _) {\n        return env.fontInfo;\n    }\n}\n//#endregion\n//#region fontSize\nclass EditorFontSize extends SimpleEditorOption {\n    constructor() {\n        super(52 /* EditorOption.fontSize */, 'fontSize', EDITOR_FONT_DEFAULTS.fontSize, {\n            type: 'number',\n            minimum: 6,\n            maximum: 100,\n            default: EDITOR_FONT_DEFAULTS.fontSize,\n            description: nls.localize('fontSize', \"Controls the font size in pixels.\")\n        });\n    }\n    validate(input) {\n        const r = EditorFloatOption.float(input, this.defaultValue);\n        if (r === 0) {\n            return EDITOR_FONT_DEFAULTS.fontSize;\n        }\n        return EditorFloatOption.clamp(r, 6, 100);\n    }\n    compute(env, options, value) {\n        // The final fontSize respects the editor zoom level.\n        // So take the result from env.fontInfo\n        return env.fontInfo.fontSize;\n    }\n}\n//#endregion\n//#region fontWeight\nclass EditorFontWeight extends BaseEditorOption {\n    static { this.SUGGESTION_VALUES = ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900']; }\n    static { this.MINIMUM_VALUE = 1; }\n    static { this.MAXIMUM_VALUE = 1000; }\n    constructor() {\n        super(53 /* EditorOption.fontWeight */, 'fontWeight', EDITOR_FONT_DEFAULTS.fontWeight, {\n            anyOf: [\n                {\n                    type: 'number',\n                    minimum: EditorFontWeight.MINIMUM_VALUE,\n                    maximum: EditorFontWeight.MAXIMUM_VALUE,\n                    errorMessage: nls.localize('fontWeightErrorMessage', \"Only \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000 are allowed.\")\n                },\n                {\n                    type: 'string',\n                    pattern: '^(normal|bold|1000|[1-9][0-9]{0,2})$'\n                },\n                {\n                    enum: EditorFontWeight.SUGGESTION_VALUES\n                }\n            ],\n            default: EDITOR_FONT_DEFAULTS.fontWeight,\n            description: nls.localize('fontWeight', \"Controls the font weight. Accepts \\\"normal\\\" and \\\"bold\\\" keywords or numbers between 1 and 1000.\")\n        });\n    }\n    validate(input) {\n        if (input === 'normal' || input === 'bold') {\n            return input;\n        }\n        return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, EditorFontWeight.MINIMUM_VALUE, EditorFontWeight.MAXIMUM_VALUE));\n    }\n}\nclass EditorGoToLocation extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            multiple: 'peek',\n            multipleDefinitions: 'peek',\n            multipleTypeDefinitions: 'peek',\n            multipleDeclarations: 'peek',\n            multipleImplementations: 'peek',\n            multipleReferences: 'peek',\n            multipleTests: 'peek',\n            alternativeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeTypeDefinitionCommand: 'editor.action.goToReferences',\n            alternativeDeclarationCommand: 'editor.action.goToReferences',\n            alternativeImplementationCommand: '',\n            alternativeReferenceCommand: '',\n            alternativeTestsCommand: '',\n        };\n        const jsonSubset = {\n            type: 'string',\n            enum: ['peek', 'gotoAndPeek', 'goto'],\n            default: defaults.multiple,\n            enumDescriptions: [\n                nls.localize('editor.gotoLocation.multiple.peek', 'Show Peek view of the results (default)'),\n                nls.localize('editor.gotoLocation.multiple.gotoAndPeek', 'Go to the primary result and show a Peek view'),\n                nls.localize('editor.gotoLocation.multiple.goto', 'Go to the primary result and enable Peek-less navigation to others')\n            ]\n        };\n        const alternativeCommandOptions = ['', 'editor.action.referenceSearch.trigger', 'editor.action.goToReferences', 'editor.action.peekImplementation', 'editor.action.goToImplementation', 'editor.action.peekTypeDefinition', 'editor.action.goToTypeDefinition', 'editor.action.peekDeclaration', 'editor.action.revealDeclaration', 'editor.action.peekDefinition', 'editor.action.revealDefinitionAside', 'editor.action.revealDefinition'];\n        super(58 /* EditorOption.gotoLocation */, 'gotoLocation', defaults, {\n            'editor.gotoLocation.multiple': {\n                deprecationMessage: nls.localize('editor.gotoLocation.multiple.deprecated', \"This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.\"),\n            },\n            'editor.gotoLocation.multipleDefinitions': {\n                description: nls.localize('editor.editor.gotoLocation.multipleDefinitions', \"Controls the behavior the 'Go to Definition'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleTypeDefinitions': {\n                description: nls.localize('editor.editor.gotoLocation.multipleTypeDefinitions', \"Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleDeclarations': {\n                description: nls.localize('editor.editor.gotoLocation.multipleDeclarations', \"Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleImplementations': {\n                description: nls.localize('editor.editor.gotoLocation.multipleImplemenattions', \"Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.multipleReferences': {\n                description: nls.localize('editor.editor.gotoLocation.multipleReferences', \"Controls the behavior the 'Go to References'-command when multiple target locations exist.\"),\n                ...jsonSubset,\n            },\n            'editor.gotoLocation.alternativeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeDefinitionCommand', \"Alternative command id that is being executed when the result of 'Go to Definition' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeTypeDefinitionCommand': {\n                type: 'string',\n                default: defaults.alternativeTypeDefinitionCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeTypeDefinitionCommand', \"Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeDeclarationCommand': {\n                type: 'string',\n                default: defaults.alternativeDeclarationCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeDeclarationCommand', \"Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeImplementationCommand': {\n                type: 'string',\n                default: defaults.alternativeImplementationCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeImplementationCommand', \"Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.\")\n            },\n            'editor.gotoLocation.alternativeReferenceCommand': {\n                type: 'string',\n                default: defaults.alternativeReferenceCommand,\n                enum: alternativeCommandOptions,\n                description: nls.localize('alternativeReferenceCommand', \"Alternative command id that is being executed when the result of 'Go to Reference' is the current location.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            multiple: stringSet(input.multiple, this.defaultValue.multiple, ['peek', 'gotoAndPeek', 'goto']),\n            multipleDefinitions: input.multipleDefinitions ?? stringSet(input.multipleDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleTypeDefinitions: input.multipleTypeDefinitions ?? stringSet(input.multipleTypeDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleDeclarations: input.multipleDeclarations ?? stringSet(input.multipleDeclarations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleImplementations: input.multipleImplementations ?? stringSet(input.multipleImplementations, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleReferences: input.multipleReferences ?? stringSet(input.multipleReferences, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            multipleTests: input.multipleTests ?? stringSet(input.multipleTests, 'peek', ['peek', 'gotoAndPeek', 'goto']),\n            alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),\n            alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),\n            alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),\n            alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),\n            alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),\n            alternativeTestsCommand: EditorStringOption.string(input.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand),\n        };\n    }\n}\nclass EditorHover extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            delay: 300,\n            hidingDelay: 300,\n            sticky: true,\n            above: true,\n        };\n        super(60 /* EditorOption.hover */, 'hover', defaults, {\n            'editor.hover.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('hover.enabled', \"Controls whether the hover is shown.\")\n            },\n            'editor.hover.delay': {\n                type: 'number',\n                default: defaults.delay,\n                minimum: 0,\n                maximum: 10000,\n                description: nls.localize('hover.delay', \"Controls the delay in milliseconds after which the hover is shown.\")\n            },\n            'editor.hover.sticky': {\n                type: 'boolean',\n                default: defaults.sticky,\n                description: nls.localize('hover.sticky', \"Controls whether the hover should remain visible when mouse is moved over it.\")\n            },\n            'editor.hover.hidingDelay': {\n                type: 'integer',\n                minimum: 0,\n                default: defaults.hidingDelay,\n                description: nls.localize('hover.hidingDelay', \"Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.\")\n            },\n            'editor.hover.above': {\n                type: 'boolean',\n                default: defaults.above,\n                description: nls.localize('hover.above', \"Prefer showing hovers above the line, if there's space.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 10000),\n            sticky: boolean(input.sticky, this.defaultValue.sticky),\n            hidingDelay: EditorIntOption.clampedInt(input.hidingDelay, this.defaultValue.hidingDelay, 0, 600000),\n            above: boolean(input.above, this.defaultValue.above),\n        };\n    }\n}\n/**\n * @internal\n */\nexport class EditorLayoutInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(146 /* EditorOption.layoutInfo */);\n    }\n    compute(env, options, _) {\n        return EditorLayoutInfoComputer.computeLayout(options, {\n            memory: env.memory,\n            outerWidth: env.outerWidth,\n            outerHeight: env.outerHeight,\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            lineHeight: env.fontInfo.lineHeight,\n            viewLineCount: env.viewLineCount,\n            lineNumbersDigitCount: env.lineNumbersDigitCount,\n            typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,\n            maxDigitWidth: env.fontInfo.maxDigitWidth,\n            pixelRatio: env.pixelRatio,\n            glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount\n        });\n    }\n    static computeContainedMinimapLineCount(input) {\n        const typicalViewportLineCount = input.height / input.lineHeight;\n        const extraLinesBeforeFirstLine = Math.floor(input.paddingTop / input.lineHeight);\n        let extraLinesBeyondLastLine = Math.floor(input.paddingBottom / input.lineHeight);\n        if (input.scrollBeyondLastLine) {\n            extraLinesBeyondLastLine = Math.max(extraLinesBeyondLastLine, typicalViewportLineCount - 1);\n        }\n        const desiredRatio = (extraLinesBeforeFirstLine + input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);\n        const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);\n        return { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };\n    }\n    static _computeMinimapLayout(input, memory) {\n        const outerWidth = input.outerWidth;\n        const outerHeight = input.outerHeight;\n        const pixelRatio = input.pixelRatio;\n        if (!input.minimap.enabled) {\n            return {\n                renderMinimap: 0 /* RenderMinimap.None */,\n                minimapLeft: 0,\n                minimapWidth: 0,\n                minimapHeightIsEditorHeight: false,\n                minimapIsSampling: false,\n                minimapScale: 1,\n                minimapLineHeight: 1,\n                minimapCanvasInnerWidth: 0,\n                minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),\n                minimapCanvasOuterWidth: 0,\n                minimapCanvasOuterHeight: outerHeight,\n            };\n        }\n        // Can use memory if only the `viewLineCount` and `remainingWidth` have changed\n        const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;\n        const couldUseMemory = (stableMinimapLayoutInput\n            // && input.outerWidth === lastMinimapLayoutInput.outerWidth !!! INTENTIONAL OMITTED\n            && input.outerHeight === stableMinimapLayoutInput.outerHeight\n            && input.lineHeight === stableMinimapLayoutInput.lineHeight\n            && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth\n            && input.pixelRatio === stableMinimapLayoutInput.pixelRatio\n            && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine\n            && input.paddingTop === stableMinimapLayoutInput.paddingTop\n            && input.paddingBottom === stableMinimapLayoutInput.paddingBottom\n            && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled\n            && input.minimap.side === stableMinimapLayoutInput.minimap.side\n            && input.minimap.size === stableMinimapLayoutInput.minimap.size\n            && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider\n            && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters\n            && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn\n            && input.minimap.scale === stableMinimapLayoutInput.minimap.scale\n            && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth\n            // && input.viewLineCount === lastMinimapLayoutInput.viewLineCount !!! INTENTIONAL OMITTED\n            // && input.remainingWidth === lastMinimapLayoutInput.remainingWidth !!! INTENTIONAL OMITTED\n            && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping);\n        const lineHeight = input.lineHeight;\n        const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;\n        const scrollBeyondLastLine = input.scrollBeyondLastLine;\n        const minimapRenderCharacters = input.minimap.renderCharacters;\n        let minimapScale = (pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale);\n        const minimapMaxColumn = input.minimap.maxColumn;\n        const minimapSize = input.minimap.size;\n        const minimapSide = input.minimap.side;\n        const verticalScrollbarWidth = input.verticalScrollbarWidth;\n        const viewLineCount = input.viewLineCount;\n        const remainingWidth = input.remainingWidth;\n        const isViewportWrapping = input.isViewportWrapping;\n        const baseCharHeight = minimapRenderCharacters ? 2 : 3;\n        let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);\n        const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;\n        let minimapHeightIsEditorHeight = false;\n        let minimapIsSampling = false;\n        let minimapLineHeight = baseCharHeight * minimapScale;\n        let minimapCharWidth = minimapScale / pixelRatio;\n        let minimapWidthMultiplier = 1;\n        if (minimapSize === 'fill' || minimapSize === 'fit') {\n            const { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n                viewLineCount: viewLineCount,\n                scrollBeyondLastLine: scrollBeyondLastLine,\n                paddingTop: input.paddingTop,\n                paddingBottom: input.paddingBottom,\n                height: outerHeight,\n                lineHeight: lineHeight,\n                pixelRatio: pixelRatio\n            });\n            // ratio is intentionally not part of the layout to avoid the layout changing all the time\n            // when doing sampling\n            const ratio = viewLineCount / minimapLineCount;\n            if (ratio > 1) {\n                minimapHeightIsEditorHeight = true;\n                minimapIsSampling = true;\n                minimapScale = 1;\n                minimapLineHeight = 1;\n                minimapCharWidth = minimapScale / pixelRatio;\n            }\n            else {\n                let fitBecomesFill = false;\n                let maxMinimapScale = minimapScale + 1;\n                if (minimapSize === 'fit') {\n                    const effectiveMinimapHeight = Math.ceil((extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        // There is a loop when using `fit` and viewport wrapping:\n                        // - view line count impacts minimap layout\n                        // - minimap layout impacts viewport width\n                        // - viewport width impacts view line count\n                        // To break the loop, once we go to a smaller minimap scale, we try to stick with it.\n                        fitBecomesFill = true;\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    else {\n                        fitBecomesFill = (effectiveMinimapHeight > minimapCanvasInnerHeight);\n                    }\n                }\n                if (minimapSize === 'fill' || fitBecomesFill) {\n                    minimapHeightIsEditorHeight = true;\n                    const configuredMinimapScale = minimapScale;\n                    minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));\n                    if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {\n                        // There is a loop when using `fill` and viewport wrapping:\n                        // - view line count impacts minimap layout\n                        // - minimap layout impacts viewport width\n                        // - viewport width impacts view line count\n                        // To break the loop, once we go to a smaller minimap scale, we try to stick with it.\n                        maxMinimapScale = memory.stableFitMaxMinimapScale;\n                    }\n                    minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));\n                    if (minimapScale > configuredMinimapScale) {\n                        minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);\n                    }\n                    minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;\n                    minimapCanvasInnerHeight = Math.ceil((Math.max(typicalViewportLineCount, extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine)) * minimapLineHeight);\n                    if (isViewportWrapping) {\n                        // remember for next time\n                        memory.stableMinimapLayoutInput = input;\n                        memory.stableFitRemainingWidth = remainingWidth;\n                        memory.stableFitMaxMinimapScale = minimapScale;\n                    }\n                    else {\n                        memory.stableMinimapLayoutInput = null;\n                        memory.stableFitRemainingWidth = 0;\n                    }\n                }\n            }\n        }\n        // Given:\n        // (leaving 2px for the cursor to have space after the last character)\n        // viewportColumn = (contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth\n        // minimapWidth = viewportColumn * minimapCharWidth\n        // contentWidth = remainingWidth - minimapWidth\n        // What are good values for contentWidth and minimapWidth ?\n        // minimapWidth = ((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth) * minimapCharWidth\n        // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth\n        // minimapWidth = ((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)\n        const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);\n        const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);\n        let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);\n        const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;\n        minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);\n        const renderMinimap = (minimapRenderCharacters ? 1 /* RenderMinimap.Text */ : 2 /* RenderMinimap.Blocks */);\n        const minimapLeft = (minimapSide === 'left' ? 0 : (outerWidth - minimapWidth - verticalScrollbarWidth));\n        return {\n            renderMinimap,\n            minimapLeft,\n            minimapWidth,\n            minimapHeightIsEditorHeight,\n            minimapIsSampling,\n            minimapScale,\n            minimapLineHeight,\n            minimapCanvasInnerWidth,\n            minimapCanvasInnerHeight,\n            minimapCanvasOuterWidth,\n            minimapCanvasOuterHeight,\n        };\n    }\n    static computeLayout(options, env) {\n        const outerWidth = env.outerWidth | 0;\n        const outerHeight = env.outerHeight | 0;\n        const lineHeight = env.lineHeight | 0;\n        const lineNumbersDigitCount = env.lineNumbersDigitCount | 0;\n        const typicalHalfwidthCharacterWidth = env.typicalHalfwidthCharacterWidth;\n        const maxDigitWidth = env.maxDigitWidth;\n        const pixelRatio = env.pixelRatio;\n        const viewLineCount = env.viewLineCount;\n        const wordWrapOverride2 = options.get(138 /* EditorOption.wordWrapOverride2 */);\n        const wordWrapOverride1 = (wordWrapOverride2 === 'inherit' ? options.get(137 /* EditorOption.wordWrapOverride1 */) : wordWrapOverride2);\n        const wordWrap = (wordWrapOverride1 === 'inherit' ? options.get(133 /* EditorOption.wordWrap */) : wordWrapOverride1);\n        const wordWrapColumn = options.get(136 /* EditorOption.wordWrapColumn */);\n        const isDominatedByLongLines = env.isDominatedByLongLines;\n        const showGlyphMargin = options.get(57 /* EditorOption.glyphMargin */);\n        const showLineNumbers = (options.get(68 /* EditorOption.lineNumbers */).renderType !== 0 /* RenderLineNumbersType.Off */);\n        const lineNumbersMinChars = options.get(69 /* EditorOption.lineNumbersMinChars */);\n        const scrollBeyondLastLine = options.get(106 /* EditorOption.scrollBeyondLastLine */);\n        const padding = options.get(84 /* EditorOption.padding */);\n        const minimap = options.get(73 /* EditorOption.minimap */);\n        const scrollbar = options.get(104 /* EditorOption.scrollbar */);\n        const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;\n        const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;\n        const scrollbarArrowSize = scrollbar.arrowSize;\n        const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;\n        const folding = options.get(43 /* EditorOption.folding */);\n        const showFoldingDecoration = options.get(111 /* EditorOption.showFoldingControls */) !== 'never';\n        let lineDecorationsWidth = options.get(66 /* EditorOption.lineDecorationsWidth */);\n        if (folding && showFoldingDecoration) {\n            lineDecorationsWidth += 16;\n        }\n        let lineNumbersWidth = 0;\n        if (showLineNumbers) {\n            const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);\n            lineNumbersWidth = Math.round(digitCount * maxDigitWidth);\n        }\n        let glyphMarginWidth = 0;\n        if (showGlyphMargin) {\n            glyphMarginWidth = lineHeight * env.glyphMarginDecorationLaneCount;\n        }\n        let glyphMarginLeft = 0;\n        let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;\n        let decorationsLeft = lineNumbersLeft + lineNumbersWidth;\n        let contentLeft = decorationsLeft + lineDecorationsWidth;\n        const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;\n        let isWordWrapMinified = false;\n        let isViewportWrapping = false;\n        let wrappingColumn = -1;\n        if (wordWrapOverride1 === 'inherit' && isDominatedByLongLines) {\n            // Force viewport width wrapping if model is dominated by long lines\n            isWordWrapMinified = true;\n            isViewportWrapping = true;\n        }\n        else if (wordWrap === 'on' || wordWrap === 'bounded') {\n            isViewportWrapping = true;\n        }\n        else if (wordWrap === 'wordWrapColumn') {\n            wrappingColumn = wordWrapColumn;\n        }\n        const minimapLayout = EditorLayoutInfoComputer._computeMinimapLayout({\n            outerWidth: outerWidth,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight,\n            typicalHalfwidthCharacterWidth: typicalHalfwidthCharacterWidth,\n            pixelRatio: pixelRatio,\n            scrollBeyondLastLine: scrollBeyondLastLine,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            minimap: minimap,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            viewLineCount: viewLineCount,\n            remainingWidth: remainingWidth,\n            isViewportWrapping: isViewportWrapping,\n        }, env.memory || new ComputeOptionsMemory());\n        if (minimapLayout.renderMinimap !== 0 /* RenderMinimap.None */ && minimapLayout.minimapLeft === 0) {\n            // the minimap is rendered to the left, so move everything to the right\n            glyphMarginLeft += minimapLayout.minimapWidth;\n            lineNumbersLeft += minimapLayout.minimapWidth;\n            decorationsLeft += minimapLayout.minimapWidth;\n            contentLeft += minimapLayout.minimapWidth;\n        }\n        const contentWidth = remainingWidth - minimapLayout.minimapWidth;\n        // (leaving 2px for the cursor to have space after the last character)\n        const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));\n        const verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);\n        if (isViewportWrapping) {\n            // compute the actual wrappingColumn\n            wrappingColumn = Math.max(1, viewportColumn);\n            if (wordWrap === 'bounded') {\n                wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);\n            }\n        }\n        return {\n            width: outerWidth,\n            height: outerHeight,\n            glyphMarginLeft: glyphMarginLeft,\n            glyphMarginWidth: glyphMarginWidth,\n            glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount,\n            lineNumbersLeft: lineNumbersLeft,\n            lineNumbersWidth: lineNumbersWidth,\n            decorationsLeft: decorationsLeft,\n            decorationsWidth: lineDecorationsWidth,\n            contentLeft: contentLeft,\n            contentWidth: contentWidth,\n            minimap: minimapLayout,\n            viewportColumn: viewportColumn,\n            isWordWrapMinified: isWordWrapMinified,\n            isViewportWrapping: isViewportWrapping,\n            wrappingColumn: wrappingColumn,\n            verticalScrollbarWidth: verticalScrollbarWidth,\n            horizontalScrollbarHeight: horizontalScrollbarHeight,\n            overviewRuler: {\n                top: verticalArrowSize,\n                width: verticalScrollbarWidth,\n                height: (outerHeight - 2 * verticalArrowSize),\n                right: 0\n            }\n        };\n    }\n}\n//#endregion\n//#region WrappingStrategy\nclass WrappingStrategy extends BaseEditorOption {\n    constructor() {\n        super(140 /* EditorOption.wrappingStrategy */, 'wrappingStrategy', 'simple', {\n            'editor.wrappingStrategy': {\n                enumDescriptions: [\n                    nls.localize('wrappingStrategy.simple', \"Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width.\"),\n                    nls.localize('wrappingStrategy.advanced', \"Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.\")\n                ],\n                type: 'string',\n                enum: ['simple', 'advanced'],\n                default: 'simple',\n                description: nls.localize('wrappingStrategy', \"Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.\")\n            }\n        });\n    }\n    validate(input) {\n        return stringSet(input, 'simple', ['simple', 'advanced']);\n    }\n    compute(env, options, value) {\n        const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        if (accessibilitySupport === 2 /* AccessibilitySupport.Enabled */) {\n            // if we know for a fact that a screen reader is attached, we switch our strategy to advanced to\n            // help that the editor's wrapping points match the textarea's wrapping points\n            return 'advanced';\n        }\n        return value;\n    }\n}\n//#endregion\n//#region lightbulb\nexport var ShowLightbulbIconMode;\n(function (ShowLightbulbIconMode) {\n    ShowLightbulbIconMode[\"Off\"] = \"off\";\n    ShowLightbulbIconMode[\"OnCode\"] = \"onCode\";\n    ShowLightbulbIconMode[\"On\"] = \"on\";\n})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));\nclass EditorLightbulb extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: ShowLightbulbIconMode.OnCode };\n        super(65 /* EditorOption.lightbulb */, 'lightbulb', defaults, {\n            'editor.lightbulb.enabled': {\n                type: 'string',\n                tags: ['experimental'],\n                enum: [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On],\n                default: defaults.enabled,\n                enumDescriptions: [\n                    nls.localize('editor.lightbulb.enabled.off', 'Disable the code action menu.'),\n                    nls.localize('editor.lightbulb.enabled.onCode', 'Show the code action menu when the cursor is on lines with code.'),\n                    nls.localize('editor.lightbulb.enabled.on', 'Show the code action menu when the cursor is on lines with code or on empty lines.'),\n                ],\n                description: nls.localize('enabled', \"Enables the Code Action lightbulb in the editor.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: stringSet(input.enabled, this.defaultValue.enabled, [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On])\n        };\n    }\n}\nclass EditorStickyScroll extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, maxLineCount: 5, defaultModel: 'outlineModel', scrollWithEditor: true };\n        super(116 /* EditorOption.stickyScroll */, 'stickyScroll', defaults, {\n            'editor.stickyScroll.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('editor.stickyScroll.enabled', \"Shows the nested current scopes during the scroll at the top of the editor.\"),\n                tags: ['experimental']\n            },\n            'editor.stickyScroll.maxLineCount': {\n                type: 'number',\n                default: defaults.maxLineCount,\n                minimum: 1,\n                maximum: 20,\n                description: nls.localize('editor.stickyScroll.maxLineCount', \"Defines the maximum number of sticky lines to show.\")\n            },\n            'editor.stickyScroll.defaultModel': {\n                type: 'string',\n                enum: ['outlineModel', 'foldingProviderModel', 'indentationModel'],\n                default: defaults.defaultModel,\n                description: nls.localize('editor.stickyScroll.defaultModel', \"Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.\")\n            },\n            'editor.stickyScroll.scrollWithEditor': {\n                type: 'boolean',\n                default: defaults.scrollWithEditor,\n                description: nls.localize('editor.stickyScroll.scrollWithEditor', \"Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            maxLineCount: EditorIntOption.clampedInt(input.maxLineCount, this.defaultValue.maxLineCount, 1, 20),\n            defaultModel: stringSet(input.defaultModel, this.defaultValue.defaultModel, ['outlineModel', 'foldingProviderModel', 'indentationModel']),\n            scrollWithEditor: boolean(input.scrollWithEditor, this.defaultValue.scrollWithEditor)\n        };\n    }\n}\nclass EditorInlayHints extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: 'on', fontSize: 0, fontFamily: '', padding: false };\n        super(142 /* EditorOption.inlayHints */, 'inlayHints', defaults, {\n            'editor.inlayHints.enabled': {\n                type: 'string',\n                default: defaults.enabled,\n                description: nls.localize('inlayHints.enable', \"Enables the inlay hints in the editor.\"),\n                enum: ['on', 'onUnlessPressed', 'offUnlessPressed', 'off'],\n                markdownEnumDescriptions: [\n                    nls.localize('editor.inlayHints.on', \"Inlay hints are enabled\"),\n                    nls.localize('editor.inlayHints.onUnlessPressed', \"Inlay hints are showing by default and hide when holding {0}\", platform.isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),\n                    nls.localize('editor.inlayHints.offUnlessPressed', \"Inlay hints are hidden by default and show when holding {0}\", platform.isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),\n                    nls.localize('editor.inlayHints.off', \"Inlay hints are disabled\"),\n                ],\n            },\n            'editor.inlayHints.fontSize': {\n                type: 'number',\n                default: defaults.fontSize,\n                markdownDescription: nls.localize('inlayHints.fontSize', \"Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.\", '`#editor.fontSize#`', '`5`')\n            },\n            'editor.inlayHints.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                markdownDescription: nls.localize('inlayHints.fontFamily', \"Controls font family of inlay hints in the editor. When set to empty, the {0} is used.\", '`#editor.fontFamily#`')\n            },\n            'editor.inlayHints.padding': {\n                type: 'boolean',\n                default: defaults.padding,\n                description: nls.localize('inlayHints.padding', \"Enables the padding around the inlay hints in the editor.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        if (typeof input.enabled === 'boolean') {\n            input.enabled = input.enabled ? 'on' : 'off';\n        }\n        return {\n            enabled: stringSet(input.enabled, this.defaultValue.enabled, ['on', 'off', 'offUnlessPressed', 'onUnlessPressed']),\n            fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),\n            padding: boolean(input.padding, this.defaultValue.padding)\n        };\n    }\n}\n//#endregion\n//#region lineDecorationsWidth\nclass EditorLineDecorationsWidth extends BaseEditorOption {\n    constructor() {\n        super(66 /* EditorOption.lineDecorationsWidth */, 'lineDecorationsWidth', 10);\n    }\n    validate(input) {\n        if (typeof input === 'string' && /^\\d+(\\.\\d+)?ch$/.test(input)) {\n            const multiple = parseFloat(input.substring(0, input.length - 2));\n            return -multiple; // negative numbers signal a multiple\n        }\n        else {\n            return EditorIntOption.clampedInt(input, this.defaultValue, 0, 1000);\n        }\n    }\n    compute(env, options, value) {\n        if (value < 0) {\n            // negative numbers signal a multiple\n            return EditorIntOption.clampedInt(-value * env.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1000);\n        }\n        else {\n            return value;\n        }\n    }\n}\n//#endregion\n//#region lineHeight\nclass EditorLineHeight extends EditorFloatOption {\n    constructor() {\n        super(67 /* EditorOption.lineHeight */, 'lineHeight', EDITOR_FONT_DEFAULTS.lineHeight, x => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: nls.localize('lineHeight', \"Controls the line height. \\n - Use 0 to automatically compute the line height from the font size.\\n - Values between 0 and 8 will be used as a multiplier with the font size.\\n - Values greater than or equal to 8 will be used as effective values.\") });\n    }\n    compute(env, options, value) {\n        // The lineHeight is computed from the fontSize if it is 0.\n        // Moreover, the final lineHeight respects the editor zoom level.\n        // So take the result from env.fontInfo\n        return env.fontInfo.lineHeight;\n    }\n}\nclass EditorMinimap extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            size: 'proportional',\n            side: 'right',\n            showSlider: 'mouseover',\n            autohide: false,\n            renderCharacters: true,\n            maxColumn: 120,\n            scale: 1,\n            showRegionSectionHeaders: true,\n            showMarkSectionHeaders: true,\n            sectionHeaderFontSize: 9,\n            sectionHeaderLetterSpacing: 1,\n        };\n        super(73 /* EditorOption.minimap */, 'minimap', defaults, {\n            'editor.minimap.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('minimap.enabled', \"Controls whether the minimap is shown.\")\n            },\n            'editor.minimap.autohide': {\n                type: 'boolean',\n                default: defaults.autohide,\n                description: nls.localize('minimap.autohide', \"Controls whether the minimap is hidden automatically.\")\n            },\n            'editor.minimap.size': {\n                type: 'string',\n                enum: ['proportional', 'fill', 'fit'],\n                enumDescriptions: [\n                    nls.localize('minimap.size.proportional', \"The minimap has the same size as the editor contents (and might scroll).\"),\n                    nls.localize('minimap.size.fill', \"The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling).\"),\n                    nls.localize('minimap.size.fit', \"The minimap will shrink as necessary to never be larger than the editor (no scrolling).\"),\n                ],\n                default: defaults.size,\n                description: nls.localize('minimap.size', \"Controls the size of the minimap.\")\n            },\n            'editor.minimap.side': {\n                type: 'string',\n                enum: ['left', 'right'],\n                default: defaults.side,\n                description: nls.localize('minimap.side', \"Controls the side where to render the minimap.\")\n            },\n            'editor.minimap.showSlider': {\n                type: 'string',\n                enum: ['always', 'mouseover'],\n                default: defaults.showSlider,\n                description: nls.localize('minimap.showSlider', \"Controls when the minimap slider is shown.\")\n            },\n            'editor.minimap.scale': {\n                type: 'number',\n                default: defaults.scale,\n                minimum: 1,\n                maximum: 3,\n                enum: [1, 2, 3],\n                description: nls.localize('minimap.scale', \"Scale of content drawn in the minimap: 1, 2 or 3.\")\n            },\n            'editor.minimap.renderCharacters': {\n                type: 'boolean',\n                default: defaults.renderCharacters,\n                description: nls.localize('minimap.renderCharacters', \"Render the actual characters on a line as opposed to color blocks.\")\n            },\n            'editor.minimap.maxColumn': {\n                type: 'number',\n                default: defaults.maxColumn,\n                description: nls.localize('minimap.maxColumn', \"Limit the width of the minimap to render at most a certain number of columns.\")\n            },\n            'editor.minimap.showRegionSectionHeaders': {\n                type: 'boolean',\n                default: defaults.showRegionSectionHeaders,\n                description: nls.localize('minimap.showRegionSectionHeaders', \"Controls whether named regions are shown as section headers in the minimap.\")\n            },\n            'editor.minimap.showMarkSectionHeaders': {\n                type: 'boolean',\n                default: defaults.showMarkSectionHeaders,\n                description: nls.localize('minimap.showMarkSectionHeaders', \"Controls whether MARK: comments are shown as section headers in the minimap.\")\n            },\n            'editor.minimap.sectionHeaderFontSize': {\n                type: 'number',\n                default: defaults.sectionHeaderFontSize,\n                description: nls.localize('minimap.sectionHeaderFontSize', \"Controls the font size of section headers in the minimap.\")\n            },\n            'editor.minimap.sectionHeaderLetterSpacing': {\n                type: 'number',\n                default: defaults.sectionHeaderLetterSpacing,\n                description: nls.localize('minimap.sectionHeaderLetterSpacing', \"Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            autohide: boolean(input.autohide, this.defaultValue.autohide),\n            size: stringSet(input.size, this.defaultValue.size, ['proportional', 'fill', 'fit']),\n            side: stringSet(input.side, this.defaultValue.side, ['right', 'left']),\n            showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ['always', 'mouseover']),\n            renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),\n            scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),\n            maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 10000),\n            showRegionSectionHeaders: boolean(input.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),\n            showMarkSectionHeaders: boolean(input.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),\n            sectionHeaderFontSize: EditorFloatOption.clamp(input.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),\n            sectionHeaderLetterSpacing: EditorFloatOption.clamp(input.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5),\n        };\n    }\n}\n//#endregion\n//#region multiCursorModifier\nfunction _multiCursorModifierFromString(multiCursorModifier) {\n    if (multiCursorModifier === 'ctrlCmd') {\n        return (platform.isMacintosh ? 'metaKey' : 'ctrlKey');\n    }\n    return 'altKey';\n}\nclass EditorPadding extends BaseEditorOption {\n    constructor() {\n        super(84 /* EditorOption.padding */, 'padding', { top: 0, bottom: 0 }, {\n            'editor.padding.top': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: nls.localize('padding.top', \"Controls the amount of space between the top edge of the editor and the first line.\")\n            },\n            'editor.padding.bottom': {\n                type: 'number',\n                default: 0,\n                minimum: 0,\n                maximum: 1000,\n                description: nls.localize('padding.bottom', \"Controls the amount of space between the bottom edge of the editor and the last line.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            top: EditorIntOption.clampedInt(input.top, 0, 0, 1000),\n            bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1000)\n        };\n    }\n}\nclass EditorParameterHints extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            cycle: true\n        };\n        super(86 /* EditorOption.parameterHints */, 'parameterHints', defaults, {\n            'editor.parameterHints.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('parameterHints.enabled', \"Enables a pop-up that shows parameter documentation and type information as you type.\")\n            },\n            'editor.parameterHints.cycle': {\n                type: 'boolean',\n                default: defaults.cycle,\n                description: nls.localize('parameterHints.cycle', \"Controls whether the parameter hints menu cycles or closes when reaching the end of the list.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            cycle: boolean(input.cycle, this.defaultValue.cycle)\n        };\n    }\n}\n//#endregion\n//#region pixelRatio\nclass EditorPixelRatio extends ComputedEditorOption {\n    constructor() {\n        super(144 /* EditorOption.pixelRatio */);\n    }\n    compute(env, options, _) {\n        return env.pixelRatio;\n    }\n}\n//#endregion\n//#region\nclass PlaceholderOption extends BaseEditorOption {\n    constructor() {\n        super(88 /* EditorOption.placeholder */, 'placeholder', undefined);\n    }\n    validate(input) {\n        if (typeof input === 'undefined') {\n            return this.defaultValue;\n        }\n        if (typeof input === 'string') {\n            return input;\n        }\n        return this.defaultValue;\n    }\n}\nclass EditorQuickSuggestions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            other: 'on',\n            comments: 'off',\n            strings: 'off'\n        };\n        const types = [\n            { type: 'boolean' },\n            {\n                type: 'string',\n                enum: ['on', 'inline', 'off'],\n                enumDescriptions: [nls.localize('on', \"Quick suggestions show inside the suggest widget\"), nls.localize('inline', \"Quick suggestions show as ghost text\"), nls.localize('off', \"Quick suggestions are disabled\")]\n            }\n        ];\n        super(90 /* EditorOption.quickSuggestions */, 'quickSuggestions', defaults, {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n                strings: {\n                    anyOf: types,\n                    default: defaults.strings,\n                    description: nls.localize('quickSuggestions.strings', \"Enable quick suggestions inside strings.\")\n                },\n                comments: {\n                    anyOf: types,\n                    default: defaults.comments,\n                    description: nls.localize('quickSuggestions.comments', \"Enable quick suggestions inside comments.\")\n                },\n                other: {\n                    anyOf: types,\n                    default: defaults.other,\n                    description: nls.localize('quickSuggestions.other', \"Enable quick suggestions outside of strings and comments.\")\n                },\n            },\n            default: defaults,\n            markdownDescription: nls.localize('quickSuggestions', \"Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.\", '`#editor.suggestOnTriggerCharacters#`')\n        });\n        this.defaultValue = defaults;\n    }\n    validate(input) {\n        if (typeof input === 'boolean') {\n            // boolean -> all on/off\n            const value = input ? 'on' : 'off';\n            return { comments: value, strings: value, other: value };\n        }\n        if (!input || typeof input !== 'object') {\n            // invalid object\n            return this.defaultValue;\n        }\n        const { other, comments, strings } = input;\n        const allowedValues = ['on', 'inline', 'off'];\n        let validatedOther;\n        let validatedComments;\n        let validatedStrings;\n        if (typeof other === 'boolean') {\n            validatedOther = other ? 'on' : 'off';\n        }\n        else {\n            validatedOther = stringSet(other, this.defaultValue.other, allowedValues);\n        }\n        if (typeof comments === 'boolean') {\n            validatedComments = comments ? 'on' : 'off';\n        }\n        else {\n            validatedComments = stringSet(comments, this.defaultValue.comments, allowedValues);\n        }\n        if (typeof strings === 'boolean') {\n            validatedStrings = strings ? 'on' : 'off';\n        }\n        else {\n            validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);\n        }\n        return {\n            other: validatedOther,\n            comments: validatedComments,\n            strings: validatedStrings\n        };\n    }\n}\nclass EditorRenderLineNumbersOption extends BaseEditorOption {\n    constructor() {\n        super(68 /* EditorOption.lineNumbers */, 'lineNumbers', { renderType: 1 /* RenderLineNumbersType.On */, renderFn: null }, {\n            type: 'string',\n            enum: ['off', 'on', 'relative', 'interval'],\n            enumDescriptions: [\n                nls.localize('lineNumbers.off', \"Line numbers are not rendered.\"),\n                nls.localize('lineNumbers.on', \"Line numbers are rendered as absolute number.\"),\n                nls.localize('lineNumbers.relative', \"Line numbers are rendered as distance in lines to cursor position.\"),\n                nls.localize('lineNumbers.interval', \"Line numbers are rendered every 10 lines.\")\n            ],\n            default: 'on',\n            description: nls.localize('lineNumbers', \"Controls the display of line numbers.\")\n        });\n    }\n    validate(lineNumbers) {\n        let renderType = this.defaultValue.renderType;\n        let renderFn = this.defaultValue.renderFn;\n        if (typeof lineNumbers !== 'undefined') {\n            if (typeof lineNumbers === 'function') {\n                renderType = 4 /* RenderLineNumbersType.Custom */;\n                renderFn = lineNumbers;\n            }\n            else if (lineNumbers === 'interval') {\n                renderType = 3 /* RenderLineNumbersType.Interval */;\n            }\n            else if (lineNumbers === 'relative') {\n                renderType = 2 /* RenderLineNumbersType.Relative */;\n            }\n            else if (lineNumbers === 'on') {\n                renderType = 1 /* RenderLineNumbersType.On */;\n            }\n            else {\n                renderType = 0 /* RenderLineNumbersType.Off */;\n            }\n        }\n        return {\n            renderType,\n            renderFn\n        };\n    }\n}\n//#endregion\n//#region renderValidationDecorations\n/**\n * @internal\n */\nexport function filterValidationDecorations(options) {\n    const renderValidationDecorations = options.get(99 /* EditorOption.renderValidationDecorations */);\n    if (renderValidationDecorations === 'editable') {\n        return options.get(92 /* EditorOption.readOnly */);\n    }\n    return renderValidationDecorations === 'on' ? false : true;\n}\nclass EditorRulers extends BaseEditorOption {\n    constructor() {\n        const defaults = [];\n        const columnSchema = { type: 'number', description: nls.localize('rulers.size', \"Number of monospace characters at which this editor ruler will render.\") };\n        super(103 /* EditorOption.rulers */, 'rulers', defaults, {\n            type: 'array',\n            items: {\n                anyOf: [\n                    columnSchema,\n                    {\n                        type: [\n                            'object'\n                        ],\n                        properties: {\n                            column: columnSchema,\n                            color: {\n                                type: 'string',\n                                description: nls.localize('rulers.color', \"Color of this editor ruler.\"),\n                                format: 'color-hex'\n                            }\n                        }\n                    }\n                ]\n            },\n            default: defaults,\n            description: nls.localize('rulers', \"Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.\")\n        });\n    }\n    validate(input) {\n        if (Array.isArray(input)) {\n            const rulers = [];\n            for (const _element of input) {\n                if (typeof _element === 'number') {\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(_element, 0, 0, 10000),\n                        color: null\n                    });\n                }\n                else if (_element && typeof _element === 'object') {\n                    const element = _element;\n                    rulers.push({\n                        column: EditorIntOption.clampedInt(element.column, 0, 0, 10000),\n                        color: element.color\n                    });\n                }\n            }\n            rulers.sort((a, b) => a.column - b.column);\n            return rulers;\n        }\n        return this.defaultValue;\n    }\n}\n//#endregion\n//#region readonly\n/**\n * Configuration options for readonly message\n */\nclass ReadonlyMessage extends BaseEditorOption {\n    constructor() {\n        const defaults = undefined;\n        super(93 /* EditorOption.readOnlyMessage */, 'readOnlyMessage', defaults);\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        return _input;\n    }\n}\nfunction _scrollbarVisibilityFromString(visibility, defaultValue) {\n    if (typeof visibility !== 'string') {\n        return defaultValue;\n    }\n    switch (visibility) {\n        case 'hidden': return 2 /* ScrollbarVisibility.Hidden */;\n        case 'visible': return 3 /* ScrollbarVisibility.Visible */;\n        default: return 1 /* ScrollbarVisibility.Auto */;\n    }\n}\nclass EditorScrollbar extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            vertical: 1 /* ScrollbarVisibility.Auto */,\n            horizontal: 1 /* ScrollbarVisibility.Auto */,\n            arrowSize: 11,\n            useShadows: true,\n            verticalHasArrows: false,\n            horizontalHasArrows: false,\n            horizontalScrollbarSize: 12,\n            horizontalSliderSize: 12,\n            verticalScrollbarSize: 14,\n            verticalSliderSize: 14,\n            handleMouseWheel: true,\n            alwaysConsumeMouseWheel: true,\n            scrollByPage: false,\n            ignoreHorizontalScrollbarInContentHeight: false,\n        };\n        super(104 /* EditorOption.scrollbar */, 'scrollbar', defaults, {\n            'editor.scrollbar.vertical': {\n                type: 'string',\n                enum: ['auto', 'visible', 'hidden'],\n                enumDescriptions: [\n                    nls.localize('scrollbar.vertical.auto', \"The vertical scrollbar will be visible only when necessary.\"),\n                    nls.localize('scrollbar.vertical.visible', \"The vertical scrollbar will always be visible.\"),\n                    nls.localize('scrollbar.vertical.fit', \"The vertical scrollbar will always be hidden.\"),\n                ],\n                default: 'auto',\n                description: nls.localize('scrollbar.vertical', \"Controls the visibility of the vertical scrollbar.\")\n            },\n            'editor.scrollbar.horizontal': {\n                type: 'string',\n                enum: ['auto', 'visible', 'hidden'],\n                enumDescriptions: [\n                    nls.localize('scrollbar.horizontal.auto', \"The horizontal scrollbar will be visible only when necessary.\"),\n                    nls.localize('scrollbar.horizontal.visible', \"The horizontal scrollbar will always be visible.\"),\n                    nls.localize('scrollbar.horizontal.fit', \"The horizontal scrollbar will always be hidden.\"),\n                ],\n                default: 'auto',\n                description: nls.localize('scrollbar.horizontal', \"Controls the visibility of the horizontal scrollbar.\")\n            },\n            'editor.scrollbar.verticalScrollbarSize': {\n                type: 'number',\n                default: defaults.verticalScrollbarSize,\n                description: nls.localize('scrollbar.verticalScrollbarSize', \"The width of the vertical scrollbar.\")\n            },\n            'editor.scrollbar.horizontalScrollbarSize': {\n                type: 'number',\n                default: defaults.horizontalScrollbarSize,\n                description: nls.localize('scrollbar.horizontalScrollbarSize', \"The height of the horizontal scrollbar.\")\n            },\n            'editor.scrollbar.scrollByPage': {\n                type: 'boolean',\n                default: defaults.scrollByPage,\n                description: nls.localize('scrollbar.scrollByPage', \"Controls whether clicks scroll by page or jump to click position.\")\n            },\n            'editor.scrollbar.ignoreHorizontalScrollbarInContentHeight': {\n                type: 'boolean',\n                default: defaults.ignoreHorizontalScrollbarInContentHeight,\n                description: nls.localize('scrollbar.ignoreHorizontalScrollbarInContentHeight', \"When set, the horizontal scrollbar will not increase the size of the editor's content.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1000);\n        const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1000);\n        return {\n            arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1000),\n            vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),\n            horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),\n            useShadows: boolean(input.useShadows, this.defaultValue.useShadows),\n            verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),\n            horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),\n            handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),\n            alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),\n            horizontalScrollbarSize: horizontalScrollbarSize,\n            horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),\n            verticalScrollbarSize: verticalScrollbarSize,\n            verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1000),\n            scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage),\n            ignoreHorizontalScrollbarInContentHeight: boolean(input.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight),\n        };\n    }\n}\n/**\n * @internal\n*/\nexport const inUntrustedWorkspace = 'inUntrustedWorkspace';\n/**\n * @internal\n */\nexport const unicodeHighlightConfigKeys = {\n    allowedCharacters: 'editor.unicodeHighlight.allowedCharacters',\n    invisibleCharacters: 'editor.unicodeHighlight.invisibleCharacters',\n    nonBasicASCII: 'editor.unicodeHighlight.nonBasicASCII',\n    ambiguousCharacters: 'editor.unicodeHighlight.ambiguousCharacters',\n    includeComments: 'editor.unicodeHighlight.includeComments',\n    includeStrings: 'editor.unicodeHighlight.includeStrings',\n    allowedLocales: 'editor.unicodeHighlight.allowedLocales',\n};\nclass UnicodeHighlight extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            nonBasicASCII: inUntrustedWorkspace,\n            invisibleCharacters: true,\n            ambiguousCharacters: true,\n            includeComments: inUntrustedWorkspace,\n            includeStrings: true,\n            allowedCharacters: {},\n            allowedLocales: { _os: true, _vscode: true },\n        };\n        super(126 /* EditorOption.unicodeHighlighting */, 'unicodeHighlight', defaults, {\n            [unicodeHighlightConfigKeys.nonBasicASCII]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.nonBasicASCII,\n                description: nls.localize('unicodeHighlight.nonBasicASCII', \"Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.\")\n            },\n            [unicodeHighlightConfigKeys.invisibleCharacters]: {\n                restricted: true,\n                type: 'boolean',\n                default: defaults.invisibleCharacters,\n                description: nls.localize('unicodeHighlight.invisibleCharacters', \"Controls whether characters that just reserve space or have no width at all are highlighted.\")\n            },\n            [unicodeHighlightConfigKeys.ambiguousCharacters]: {\n                restricted: true,\n                type: 'boolean',\n                default: defaults.ambiguousCharacters,\n                description: nls.localize('unicodeHighlight.ambiguousCharacters', \"Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.\")\n            },\n            [unicodeHighlightConfigKeys.includeComments]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.includeComments,\n                description: nls.localize('unicodeHighlight.includeComments', \"Controls whether characters in comments should also be subject to Unicode highlighting.\")\n            },\n            [unicodeHighlightConfigKeys.includeStrings]: {\n                restricted: true,\n                type: ['boolean', 'string'],\n                enum: [true, false, inUntrustedWorkspace],\n                default: defaults.includeStrings,\n                description: nls.localize('unicodeHighlight.includeStrings', \"Controls whether characters in strings should also be subject to Unicode highlighting.\")\n            },\n            [unicodeHighlightConfigKeys.allowedCharacters]: {\n                restricted: true,\n                type: 'object',\n                default: defaults.allowedCharacters,\n                description: nls.localize('unicodeHighlight.allowedCharacters', \"Defines allowed characters that are not being highlighted.\"),\n                additionalProperties: {\n                    type: 'boolean'\n                }\n            },\n            [unicodeHighlightConfigKeys.allowedLocales]: {\n                restricted: true,\n                type: 'object',\n                additionalProperties: {\n                    type: 'boolean'\n                },\n                default: defaults.allowedLocales,\n                description: nls.localize('unicodeHighlight.allowedLocales', \"Unicode characters that are common in allowed locales are not being highlighted.\")\n            },\n        });\n    }\n    applyUpdate(value, update) {\n        let didChange = false;\n        if (update.allowedCharacters && value) {\n            // Treat allowedCharacters atomically\n            if (!objects.equals(value.allowedCharacters, update.allowedCharacters)) {\n                value = { ...value, allowedCharacters: update.allowedCharacters };\n                didChange = true;\n            }\n        }\n        if (update.allowedLocales && value) {\n            // Treat allowedLocales atomically\n            if (!objects.equals(value.allowedLocales, update.allowedLocales)) {\n                value = { ...value, allowedLocales: update.allowedLocales };\n                didChange = true;\n            }\n        }\n        const result = super.applyUpdate(value, update);\n        if (didChange) {\n            return new ApplyUpdateResult(result.newValue, true);\n        }\n        return result;\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            nonBasicASCII: primitiveSet(input.nonBasicASCII, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),\n            ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),\n            includeComments: primitiveSet(input.includeComments, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            includeStrings: primitiveSet(input.includeStrings, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),\n            allowedCharacters: this.validateBooleanMap(_input.allowedCharacters, this.defaultValue.allowedCharacters),\n            allowedLocales: this.validateBooleanMap(_input.allowedLocales, this.defaultValue.allowedLocales),\n        };\n    }\n    validateBooleanMap(map, defaultValue) {\n        if ((typeof map !== 'object') || !map) {\n            return defaultValue;\n        }\n        const result = {};\n        for (const [key, value] of Object.entries(map)) {\n            if (value === true) {\n                result[key] = true;\n            }\n        }\n        return result;\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass InlineEditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: true,\n            mode: 'subwordSmart',\n            showToolbar: 'onHover',\n            suppressSuggestions: false,\n            keepOnBlur: false,\n            fontFamily: 'default'\n        };\n        super(62 /* EditorOption.inlineSuggest */, 'inlineSuggest', defaults, {\n            'editor.inlineSuggest.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('inlineSuggest.enabled', \"Controls whether to automatically show inline suggestions in the editor.\")\n            },\n            'editor.inlineSuggest.showToolbar': {\n                type: 'string',\n                default: defaults.showToolbar,\n                enum: ['always', 'onHover', 'never'],\n                enumDescriptions: [\n                    nls.localize('inlineSuggest.showToolbar.always', \"Show the inline suggestion toolbar whenever an inline suggestion is shown.\"),\n                    nls.localize('inlineSuggest.showToolbar.onHover', \"Show the inline suggestion toolbar when hovering over an inline suggestion.\"),\n                    nls.localize('inlineSuggest.showToolbar.never', \"Never show the inline suggestion toolbar.\"),\n                ],\n                description: nls.localize('inlineSuggest.showToolbar', \"Controls when to show the inline suggestion toolbar.\"),\n            },\n            'editor.inlineSuggest.suppressSuggestions': {\n                type: 'boolean',\n                default: defaults.suppressSuggestions,\n                description: nls.localize('inlineSuggest.suppressSuggestions', \"Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.\")\n            },\n            'editor.inlineSuggest.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                description: nls.localize('inlineSuggest.fontFamily', \"Controls the font family of the inline suggestions.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            mode: stringSet(input.mode, this.defaultValue.mode, ['prefix', 'subword', 'subwordSmart']),\n            showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ['always', 'onHover', 'never']),\n            suppressSuggestions: boolean(input.suppressSuggestions, this.defaultValue.suppressSuggestions),\n            keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily)\n        };\n    }\n}\nclass InlineEditorEdit extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: false,\n            showToolbar: 'onHover',\n            fontFamily: 'default',\n            keepOnBlur: false,\n        };\n        super(63 /* EditorOption.inlineEdit */, 'experimentalInlineEdit', defaults, {\n            'editor.experimentalInlineEdit.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                description: nls.localize('inlineEdit.enabled', \"Controls whether to show inline edits in the editor.\")\n            },\n            'editor.experimentalInlineEdit.showToolbar': {\n                type: 'string',\n                default: defaults.showToolbar,\n                enum: ['always', 'onHover', 'never'],\n                enumDescriptions: [\n                    nls.localize('inlineEdit.showToolbar.always', \"Show the inline edit toolbar whenever an inline suggestion is shown.\"),\n                    nls.localize('inlineEdit.showToolbar.onHover', \"Show the inline edit toolbar when hovering over an inline suggestion.\"),\n                    nls.localize('inlineEdit.showToolbar.never', \"Never show the inline edit toolbar.\"),\n                ],\n                description: nls.localize('inlineEdit.showToolbar', \"Controls when to show the inline edit toolbar.\"),\n            },\n            'editor.experimentalInlineEdit.fontFamily': {\n                type: 'string',\n                default: defaults.fontFamily,\n                description: nls.localize('inlineEdit.fontFamily', \"Controls the font family of the inline edit.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ['always', 'onHover', 'never']),\n            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),\n            keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),\n        };\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass BracketPairColorization extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            enabled: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.enabled,\n            independentColorPoolPerBracketType: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.independentColorPoolPerBracketType,\n        };\n        super(15 /* EditorOption.bracketPairColorization */, 'bracketPairColorization', defaults, {\n            'editor.bracketPairColorization.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: nls.localize('bracketPairColorization.enabled', \"Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.\", '`#workbench.colorCustomizations#`')\n            },\n            'editor.bracketPairColorization.independentColorPoolPerBracketType': {\n                type: 'boolean',\n                default: defaults.independentColorPoolPerBracketType,\n                description: nls.localize('bracketPairColorization.independentColorPoolPerBracketType', \"Controls whether each bracket type has its own independent color pool.\")\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType),\n        };\n    }\n}\n/**\n * Configuration options for inline suggestions\n */\nclass GuideOptions extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            bracketPairs: false,\n            bracketPairsHorizontal: 'active',\n            highlightActiveBracketPair: true,\n            indentation: true,\n            highlightActiveIndentation: true\n        };\n        super(16 /* EditorOption.guides */, 'guides', defaults, {\n            'editor.guides.bracketPairs': {\n                type: ['boolean', 'string'],\n                enum: [true, 'active', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.bracketPairs.true', \"Enables bracket pair guides.\"),\n                    nls.localize('editor.guides.bracketPairs.active', \"Enables bracket pair guides only for the active bracket pair.\"),\n                    nls.localize('editor.guides.bracketPairs.false', \"Disables bracket pair guides.\"),\n                ],\n                default: defaults.bracketPairs,\n                description: nls.localize('editor.guides.bracketPairs', \"Controls whether bracket pair guides are enabled or not.\")\n            },\n            'editor.guides.bracketPairsHorizontal': {\n                type: ['boolean', 'string'],\n                enum: [true, 'active', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.bracketPairsHorizontal.true', \"Enables horizontal guides as addition to vertical bracket pair guides.\"),\n                    nls.localize('editor.guides.bracketPairsHorizontal.active', \"Enables horizontal guides only for the active bracket pair.\"),\n                    nls.localize('editor.guides.bracketPairsHorizontal.false', \"Disables horizontal bracket pair guides.\"),\n                ],\n                default: defaults.bracketPairsHorizontal,\n                description: nls.localize('editor.guides.bracketPairsHorizontal', \"Controls whether horizontal bracket pair guides are enabled or not.\")\n            },\n            'editor.guides.highlightActiveBracketPair': {\n                type: 'boolean',\n                default: defaults.highlightActiveBracketPair,\n                description: nls.localize('editor.guides.highlightActiveBracketPair', \"Controls whether the editor should highlight the active bracket pair.\")\n            },\n            'editor.guides.indentation': {\n                type: 'boolean',\n                default: defaults.indentation,\n                description: nls.localize('editor.guides.indentation', \"Controls whether the editor should render indent guides.\")\n            },\n            'editor.guides.highlightActiveIndentation': {\n                type: ['boolean', 'string'],\n                enum: [true, 'always', false],\n                enumDescriptions: [\n                    nls.localize('editor.guides.highlightActiveIndentation.true', \"Highlights the active indent guide.\"),\n                    nls.localize('editor.guides.highlightActiveIndentation.always', \"Highlights the active indent guide even if bracket guides are highlighted.\"),\n                    nls.localize('editor.guides.highlightActiveIndentation.false', \"Do not highlight the active indent guide.\"),\n                ],\n                default: defaults.highlightActiveIndentation,\n                description: nls.localize('editor.guides.highlightActiveIndentation', \"Controls whether the editor should highlight the active indent guide.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, 'active']),\n            bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, 'active']),\n            highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),\n            indentation: boolean(input.indentation, this.defaultValue.indentation),\n            highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, 'always']),\n        };\n    }\n}\nfunction primitiveSet(value, defaultValue, allowedValues) {\n    const idx = allowedValues.indexOf(value);\n    if (idx === -1) {\n        return defaultValue;\n    }\n    return allowedValues[idx];\n}\nclass EditorSuggest extends BaseEditorOption {\n    constructor() {\n        const defaults = {\n            insertMode: 'insert',\n            filterGraceful: true,\n            snippetsPreventQuickSuggestions: false,\n            localityBonus: false,\n            shareSuggestSelections: false,\n            selectionMode: 'always',\n            showIcons: true,\n            showStatusBar: false,\n            preview: false,\n            previewMode: 'subwordSmart',\n            showInlineDetails: true,\n            showMethods: true,\n            showFunctions: true,\n            showConstructors: true,\n            showDeprecated: true,\n            matchOnWordStartOnly: true,\n            showFields: true,\n            showVariables: true,\n            showClasses: true,\n            showStructs: true,\n            showInterfaces: true,\n            showModules: true,\n            showProperties: true,\n            showEvents: true,\n            showOperators: true,\n            showUnits: true,\n            showValues: true,\n            showConstants: true,\n            showEnums: true,\n            showEnumMembers: true,\n            showKeywords: true,\n            showWords: true,\n            showColors: true,\n            showFiles: true,\n            showReferences: true,\n            showFolders: true,\n            showTypeParameters: true,\n            showSnippets: true,\n            showUsers: true,\n            showIssues: true,\n        };\n        super(119 /* EditorOption.suggest */, 'suggest', defaults, {\n            'editor.suggest.insertMode': {\n                type: 'string',\n                enum: ['insert', 'replace'],\n                enumDescriptions: [\n                    nls.localize('suggest.insertMode.insert', \"Insert suggestion without overwriting text right of the cursor.\"),\n                    nls.localize('suggest.insertMode.replace', \"Insert suggestion and overwrite text right of the cursor.\"),\n                ],\n                default: defaults.insertMode,\n                description: nls.localize('suggest.insertMode', \"Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.\")\n            },\n            'editor.suggest.filterGraceful': {\n                type: 'boolean',\n                default: defaults.filterGraceful,\n                description: nls.localize('suggest.filterGraceful', \"Controls whether filtering and sorting suggestions accounts for small typos.\")\n            },\n            'editor.suggest.localityBonus': {\n                type: 'boolean',\n                default: defaults.localityBonus,\n                description: nls.localize('suggest.localityBonus', \"Controls whether sorting favors words that appear close to the cursor.\")\n            },\n            'editor.suggest.shareSuggestSelections': {\n                type: 'boolean',\n                default: defaults.shareSuggestSelections,\n                markdownDescription: nls.localize('suggest.shareSuggestSelections', \"Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).\")\n            },\n            'editor.suggest.selectionMode': {\n                type: 'string',\n                enum: ['always', 'never', 'whenTriggerCharacter', 'whenQuickSuggestion'],\n                enumDescriptions: [\n                    nls.localize('suggest.insertMode.always', \"Always select a suggestion when automatically triggering IntelliSense.\"),\n                    nls.localize('suggest.insertMode.never', \"Never select a suggestion when automatically triggering IntelliSense.\"),\n                    nls.localize('suggest.insertMode.whenTriggerCharacter', \"Select a suggestion only when triggering IntelliSense from a trigger character.\"),\n                    nls.localize('suggest.insertMode.whenQuickSuggestion', \"Select a suggestion only when triggering IntelliSense as you type.\"),\n                ],\n                default: defaults.selectionMode,\n                markdownDescription: nls.localize('suggest.selectionMode', \"Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.\", '`#editor.quickSuggestions#`', '`#editor.suggestOnTriggerCharacters#`')\n            },\n            'editor.suggest.snippetsPreventQuickSuggestions': {\n                type: 'boolean',\n                default: defaults.snippetsPreventQuickSuggestions,\n                description: nls.localize('suggest.snippetsPreventQuickSuggestions', \"Controls whether an active snippet prevents quick suggestions.\")\n            },\n            'editor.suggest.showIcons': {\n                type: 'boolean',\n                default: defaults.showIcons,\n                description: nls.localize('suggest.showIcons', \"Controls whether to show or hide icons in suggestions.\")\n            },\n            'editor.suggest.showStatusBar': {\n                type: 'boolean',\n                default: defaults.showStatusBar,\n                description: nls.localize('suggest.showStatusBar', \"Controls the visibility of the status bar at the bottom of the suggest widget.\")\n            },\n            'editor.suggest.preview': {\n                type: 'boolean',\n                default: defaults.preview,\n                description: nls.localize('suggest.preview', \"Controls whether to preview the suggestion outcome in the editor.\")\n            },\n            'editor.suggest.showInlineDetails': {\n                type: 'boolean',\n                default: defaults.showInlineDetails,\n                description: nls.localize('suggest.showInlineDetails', \"Controls whether suggest details show inline with the label or only in the details widget.\")\n            },\n            'editor.suggest.maxVisibleSuggestions': {\n                type: 'number',\n                deprecationMessage: nls.localize('suggest.maxVisibleSuggestions.dep', \"This setting is deprecated. The suggest widget can now be resized.\"),\n            },\n            'editor.suggest.filteredTypes': {\n                type: 'object',\n                deprecationMessage: nls.localize('deprecated', \"This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.\")\n            },\n            'editor.suggest.showMethods': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showMethods', \"When enabled IntelliSense shows `method`-suggestions.\")\n            },\n            'editor.suggest.showFunctions': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFunctions', \"When enabled IntelliSense shows `function`-suggestions.\")\n            },\n            'editor.suggest.showConstructors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showConstructors', \"When enabled IntelliSense shows `constructor`-suggestions.\")\n            },\n            'editor.suggest.showDeprecated': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showDeprecated', \"When enabled IntelliSense shows `deprecated`-suggestions.\")\n            },\n            'editor.suggest.matchOnWordStartOnly': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.matchOnWordStartOnly', \"When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.\")\n            },\n            'editor.suggest.showFields': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFields', \"When enabled IntelliSense shows `field`-suggestions.\")\n            },\n            'editor.suggest.showVariables': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showVariables', \"When enabled IntelliSense shows `variable`-suggestions.\")\n            },\n            'editor.suggest.showClasses': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showClasss', \"When enabled IntelliSense shows `class`-suggestions.\")\n            },\n            'editor.suggest.showStructs': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showStructs', \"When enabled IntelliSense shows `struct`-suggestions.\")\n            },\n            'editor.suggest.showInterfaces': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showInterfaces', \"When enabled IntelliSense shows `interface`-suggestions.\")\n            },\n            'editor.suggest.showModules': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showModules', \"When enabled IntelliSense shows `module`-suggestions.\")\n            },\n            'editor.suggest.showProperties': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showPropertys', \"When enabled IntelliSense shows `property`-suggestions.\")\n            },\n            'editor.suggest.showEvents': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEvents', \"When enabled IntelliSense shows `event`-suggestions.\")\n            },\n            'editor.suggest.showOperators': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showOperators', \"When enabled IntelliSense shows `operator`-suggestions.\")\n            },\n            'editor.suggest.showUnits': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showUnits', \"When enabled IntelliSense shows `unit`-suggestions.\")\n            },\n            'editor.suggest.showValues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showValues', \"When enabled IntelliSense shows `value`-suggestions.\")\n            },\n            'editor.suggest.showConstants': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showConstants', \"When enabled IntelliSense shows `constant`-suggestions.\")\n            },\n            'editor.suggest.showEnums': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEnums', \"When enabled IntelliSense shows `enum`-suggestions.\")\n            },\n            'editor.suggest.showEnumMembers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showEnumMembers', \"When enabled IntelliSense shows `enumMember`-suggestions.\")\n            },\n            'editor.suggest.showKeywords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showKeywords', \"When enabled IntelliSense shows `keyword`-suggestions.\")\n            },\n            'editor.suggest.showWords': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showTexts', \"When enabled IntelliSense shows `text`-suggestions.\")\n            },\n            'editor.suggest.showColors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showColors', \"When enabled IntelliSense shows `color`-suggestions.\")\n            },\n            'editor.suggest.showFiles': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFiles', \"When enabled IntelliSense shows `file`-suggestions.\")\n            },\n            'editor.suggest.showReferences': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showReferences', \"When enabled IntelliSense shows `reference`-suggestions.\")\n            },\n            'editor.suggest.showCustomcolors': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showCustomcolors', \"When enabled IntelliSense shows `customcolor`-suggestions.\")\n            },\n            'editor.suggest.showFolders': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showFolders', \"When enabled IntelliSense shows `folder`-suggestions.\")\n            },\n            'editor.suggest.showTypeParameters': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showTypeParameters', \"When enabled IntelliSense shows `typeParameter`-suggestions.\")\n            },\n            'editor.suggest.showSnippets': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showSnippets', \"When enabled IntelliSense shows `snippet`-suggestions.\")\n            },\n            'editor.suggest.showUsers': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showUsers', \"When enabled IntelliSense shows `user`-suggestions.\")\n            },\n            'editor.suggest.showIssues': {\n                type: 'boolean',\n                default: true,\n                markdownDescription: nls.localize('editor.suggest.showIssues', \"When enabled IntelliSense shows `issues`-suggestions.\")\n            }\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ['insert', 'replace']),\n            filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),\n            snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),\n            localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),\n            shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),\n            selectionMode: stringSet(input.selectionMode, this.defaultValue.selectionMode, ['always', 'never', 'whenQuickSuggestion', 'whenTriggerCharacter']),\n            showIcons: boolean(input.showIcons, this.defaultValue.showIcons),\n            showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),\n            preview: boolean(input.preview, this.defaultValue.preview),\n            previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ['prefix', 'subword', 'subwordSmart']),\n            showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),\n            showMethods: boolean(input.showMethods, this.defaultValue.showMethods),\n            showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),\n            showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),\n            showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),\n            matchOnWordStartOnly: boolean(input.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),\n            showFields: boolean(input.showFields, this.defaultValue.showFields),\n            showVariables: boolean(input.showVariables, this.defaultValue.showVariables),\n            showClasses: boolean(input.showClasses, this.defaultValue.showClasses),\n            showStructs: boolean(input.showStructs, this.defaultValue.showStructs),\n            showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),\n            showModules: boolean(input.showModules, this.defaultValue.showModules),\n            showProperties: boolean(input.showProperties, this.defaultValue.showProperties),\n            showEvents: boolean(input.showEvents, this.defaultValue.showEvents),\n            showOperators: boolean(input.showOperators, this.defaultValue.showOperators),\n            showUnits: boolean(input.showUnits, this.defaultValue.showUnits),\n            showValues: boolean(input.showValues, this.defaultValue.showValues),\n            showConstants: boolean(input.showConstants, this.defaultValue.showConstants),\n            showEnums: boolean(input.showEnums, this.defaultValue.showEnums),\n            showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),\n            showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),\n            showWords: boolean(input.showWords, this.defaultValue.showWords),\n            showColors: boolean(input.showColors, this.defaultValue.showColors),\n            showFiles: boolean(input.showFiles, this.defaultValue.showFiles),\n            showReferences: boolean(input.showReferences, this.defaultValue.showReferences),\n            showFolders: boolean(input.showFolders, this.defaultValue.showFolders),\n            showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),\n            showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),\n            showUsers: boolean(input.showUsers, this.defaultValue.showUsers),\n            showIssues: boolean(input.showIssues, this.defaultValue.showIssues),\n        };\n    }\n}\nclass SmartSelect extends BaseEditorOption {\n    constructor() {\n        super(114 /* EditorOption.smartSelect */, 'smartSelect', {\n            selectLeadingAndTrailingWhitespace: true,\n            selectSubwords: true,\n        }, {\n            'editor.smartSelect.selectLeadingAndTrailingWhitespace': {\n                description: nls.localize('selectLeadingAndTrailingWhitespace', \"Whether leading and trailing whitespace should always be selected.\"),\n                default: true,\n                type: 'boolean'\n            },\n            'editor.smartSelect.selectSubwords': {\n                description: nls.localize('selectSubwords', \"Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected.\"),\n                default: true,\n                type: 'boolean'\n            }\n        });\n    }\n    validate(input) {\n        if (!input || typeof input !== 'object') {\n            return this.defaultValue;\n        }\n        return {\n            selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),\n            selectSubwords: boolean(input.selectSubwords, this.defaultValue.selectSubwords),\n        };\n    }\n}\n//#endregion\n//#region wordSegmenterLocales\n/**\n * Locales used for segmenting lines into words when doing word related navigations or operations.\n *\n * Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).\n */\nclass WordSegmenterLocales extends BaseEditorOption {\n    constructor() {\n        const defaults = [];\n        super(131 /* EditorOption.wordSegmenterLocales */, 'wordSegmenterLocales', defaults, {\n            anyOf: [\n                {\n                    description: nls.localize('wordSegmenterLocales', \"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).\"),\n                    type: 'string',\n                }, {\n                    description: nls.localize('wordSegmenterLocales', \"Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).\"),\n                    type: 'array',\n                    items: {\n                        type: 'string'\n                    }\n                }\n            ]\n        });\n    }\n    validate(input) {\n        if (typeof input === 'string') {\n            input = [input];\n        }\n        if (Array.isArray(input)) {\n            const validLocales = [];\n            for (const locale of input) {\n                if (typeof locale === 'string') {\n                    try {\n                        if (Intl.Segmenter.supportedLocalesOf(locale).length > 0) {\n                            validLocales.push(locale);\n                        }\n                    }\n                    catch {\n                        // ignore invalid locales\n                    }\n                }\n            }\n            return validLocales;\n        }\n        return this.defaultValue;\n    }\n}\nclass WrappingIndentOption extends BaseEditorOption {\n    constructor() {\n        super(139 /* EditorOption.wrappingIndent */, 'wrappingIndent', 1 /* WrappingIndent.Same */, {\n            'editor.wrappingIndent': {\n                type: 'string',\n                enum: ['none', 'same', 'indent', 'deepIndent'],\n                enumDescriptions: [\n                    nls.localize('wrappingIndent.none', \"No indentation. Wrapped lines begin at column 1.\"),\n                    nls.localize('wrappingIndent.same', \"Wrapped lines get the same indentation as the parent.\"),\n                    nls.localize('wrappingIndent.indent', \"Wrapped lines get +1 indentation toward the parent.\"),\n                    nls.localize('wrappingIndent.deepIndent', \"Wrapped lines get +2 indentation toward the parent.\"),\n                ],\n                description: nls.localize('wrappingIndent', \"Controls the indentation of wrapped lines.\"),\n                default: 'same'\n            }\n        });\n    }\n    validate(input) {\n        switch (input) {\n            case 'none': return 0 /* WrappingIndent.None */;\n            case 'same': return 1 /* WrappingIndent.Same */;\n            case 'indent': return 2 /* WrappingIndent.Indent */;\n            case 'deepIndent': return 3 /* WrappingIndent.DeepIndent */;\n        }\n        return 1 /* WrappingIndent.Same */;\n    }\n    compute(env, options, value) {\n        const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        if (accessibilitySupport === 2 /* AccessibilitySupport.Enabled */) {\n            // if we know for a fact that a screen reader is attached, we use no indent wrapping to\n            // help that the editor's wrapping points match the textarea's wrapping points\n            return 0 /* WrappingIndent.None */;\n        }\n        return value;\n    }\n}\nclass EditorWrappingInfoComputer extends ComputedEditorOption {\n    constructor() {\n        super(147 /* EditorOption.wrappingInfo */);\n    }\n    compute(env, options, _) {\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        return {\n            isDominatedByLongLines: env.isDominatedByLongLines,\n            isWordWrapMinified: layoutInfo.isWordWrapMinified,\n            isViewportWrapping: layoutInfo.isViewportWrapping,\n            wrappingColumn: layoutInfo.wrappingColumn,\n        };\n    }\n}\nclass EditorDropIntoEditor extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, showDropSelector: 'afterDrop' };\n        super(36 /* EditorOption.dropIntoEditor */, 'dropIntoEditor', defaults, {\n            'editor.dropIntoEditor.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: nls.localize('dropIntoEditor.enabled', \"Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).\"),\n            },\n            'editor.dropIntoEditor.showDropSelector': {\n                type: 'string',\n                markdownDescription: nls.localize('dropIntoEditor.showDropSelector', \"Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped.\"),\n                enum: [\n                    'afterDrop',\n                    'never'\n                ],\n                enumDescriptions: [\n                    nls.localize('dropIntoEditor.showDropSelector.afterDrop', \"Show the drop selector widget after a file is dropped into the editor.\"),\n                    nls.localize('dropIntoEditor.showDropSelector.never', \"Never show the drop selector widget. Instead the default drop provider is always used.\"),\n                ],\n                default: 'afterDrop',\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showDropSelector: stringSet(input.showDropSelector, this.defaultValue.showDropSelector, ['afterDrop', 'never']),\n        };\n    }\n}\nclass EditorPasteAs extends BaseEditorOption {\n    constructor() {\n        const defaults = { enabled: true, showPasteSelector: 'afterPaste' };\n        super(85 /* EditorOption.pasteAs */, 'pasteAs', defaults, {\n            'editor.pasteAs.enabled': {\n                type: 'boolean',\n                default: defaults.enabled,\n                markdownDescription: nls.localize('pasteAs.enabled', \"Controls whether you can paste content in different ways.\"),\n            },\n            'editor.pasteAs.showPasteSelector': {\n                type: 'string',\n                markdownDescription: nls.localize('pasteAs.showPasteSelector', \"Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted.\"),\n                enum: [\n                    'afterPaste',\n                    'never'\n                ],\n                enumDescriptions: [\n                    nls.localize('pasteAs.showPasteSelector.afterPaste', \"Show the paste selector widget after content is pasted into the editor.\"),\n                    nls.localize('pasteAs.showPasteSelector.never', \"Never show the paste selector widget. Instead the default pasting behavior is always used.\"),\n                ],\n                default: 'afterPaste',\n            },\n        });\n    }\n    validate(_input) {\n        if (!_input || typeof _input !== 'object') {\n            return this.defaultValue;\n        }\n        const input = _input;\n        return {\n            enabled: boolean(input.enabled, this.defaultValue.enabled),\n            showPasteSelector: stringSet(input.showPasteSelector, this.defaultValue.showPasteSelector, ['afterPaste', 'never']),\n        };\n    }\n}\n//#endregion\nconst DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\nconst DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\nconst DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'monospace\\', monospace';\n/**\n * @internal\n */\nexport const EDITOR_FONT_DEFAULTS = {\n    fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),\n    fontWeight: 'normal',\n    fontSize: (platform.isMacintosh ? 12 : 14),\n    lineHeight: 0,\n    letterSpacing: 0,\n};\n/**\n * @internal\n */\nexport const editorOptionsRegistry = [];\nfunction register(option) {\n    editorOptionsRegistry[option.id] = option;\n    return option;\n}\nexport const EditorOptions = {\n    acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(0 /* EditorOption.acceptSuggestionOnCommitCharacter */, 'acceptSuggestionOnCommitCharacter', true, { markdownDescription: nls.localize('acceptSuggestionOnCommitCharacter', \"Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.\") })),\n    acceptSuggestionOnEnter: register(new EditorStringEnumOption(1 /* EditorOption.acceptSuggestionOnEnter */, 'acceptSuggestionOnEnter', 'on', ['on', 'smart', 'off'], {\n        markdownEnumDescriptions: [\n            '',\n            nls.localize('acceptSuggestionOnEnterSmart', \"Only accept a suggestion with `Enter` when it makes a textual change.\"),\n            ''\n        ],\n        markdownDescription: nls.localize('acceptSuggestionOnEnter', \"Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.\")\n    })),\n    accessibilitySupport: register(new EditorAccessibilitySupport()),\n    accessibilityPageSize: register(new EditorIntOption(3 /* EditorOption.accessibilityPageSize */, 'accessibilityPageSize', 10, 1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, {\n        description: nls.localize('accessibilityPageSize', \"Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.\"),\n        tags: ['accessibility']\n    })),\n    ariaLabel: register(new EditorStringOption(4 /* EditorOption.ariaLabel */, 'ariaLabel', nls.localize('editorViewAccessibleLabel', \"Editor content\"))),\n    ariaRequired: register(new EditorBooleanOption(5 /* EditorOption.ariaRequired */, 'ariaRequired', false, undefined)),\n    screenReaderAnnounceInlineSuggestion: register(new EditorBooleanOption(8 /* EditorOption.screenReaderAnnounceInlineSuggestion */, 'screenReaderAnnounceInlineSuggestion', true, {\n        description: nls.localize('screenReaderAnnounceInlineSuggestion', \"Control whether inline suggestions are announced by a screen reader.\"),\n        tags: ['accessibility']\n    })),\n    autoClosingBrackets: register(new EditorStringEnumOption(6 /* EditorOption.autoClosingBrackets */, 'autoClosingBrackets', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingBrackets.languageDefined', \"Use language configurations to determine when to autoclose brackets.\"),\n            nls.localize('editor.autoClosingBrackets.beforeWhitespace', \"Autoclose brackets only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingBrackets', \"Controls whether the editor should automatically close brackets after the user adds an opening bracket.\")\n    })),\n    autoClosingComments: register(new EditorStringEnumOption(7 /* EditorOption.autoClosingComments */, 'autoClosingComments', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingComments.languageDefined', \"Use language configurations to determine when to autoclose comments.\"),\n            nls.localize('editor.autoClosingComments.beforeWhitespace', \"Autoclose comments only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingComments', \"Controls whether the editor should automatically close comments after the user adds an opening comment.\")\n    })),\n    autoClosingDelete: register(new EditorStringEnumOption(9 /* EditorOption.autoClosingDelete */, 'autoClosingDelete', 'auto', ['always', 'auto', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingDelete.auto', \"Remove adjacent closing quotes or brackets only if they were automatically inserted.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingDelete', \"Controls whether the editor should remove adjacent closing quotes or brackets when deleting.\")\n    })),\n    autoClosingOvertype: register(new EditorStringEnumOption(10 /* EditorOption.autoClosingOvertype */, 'autoClosingOvertype', 'auto', ['always', 'auto', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingOvertype.auto', \"Type over closing quotes or brackets only if they were automatically inserted.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingOvertype', \"Controls whether the editor should type over closing quotes or brackets.\")\n    })),\n    autoClosingQuotes: register(new EditorStringEnumOption(11 /* EditorOption.autoClosingQuotes */, 'autoClosingQuotes', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {\n        enumDescriptions: [\n            '',\n            nls.localize('editor.autoClosingQuotes.languageDefined', \"Use language configurations to determine when to autoclose quotes.\"),\n            nls.localize('editor.autoClosingQuotes.beforeWhitespace', \"Autoclose quotes only when the cursor is to the left of whitespace.\"),\n            '',\n        ],\n        description: nls.localize('autoClosingQuotes', \"Controls whether the editor should automatically close quotes after the user adds an opening quote.\")\n    })),\n    autoIndent: register(new EditorEnumOption(12 /* EditorOption.autoIndent */, 'autoIndent', 4 /* EditorAutoIndentStrategy.Full */, 'full', ['none', 'keep', 'brackets', 'advanced', 'full'], _autoIndentFromString, {\n        enumDescriptions: [\n            nls.localize('editor.autoIndent.none', \"The editor will not insert indentation automatically.\"),\n            nls.localize('editor.autoIndent.keep', \"The editor will keep the current line's indentation.\"),\n            nls.localize('editor.autoIndent.brackets', \"The editor will keep the current line's indentation and honor language defined brackets.\"),\n            nls.localize('editor.autoIndent.advanced', \"The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages.\"),\n            nls.localize('editor.autoIndent.full', \"The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.\"),\n        ],\n        description: nls.localize('autoIndent', \"Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.\")\n    })),\n    automaticLayout: register(new EditorBooleanOption(13 /* EditorOption.automaticLayout */, 'automaticLayout', false)),\n    autoSurround: register(new EditorStringEnumOption(14 /* EditorOption.autoSurround */, 'autoSurround', 'languageDefined', ['languageDefined', 'quotes', 'brackets', 'never'], {\n        enumDescriptions: [\n            nls.localize('editor.autoSurround.languageDefined', \"Use language configurations to determine when to automatically surround selections.\"),\n            nls.localize('editor.autoSurround.quotes', \"Surround with quotes but not brackets.\"),\n            nls.localize('editor.autoSurround.brackets', \"Surround with brackets but not quotes.\"),\n            ''\n        ],\n        description: nls.localize('autoSurround', \"Controls whether the editor should automatically surround selections when typing quotes or brackets.\")\n    })),\n    bracketPairColorization: register(new BracketPairColorization()),\n    bracketPairGuides: register(new GuideOptions()),\n    stickyTabStops: register(new EditorBooleanOption(117 /* EditorOption.stickyTabStops */, 'stickyTabStops', false, { description: nls.localize('stickyTabStops', \"Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.\") })),\n    codeLens: register(new EditorBooleanOption(17 /* EditorOption.codeLens */, 'codeLens', true, { description: nls.localize('codeLens', \"Controls whether the editor shows CodeLens.\") })),\n    codeLensFontFamily: register(new EditorStringOption(18 /* EditorOption.codeLensFontFamily */, 'codeLensFontFamily', '', { description: nls.localize('codeLensFontFamily', \"Controls the font family for CodeLens.\") })),\n    codeLensFontSize: register(new EditorIntOption(19 /* EditorOption.codeLensFontSize */, 'codeLensFontSize', 0, 0, 100, {\n        type: 'number',\n        default: 0,\n        minimum: 0,\n        maximum: 100,\n        markdownDescription: nls.localize('codeLensFontSize', \"Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.\")\n    })),\n    colorDecorators: register(new EditorBooleanOption(20 /* EditorOption.colorDecorators */, 'colorDecorators', true, { description: nls.localize('colorDecorators', \"Controls whether the editor should render the inline color decorators and color picker.\") })),\n    colorDecoratorActivatedOn: register(new EditorStringEnumOption(149 /* EditorOption.colorDecoratorsActivatedOn */, 'colorDecoratorsActivatedOn', 'clickAndHover', ['clickAndHover', 'hover', 'click'], {\n        enumDescriptions: [\n            nls.localize('editor.colorDecoratorActivatedOn.clickAndHover', \"Make the color picker appear both on click and hover of the color decorator\"),\n            nls.localize('editor.colorDecoratorActivatedOn.hover', \"Make the color picker appear on hover of the color decorator\"),\n            nls.localize('editor.colorDecoratorActivatedOn.click', \"Make the color picker appear on click of the color decorator\")\n        ],\n        description: nls.localize('colorDecoratorActivatedOn', \"Controls the condition to make a color picker appear from a color decorator\")\n    })),\n    colorDecoratorsLimit: register(new EditorIntOption(21 /* EditorOption.colorDecoratorsLimit */, 'colorDecoratorsLimit', 500, 1, 1000000, {\n        markdownDescription: nls.localize('colorDecoratorsLimit', \"Controls the max number of color decorators that can be rendered in an editor at once.\")\n    })),\n    columnSelection: register(new EditorBooleanOption(22 /* EditorOption.columnSelection */, 'columnSelection', false, { description: nls.localize('columnSelection', \"Enable that the selection with the mouse and keys is doing column selection.\") })),\n    comments: register(new EditorComments()),\n    contextmenu: register(new EditorBooleanOption(24 /* EditorOption.contextmenu */, 'contextmenu', true)),\n    copyWithSyntaxHighlighting: register(new EditorBooleanOption(25 /* EditorOption.copyWithSyntaxHighlighting */, 'copyWithSyntaxHighlighting', true, { description: nls.localize('copyWithSyntaxHighlighting', \"Controls whether syntax highlighting should be copied into the clipboard.\") })),\n    cursorBlinking: register(new EditorEnumOption(26 /* EditorOption.cursorBlinking */, 'cursorBlinking', 1 /* TextEditorCursorBlinkingStyle.Blink */, 'blink', ['blink', 'smooth', 'phase', 'expand', 'solid'], _cursorBlinkingStyleFromString, { description: nls.localize('cursorBlinking', \"Control the cursor animation style.\") })),\n    cursorSmoothCaretAnimation: register(new EditorStringEnumOption(27 /* EditorOption.cursorSmoothCaretAnimation */, 'cursorSmoothCaretAnimation', 'off', ['off', 'explicit', 'on'], {\n        enumDescriptions: [\n            nls.localize('cursorSmoothCaretAnimation.off', \"Smooth caret animation is disabled.\"),\n            nls.localize('cursorSmoothCaretAnimation.explicit', \"Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture.\"),\n            nls.localize('cursorSmoothCaretAnimation.on', \"Smooth caret animation is always enabled.\")\n        ],\n        description: nls.localize('cursorSmoothCaretAnimation', \"Controls whether the smooth caret animation should be enabled.\")\n    })),\n    cursorStyle: register(new EditorEnumOption(28 /* EditorOption.cursorStyle */, 'cursorStyle', TextEditorCursorStyle.Line, 'line', ['line', 'block', 'underline', 'line-thin', 'block-outline', 'underline-thin'], _cursorStyleFromString, { description: nls.localize('cursorStyle', \"Controls the cursor style.\") })),\n    cursorSurroundingLines: register(new EditorIntOption(29 /* EditorOption.cursorSurroundingLines */, 'cursorSurroundingLines', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('cursorSurroundingLines', \"Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.\") })),\n    cursorSurroundingLinesStyle: register(new EditorStringEnumOption(30 /* EditorOption.cursorSurroundingLinesStyle */, 'cursorSurroundingLinesStyle', 'default', ['default', 'all'], {\n        enumDescriptions: [\n            nls.localize('cursorSurroundingLinesStyle.default', \"`cursorSurroundingLines` is enforced only when triggered via the keyboard or API.\"),\n            nls.localize('cursorSurroundingLinesStyle.all', \"`cursorSurroundingLines` is enforced always.\")\n        ],\n        markdownDescription: nls.localize('cursorSurroundingLinesStyle', \"Controls when `#editor.cursorSurroundingLines#` should be enforced.\")\n    })),\n    cursorWidth: register(new EditorIntOption(31 /* EditorOption.cursorWidth */, 'cursorWidth', 0, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { markdownDescription: nls.localize('cursorWidth', \"Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.\") })),\n    disableLayerHinting: register(new EditorBooleanOption(32 /* EditorOption.disableLayerHinting */, 'disableLayerHinting', false)),\n    disableMonospaceOptimizations: register(new EditorBooleanOption(33 /* EditorOption.disableMonospaceOptimizations */, 'disableMonospaceOptimizations', false)),\n    domReadOnly: register(new EditorBooleanOption(34 /* EditorOption.domReadOnly */, 'domReadOnly', false)),\n    dragAndDrop: register(new EditorBooleanOption(35 /* EditorOption.dragAndDrop */, 'dragAndDrop', true, { description: nls.localize('dragAndDrop', \"Controls whether the editor should allow moving selections via drag and drop.\") })),\n    emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),\n    dropIntoEditor: register(new EditorDropIntoEditor()),\n    stickyScroll: register(new EditorStickyScroll()),\n    experimentalWhitespaceRendering: register(new EditorStringEnumOption(38 /* EditorOption.experimentalWhitespaceRendering */, 'experimentalWhitespaceRendering', 'svg', ['svg', 'font', 'off'], {\n        enumDescriptions: [\n            nls.localize('experimentalWhitespaceRendering.svg', \"Use a new rendering method with svgs.\"),\n            nls.localize('experimentalWhitespaceRendering.font', \"Use a new rendering method with font characters.\"),\n            nls.localize('experimentalWhitespaceRendering.off', \"Use the stable rendering method.\"),\n        ],\n        description: nls.localize('experimentalWhitespaceRendering', \"Controls whether whitespace is rendered with a new, experimental method.\")\n    })),\n    extraEditorClassName: register(new EditorStringOption(39 /* EditorOption.extraEditorClassName */, 'extraEditorClassName', '')),\n    fastScrollSensitivity: register(new EditorFloatOption(40 /* EditorOption.fastScrollSensitivity */, 'fastScrollSensitivity', 5, x => (x <= 0 ? 5 : x), { markdownDescription: nls.localize('fastScrollSensitivity', \"Scrolling speed multiplier when pressing `Alt`.\") })),\n    find: register(new EditorFind()),\n    fixedOverflowWidgets: register(new EditorBooleanOption(42 /* EditorOption.fixedOverflowWidgets */, 'fixedOverflowWidgets', false)),\n    folding: register(new EditorBooleanOption(43 /* EditorOption.folding */, 'folding', true, { description: nls.localize('folding', \"Controls whether the editor has code folding enabled.\") })),\n    foldingStrategy: register(new EditorStringEnumOption(44 /* EditorOption.foldingStrategy */, 'foldingStrategy', 'auto', ['auto', 'indentation'], {\n        enumDescriptions: [\n            nls.localize('foldingStrategy.auto', \"Use a language-specific folding strategy if available, else the indentation-based one.\"),\n            nls.localize('foldingStrategy.indentation', \"Use the indentation-based folding strategy.\"),\n        ],\n        description: nls.localize('foldingStrategy', \"Controls the strategy for computing folding ranges.\")\n    })),\n    foldingHighlight: register(new EditorBooleanOption(45 /* EditorOption.foldingHighlight */, 'foldingHighlight', true, { description: nls.localize('foldingHighlight', \"Controls whether the editor should highlight folded ranges.\") })),\n    foldingImportsByDefault: register(new EditorBooleanOption(46 /* EditorOption.foldingImportsByDefault */, 'foldingImportsByDefault', false, { description: nls.localize('foldingImportsByDefault', \"Controls whether the editor automatically collapses import ranges.\") })),\n    foldingMaximumRegions: register(new EditorIntOption(47 /* EditorOption.foldingMaximumRegions */, 'foldingMaximumRegions', 5000, 10, 65000, // limit must be less than foldingRanges MAX_FOLDING_REGIONS\n    { description: nls.localize('foldingMaximumRegions', \"The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.\") })),\n    unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(48 /* EditorOption.unfoldOnClickAfterEndOfLine */, 'unfoldOnClickAfterEndOfLine', false, { description: nls.localize('unfoldOnClickAfterEndOfLine', \"Controls whether clicking on the empty content after a folded line will unfold the line.\") })),\n    fontFamily: register(new EditorStringOption(49 /* EditorOption.fontFamily */, 'fontFamily', EDITOR_FONT_DEFAULTS.fontFamily, { description: nls.localize('fontFamily', \"Controls the font family.\") })),\n    fontInfo: register(new EditorFontInfo()),\n    fontLigatures2: register(new EditorFontLigatures()),\n    fontSize: register(new EditorFontSize()),\n    fontWeight: register(new EditorFontWeight()),\n    fontVariations: register(new EditorFontVariations()),\n    formatOnPaste: register(new EditorBooleanOption(55 /* EditorOption.formatOnPaste */, 'formatOnPaste', false, { description: nls.localize('formatOnPaste', \"Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.\") })),\n    formatOnType: register(new EditorBooleanOption(56 /* EditorOption.formatOnType */, 'formatOnType', false, { description: nls.localize('formatOnType', \"Controls whether the editor should automatically format the line after typing.\") })),\n    glyphMargin: register(new EditorBooleanOption(57 /* EditorOption.glyphMargin */, 'glyphMargin', true, { description: nls.localize('glyphMargin', \"Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.\") })),\n    gotoLocation: register(new EditorGoToLocation()),\n    hideCursorInOverviewRuler: register(new EditorBooleanOption(59 /* EditorOption.hideCursorInOverviewRuler */, 'hideCursorInOverviewRuler', false, { description: nls.localize('hideCursorInOverviewRuler', \"Controls whether the cursor should be hidden in the overview ruler.\") })),\n    hover: register(new EditorHover()),\n    inDiffEditor: register(new EditorBooleanOption(61 /* EditorOption.inDiffEditor */, 'inDiffEditor', false)),\n    letterSpacing: register(new EditorFloatOption(64 /* EditorOption.letterSpacing */, 'letterSpacing', EDITOR_FONT_DEFAULTS.letterSpacing, x => EditorFloatOption.clamp(x, -5, 20), { description: nls.localize('letterSpacing', \"Controls the letter spacing in pixels.\") })),\n    lightbulb: register(new EditorLightbulb()),\n    lineDecorationsWidth: register(new EditorLineDecorationsWidth()),\n    lineHeight: register(new EditorLineHeight()),\n    lineNumbers: register(new EditorRenderLineNumbersOption()),\n    lineNumbersMinChars: register(new EditorIntOption(69 /* EditorOption.lineNumbersMinChars */, 'lineNumbersMinChars', 5, 1, 300)),\n    linkedEditing: register(new EditorBooleanOption(70 /* EditorOption.linkedEditing */, 'linkedEditing', false, { description: nls.localize('linkedEditing', \"Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.\") })),\n    links: register(new EditorBooleanOption(71 /* EditorOption.links */, 'links', true, { description: nls.localize('links', \"Controls whether the editor should detect links and make them clickable.\") })),\n    matchBrackets: register(new EditorStringEnumOption(72 /* EditorOption.matchBrackets */, 'matchBrackets', 'always', ['always', 'near', 'never'], { description: nls.localize('matchBrackets', \"Highlight matching brackets.\") })),\n    minimap: register(new EditorMinimap()),\n    mouseStyle: register(new EditorStringEnumOption(74 /* EditorOption.mouseStyle */, 'mouseStyle', 'text', ['text', 'default', 'copy'])),\n    mouseWheelScrollSensitivity: register(new EditorFloatOption(75 /* EditorOption.mouseWheelScrollSensitivity */, 'mouseWheelScrollSensitivity', 1, x => (x === 0 ? 1 : x), { markdownDescription: nls.localize('mouseWheelScrollSensitivity', \"A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.\") })),\n    mouseWheelZoom: register(new EditorBooleanOption(76 /* EditorOption.mouseWheelZoom */, 'mouseWheelZoom', false, {\n        markdownDescription: platform.isMacintosh\n            ? nls.localize('mouseWheelZoom.mac', \"Zoom the font of the editor when using mouse wheel and holding `Cmd`.\")\n            : nls.localize('mouseWheelZoom', \"Zoom the font of the editor when using mouse wheel and holding `Ctrl`.\")\n    })),\n    multiCursorMergeOverlapping: register(new EditorBooleanOption(77 /* EditorOption.multiCursorMergeOverlapping */, 'multiCursorMergeOverlapping', true, { description: nls.localize('multiCursorMergeOverlapping', \"Merge multiple cursors when they are overlapping.\") })),\n    multiCursorModifier: register(new EditorEnumOption(78 /* EditorOption.multiCursorModifier */, 'multiCursorModifier', 'altKey', 'alt', ['ctrlCmd', 'alt'], _multiCursorModifierFromString, {\n        markdownEnumDescriptions: [\n            nls.localize('multiCursorModifier.ctrlCmd', \"Maps to `Control` on Windows and Linux and to `Command` on macOS.\"),\n            nls.localize('multiCursorModifier.alt', \"Maps to `Alt` on Windows and Linux and to `Option` on macOS.\")\n        ],\n        markdownDescription: nls.localize({\n            key: 'multiCursorModifier',\n            comment: [\n                '- `ctrlCmd` refers to a value the setting can take and should not be localized.',\n                '- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized.'\n            ]\n        }, \"The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).\")\n    })),\n    multiCursorPaste: register(new EditorStringEnumOption(79 /* EditorOption.multiCursorPaste */, 'multiCursorPaste', 'spread', ['spread', 'full'], {\n        markdownEnumDescriptions: [\n            nls.localize('multiCursorPaste.spread', \"Each cursor pastes a single line of the text.\"),\n            nls.localize('multiCursorPaste.full', \"Each cursor pastes the full text.\")\n        ],\n        markdownDescription: nls.localize('multiCursorPaste', \"Controls pasting when the line count of the pasted text matches the cursor count.\")\n    })),\n    multiCursorLimit: register(new EditorIntOption(80 /* EditorOption.multiCursorLimit */, 'multiCursorLimit', 10000, 1, 100000, {\n        markdownDescription: nls.localize('multiCursorLimit', \"Controls the max number of cursors that can be in an active editor at once.\")\n    })),\n    occurrencesHighlight: register(new EditorStringEnumOption(81 /* EditorOption.occurrencesHighlight */, 'occurrencesHighlight', 'singleFile', ['off', 'singleFile', 'multiFile'], {\n        markdownEnumDescriptions: [\n            nls.localize('occurrencesHighlight.off', \"Does not highlight occurrences.\"),\n            nls.localize('occurrencesHighlight.singleFile', \"Highlights occurrences only in the current file.\"),\n            nls.localize('occurrencesHighlight.multiFile', \"Experimental: Highlights occurrences across all valid open files.\")\n        ],\n        markdownDescription: nls.localize('occurrencesHighlight', \"Controls whether occurrences should be highlighted across open files.\")\n    })),\n    overviewRulerBorder: register(new EditorBooleanOption(82 /* EditorOption.overviewRulerBorder */, 'overviewRulerBorder', true, { description: nls.localize('overviewRulerBorder', \"Controls whether a border should be drawn around the overview ruler.\") })),\n    overviewRulerLanes: register(new EditorIntOption(83 /* EditorOption.overviewRulerLanes */, 'overviewRulerLanes', 3, 0, 3)),\n    padding: register(new EditorPadding()),\n    pasteAs: register(new EditorPasteAs()),\n    parameterHints: register(new EditorParameterHints()),\n    peekWidgetDefaultFocus: register(new EditorStringEnumOption(87 /* EditorOption.peekWidgetDefaultFocus */, 'peekWidgetDefaultFocus', 'tree', ['tree', 'editor'], {\n        enumDescriptions: [\n            nls.localize('peekWidgetDefaultFocus.tree', \"Focus the tree when opening peek\"),\n            nls.localize('peekWidgetDefaultFocus.editor', \"Focus the editor when opening peek\")\n        ],\n        description: nls.localize('peekWidgetDefaultFocus', \"Controls whether to focus the inline editor or the tree in the peek widget.\")\n    })),\n    placeholder: register(new PlaceholderOption()),\n    definitionLinkOpensInPeek: register(new EditorBooleanOption(89 /* EditorOption.definitionLinkOpensInPeek */, 'definitionLinkOpensInPeek', false, { description: nls.localize('definitionLinkOpensInPeek', \"Controls whether the Go to Definition mouse gesture always opens the peek widget.\") })),\n    quickSuggestions: register(new EditorQuickSuggestions()),\n    quickSuggestionsDelay: register(new EditorIntOption(91 /* EditorOption.quickSuggestionsDelay */, 'quickSuggestionsDelay', 10, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('quickSuggestionsDelay', \"Controls the delay in milliseconds after which quick suggestions will show up.\") })),\n    readOnly: register(new EditorBooleanOption(92 /* EditorOption.readOnly */, 'readOnly', false)),\n    readOnlyMessage: register(new ReadonlyMessage()),\n    renameOnType: register(new EditorBooleanOption(94 /* EditorOption.renameOnType */, 'renameOnType', false, { description: nls.localize('renameOnType', \"Controls whether the editor auto renames on type.\"), markdownDeprecationMessage: nls.localize('renameOnTypeDeprecate', \"Deprecated, use `editor.linkedEditing` instead.\") })),\n    renderControlCharacters: register(new EditorBooleanOption(95 /* EditorOption.renderControlCharacters */, 'renderControlCharacters', true, { description: nls.localize('renderControlCharacters', \"Controls whether the editor should render control characters.\"), restricted: true })),\n    renderFinalNewline: register(new EditorStringEnumOption(96 /* EditorOption.renderFinalNewline */, 'renderFinalNewline', (platform.isLinux ? 'dimmed' : 'on'), ['off', 'on', 'dimmed'], { description: nls.localize('renderFinalNewline', \"Render last line number when the file ends with a newline.\") })),\n    renderLineHighlight: register(new EditorStringEnumOption(97 /* EditorOption.renderLineHighlight */, 'renderLineHighlight', 'line', ['none', 'gutter', 'line', 'all'], {\n        enumDescriptions: [\n            '',\n            '',\n            '',\n            nls.localize('renderLineHighlight.all', \"Highlights both the gutter and the current line.\"),\n        ],\n        description: nls.localize('renderLineHighlight', \"Controls how the editor should render the current line highlight.\")\n    })),\n    renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(98 /* EditorOption.renderLineHighlightOnlyWhenFocus */, 'renderLineHighlightOnlyWhenFocus', false, { description: nls.localize('renderLineHighlightOnlyWhenFocus', \"Controls if the editor should render the current line highlight only when the editor is focused.\") })),\n    renderValidationDecorations: register(new EditorStringEnumOption(99 /* EditorOption.renderValidationDecorations */, 'renderValidationDecorations', 'editable', ['editable', 'on', 'off'])),\n    renderWhitespace: register(new EditorStringEnumOption(100 /* EditorOption.renderWhitespace */, 'renderWhitespace', 'selection', ['none', 'boundary', 'selection', 'trailing', 'all'], {\n        enumDescriptions: [\n            '',\n            nls.localize('renderWhitespace.boundary', \"Render whitespace characters except for single spaces between words.\"),\n            nls.localize('renderWhitespace.selection', \"Render whitespace characters only on selected text.\"),\n            nls.localize('renderWhitespace.trailing', \"Render only trailing whitespace characters.\"),\n            ''\n        ],\n        description: nls.localize('renderWhitespace', \"Controls how the editor should render whitespace characters.\")\n    })),\n    revealHorizontalRightPadding: register(new EditorIntOption(101 /* EditorOption.revealHorizontalRightPadding */, 'revealHorizontalRightPadding', 15, 0, 1000)),\n    roundedSelection: register(new EditorBooleanOption(102 /* EditorOption.roundedSelection */, 'roundedSelection', true, { description: nls.localize('roundedSelection', \"Controls whether selections should have rounded corners.\") })),\n    rulers: register(new EditorRulers()),\n    scrollbar: register(new EditorScrollbar()),\n    scrollBeyondLastColumn: register(new EditorIntOption(105 /* EditorOption.scrollBeyondLastColumn */, 'scrollBeyondLastColumn', 4, 0, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, { description: nls.localize('scrollBeyondLastColumn', \"Controls the number of extra characters beyond which the editor will scroll horizontally.\") })),\n    scrollBeyondLastLine: register(new EditorBooleanOption(106 /* EditorOption.scrollBeyondLastLine */, 'scrollBeyondLastLine', true, { description: nls.localize('scrollBeyondLastLine', \"Controls whether the editor will scroll beyond the last line.\") })),\n    scrollPredominantAxis: register(new EditorBooleanOption(107 /* EditorOption.scrollPredominantAxis */, 'scrollPredominantAxis', true, { description: nls.localize('scrollPredominantAxis', \"Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.\") })),\n    selectionClipboard: register(new EditorBooleanOption(108 /* EditorOption.selectionClipboard */, 'selectionClipboard', true, {\n        description: nls.localize('selectionClipboard', \"Controls whether the Linux primary clipboard should be supported.\"),\n        included: platform.isLinux\n    })),\n    selectionHighlight: register(new EditorBooleanOption(109 /* EditorOption.selectionHighlight */, 'selectionHighlight', true, { description: nls.localize('selectionHighlight', \"Controls whether the editor should highlight matches similar to the selection.\") })),\n    selectOnLineNumbers: register(new EditorBooleanOption(110 /* EditorOption.selectOnLineNumbers */, 'selectOnLineNumbers', true)),\n    showFoldingControls: register(new EditorStringEnumOption(111 /* EditorOption.showFoldingControls */, 'showFoldingControls', 'mouseover', ['always', 'never', 'mouseover'], {\n        enumDescriptions: [\n            nls.localize('showFoldingControls.always', \"Always show the folding controls.\"),\n            nls.localize('showFoldingControls.never', \"Never show the folding controls and reduce the gutter size.\"),\n            nls.localize('showFoldingControls.mouseover', \"Only show the folding controls when the mouse is over the gutter.\"),\n        ],\n        description: nls.localize('showFoldingControls', \"Controls when the folding controls on the gutter are shown.\")\n    })),\n    showUnused: register(new EditorBooleanOption(112 /* EditorOption.showUnused */, 'showUnused', true, { description: nls.localize('showUnused', \"Controls fading out of unused code.\") })),\n    showDeprecated: register(new EditorBooleanOption(141 /* EditorOption.showDeprecated */, 'showDeprecated', true, { description: nls.localize('showDeprecated', \"Controls strikethrough deprecated variables.\") })),\n    inlayHints: register(new EditorInlayHints()),\n    snippetSuggestions: register(new EditorStringEnumOption(113 /* EditorOption.snippetSuggestions */, 'snippetSuggestions', 'inline', ['top', 'bottom', 'inline', 'none'], {\n        enumDescriptions: [\n            nls.localize('snippetSuggestions.top', \"Show snippet suggestions on top of other suggestions.\"),\n            nls.localize('snippetSuggestions.bottom', \"Show snippet suggestions below other suggestions.\"),\n            nls.localize('snippetSuggestions.inline', \"Show snippets suggestions with other suggestions.\"),\n            nls.localize('snippetSuggestions.none', \"Do not show snippet suggestions.\"),\n        ],\n        description: nls.localize('snippetSuggestions', \"Controls whether snippets are shown with other suggestions and how they are sorted.\")\n    })),\n    smartSelect: register(new SmartSelect()),\n    smoothScrolling: register(new EditorBooleanOption(115 /* EditorOption.smoothScrolling */, 'smoothScrolling', false, { description: nls.localize('smoothScrolling', \"Controls whether the editor will scroll using an animation.\") })),\n    stopRenderingLineAfter: register(new EditorIntOption(118 /* EditorOption.stopRenderingLineAfter */, 'stopRenderingLineAfter', 10000, -1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */)),\n    suggest: register(new EditorSuggest()),\n    inlineSuggest: register(new InlineEditorSuggest()),\n    inlineEdit: register(new InlineEditorEdit()),\n    inlineCompletionsAccessibilityVerbose: register(new EditorBooleanOption(150 /* EditorOption.inlineCompletionsAccessibilityVerbose */, 'inlineCompletionsAccessibilityVerbose', false, { description: nls.localize('inlineCompletionsAccessibilityVerbose', \"Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.\") })),\n    suggestFontSize: register(new EditorIntOption(120 /* EditorOption.suggestFontSize */, 'suggestFontSize', 0, 0, 1000, { markdownDescription: nls.localize('suggestFontSize', \"Font size for the suggest widget. When set to {0}, the value of {1} is used.\", '`0`', '`#editor.fontSize#`') })),\n    suggestLineHeight: register(new EditorIntOption(121 /* EditorOption.suggestLineHeight */, 'suggestLineHeight', 0, 0, 1000, { markdownDescription: nls.localize('suggestLineHeight', \"Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.\", '`0`', '`#editor.lineHeight#`') })),\n    suggestOnTriggerCharacters: register(new EditorBooleanOption(122 /* EditorOption.suggestOnTriggerCharacters */, 'suggestOnTriggerCharacters', true, { description: nls.localize('suggestOnTriggerCharacters', \"Controls whether suggestions should automatically show up when typing trigger characters.\") })),\n    suggestSelection: register(new EditorStringEnumOption(123 /* EditorOption.suggestSelection */, 'suggestSelection', 'first', ['first', 'recentlyUsed', 'recentlyUsedByPrefix'], {\n        markdownEnumDescriptions: [\n            nls.localize('suggestSelection.first', \"Always select the first suggestion.\"),\n            nls.localize('suggestSelection.recentlyUsed', \"Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently.\"),\n            nls.localize('suggestSelection.recentlyUsedByPrefix', \"Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.\"),\n        ],\n        description: nls.localize('suggestSelection', \"Controls how suggestions are pre-selected when showing the suggest list.\")\n    })),\n    tabCompletion: register(new EditorStringEnumOption(124 /* EditorOption.tabCompletion */, 'tabCompletion', 'off', ['on', 'off', 'onlySnippets'], {\n        enumDescriptions: [\n            nls.localize('tabCompletion.on', \"Tab complete will insert the best matching suggestion when pressing tab.\"),\n            nls.localize('tabCompletion.off', \"Disable tab completions.\"),\n            nls.localize('tabCompletion.onlySnippets', \"Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.\"),\n        ],\n        description: nls.localize('tabCompletion', \"Enables tab completions.\")\n    })),\n    tabIndex: register(new EditorIntOption(125 /* EditorOption.tabIndex */, 'tabIndex', 0, -1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */)),\n    unicodeHighlight: register(new UnicodeHighlight()),\n    unusualLineTerminators: register(new EditorStringEnumOption(127 /* EditorOption.unusualLineTerminators */, 'unusualLineTerminators', 'prompt', ['auto', 'off', 'prompt'], {\n        enumDescriptions: [\n            nls.localize('unusualLineTerminators.auto', \"Unusual line terminators are automatically removed.\"),\n            nls.localize('unusualLineTerminators.off', \"Unusual line terminators are ignored.\"),\n            nls.localize('unusualLineTerminators.prompt', \"Unusual line terminators prompt to be removed.\"),\n        ],\n        description: nls.localize('unusualLineTerminators', \"Remove unusual line terminators that might cause problems.\")\n    })),\n    useShadowDOM: register(new EditorBooleanOption(128 /* EditorOption.useShadowDOM */, 'useShadowDOM', true)),\n    useTabStops: register(new EditorBooleanOption(129 /* EditorOption.useTabStops */, 'useTabStops', true, { description: nls.localize('useTabStops', \"Spaces and tabs are inserted and deleted in alignment with tab stops.\") })),\n    wordBreak: register(new EditorStringEnumOption(130 /* EditorOption.wordBreak */, 'wordBreak', 'normal', ['normal', 'keepAll'], {\n        markdownEnumDescriptions: [\n            nls.localize('wordBreak.normal', \"Use the default line break rule.\"),\n            nls.localize('wordBreak.keepAll', \"Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.\"),\n        ],\n        description: nls.localize('wordBreak', \"Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.\")\n    })),\n    wordSegmenterLocales: register(new WordSegmenterLocales()),\n    wordSeparators: register(new EditorStringOption(132 /* EditorOption.wordSeparators */, 'wordSeparators', USUAL_WORD_SEPARATORS, { description: nls.localize('wordSeparators', \"Characters that will be used as word separators when doing word related navigations or operations.\") })),\n    wordWrap: register(new EditorStringEnumOption(133 /* EditorOption.wordWrap */, 'wordWrap', 'off', ['off', 'on', 'wordWrapColumn', 'bounded'], {\n        markdownEnumDescriptions: [\n            nls.localize('wordWrap.off', \"Lines will never wrap.\"),\n            nls.localize('wordWrap.on', \"Lines will wrap at the viewport width.\"),\n            nls.localize({\n                key: 'wordWrap.wordWrapColumn',\n                comment: [\n                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n                ]\n            }, \"Lines will wrap at `#editor.wordWrapColumn#`.\"),\n            nls.localize({\n                key: 'wordWrap.bounded',\n                comment: [\n                    '- viewport means the edge of the visible window size.',\n                    '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n                ]\n            }, \"Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.\"),\n        ],\n        description: nls.localize({\n            key: 'wordWrap',\n            comment: [\n                '- \\'off\\', \\'on\\', \\'wordWrapColumn\\' and \\'bounded\\' refer to values the setting can take and should not be localized.',\n                '- `editor.wordWrapColumn` refers to a different setting and should not be localized.'\n            ]\n        }, \"Controls how lines should wrap.\")\n    })),\n    wordWrapBreakAfterCharacters: register(new EditorStringOption(134 /* EditorOption.wordWrapBreakAfterCharacters */, 'wordWrapBreakAfterCharacters', \n    // allow-any-unicode-next-line\n    ' \\t})]?|/&.,;')),\n    wordWrapBreakBeforeCharacters: register(new EditorStringOption(135 /* EditorOption.wordWrapBreakBeforeCharacters */, 'wordWrapBreakBeforeCharacters', \n    // allow-any-unicode-next-line\n    '([{+')),\n    wordWrapColumn: register(new EditorIntOption(136 /* EditorOption.wordWrapColumn */, 'wordWrapColumn', 80, 1, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, {\n        markdownDescription: nls.localize({\n            key: 'wordWrapColumn',\n            comment: [\n                '- `editor.wordWrap` refers to a different setting and should not be localized.',\n                '- \\'wordWrapColumn\\' and \\'bounded\\' refer to values the different setting can take and should not be localized.'\n            ]\n        }, \"Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.\")\n    })),\n    wordWrapOverride1: register(new EditorStringEnumOption(137 /* EditorOption.wordWrapOverride1 */, 'wordWrapOverride1', 'inherit', ['off', 'on', 'inherit'])),\n    wordWrapOverride2: register(new EditorStringEnumOption(138 /* EditorOption.wordWrapOverride2 */, 'wordWrapOverride2', 'inherit', ['off', 'on', 'inherit'])),\n    // Leave these at the end (because they have dependencies!)\n    editorClassName: register(new EditorClassName()),\n    defaultColorDecorators: register(new EditorBooleanOption(148 /* EditorOption.defaultColorDecorators */, 'defaultColorDecorators', false, { markdownDescription: nls.localize('defaultColorDecorators', \"Controls whether inline color decorations should be shown using the default document color provider\") })),\n    pixelRatio: register(new EditorPixelRatio()),\n    tabFocusMode: register(new EditorBooleanOption(145 /* EditorOption.tabFocusMode */, 'tabFocusMode', false, { markdownDescription: nls.localize('tabFocusMode', \"Controls whether the editor receives tabs or defers them to the workbench for navigation.\") })),\n    layoutInfo: register(new EditorLayoutInfoComputer()),\n    wrappingInfo: register(new EditorWrappingInfoComputer()),\n    wrappingIndent: register(new WrappingIndentOption()),\n    wrappingStrategy: register(new WrappingStrategy())\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n    toJSON() {\n        return {\n            lineNumber: this.lineNumber,\n            column: this.column\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../base/common/lifecycle.js';\nexport class TokenizationRegistry {\n    constructor() {\n        this._tokenizationSupports = new Map();\n        this._factories = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._colorMap = null;\n    }\n    handleChange(languageIds) {\n        this._onDidChange.fire({\n            changedLanguages: languageIds,\n            changedColorMap: false\n        });\n    }\n    register(languageId, support) {\n        this._tokenizationSupports.set(languageId, support);\n        this.handleChange([languageId]);\n        return toDisposable(() => {\n            if (this._tokenizationSupports.get(languageId) !== support) {\n                return;\n            }\n            this._tokenizationSupports.delete(languageId);\n            this.handleChange([languageId]);\n        });\n    }\n    get(languageId) {\n        return this._tokenizationSupports.get(languageId) || null;\n    }\n    registerFactory(languageId, factory) {\n        this._factories.get(languageId)?.dispose();\n        const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n        this._factories.set(languageId, myData);\n        return toDisposable(() => {\n            const v = this._factories.get(languageId);\n            if (!v || v !== myData) {\n                return;\n            }\n            this._factories.delete(languageId);\n            v.dispose();\n        });\n    }\n    async getOrCreate(languageId) {\n        // check first if the support is already set\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return tokenizationSupport;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            // no factory or factory.resolve already finished\n            return null;\n        }\n        await factory.resolve();\n        return this.get(languageId);\n    }\n    isResolved(languageId) {\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return true;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            return true;\n        }\n        return false;\n    }\n    setColorMap(colorMap) {\n        this._colorMap = colorMap;\n        this._onDidChange.fire({\n            changedLanguages: Array.from(this._tokenizationSupports.keys()),\n            changedColorMap: true\n        });\n    }\n    getColorMap() {\n        return this._colorMap;\n    }\n    getDefaultBackground() {\n        if (this._colorMap && this._colorMap.length > 2 /* ColorId.DefaultBackground */) {\n            return this._colorMap[2 /* ColorId.DefaultBackground */];\n        }\n        return null;\n    }\n}\nclass TokenizationSupportFactoryData extends Disposable {\n    get isResolved() {\n        return this._isResolved;\n    }\n    constructor(_registry, _languageId, _factory) {\n        super();\n        this._registry = _registry;\n        this._languageId = _languageId;\n        this._factory = _factory;\n        this._isDisposed = false;\n        this._resolvePromise = null;\n        this._isResolved = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    async resolve() {\n        if (!this._resolvePromise) {\n            this._resolvePromise = this._create();\n        }\n        return this._resolvePromise;\n    }\n    async _create() {\n        const value = await this._factory.tokenizationSupport;\n        this._isResolved = true;\n        if (value && !this._isDisposed) {\n            this._register(this._registry.register(this._languageId, value));\n        }\n    }\n}\n","import { Codicon } from '../../base/common/codicons.js';\nimport { URI } from '../../base/common/uri.js';\nimport { Range } from './core/range.js';\nimport { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';\nimport { localize } from '../../nls.js';\nexport class Token {\n    constructor(offset, type, language) {\n        this.offset = offset;\n        this.type = type;\n        this.language = language;\n        this._tokenBrand = undefined;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationResult {\n    constructor(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._tokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationResult {\n    constructor(\n    /**\n     * The tokens in binary format. Each token occupies two array indices. For token i:\n     *  - at offset 2*i => startIndex\n     *  - at offset 2*i + 1 => metadata\n     *\n     */\n    tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._encodedTokenizationResultBrand = undefined;\n    }\n}\nexport var HoverVerbosityAction;\n(function (HoverVerbosityAction) {\n    /**\n     * Increase the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\n    /**\n     * Decrease the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\n})(HoverVerbosityAction || (HoverVerbosityAction = {}));\n/**\n * @internal\n */\nexport var CompletionItemKinds;\n(function (CompletionItemKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* CompletionItemKind.Method */, Codicon.symbolMethod);\n    byKind.set(1 /* CompletionItemKind.Function */, Codicon.symbolFunction);\n    byKind.set(2 /* CompletionItemKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(3 /* CompletionItemKind.Field */, Codicon.symbolField);\n    byKind.set(4 /* CompletionItemKind.Variable */, Codicon.symbolVariable);\n    byKind.set(5 /* CompletionItemKind.Class */, Codicon.symbolClass);\n    byKind.set(6 /* CompletionItemKind.Struct */, Codicon.symbolStruct);\n    byKind.set(7 /* CompletionItemKind.Interface */, Codicon.symbolInterface);\n    byKind.set(8 /* CompletionItemKind.Module */, Codicon.symbolModule);\n    byKind.set(9 /* CompletionItemKind.Property */, Codicon.symbolProperty);\n    byKind.set(10 /* CompletionItemKind.Event */, Codicon.symbolEvent);\n    byKind.set(11 /* CompletionItemKind.Operator */, Codicon.symbolOperator);\n    byKind.set(12 /* CompletionItemKind.Unit */, Codicon.symbolUnit);\n    byKind.set(13 /* CompletionItemKind.Value */, Codicon.symbolValue);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(14 /* CompletionItemKind.Constant */, Codicon.symbolConstant);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(16 /* CompletionItemKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(17 /* CompletionItemKind.Keyword */, Codicon.symbolKeyword);\n    byKind.set(27 /* CompletionItemKind.Snippet */, Codicon.symbolSnippet);\n    byKind.set(18 /* CompletionItemKind.Text */, Codicon.symbolText);\n    byKind.set(19 /* CompletionItemKind.Color */, Codicon.symbolColor);\n    byKind.set(20 /* CompletionItemKind.File */, Codicon.symbolFile);\n    byKind.set(21 /* CompletionItemKind.Reference */, Codicon.symbolReference);\n    byKind.set(22 /* CompletionItemKind.Customcolor */, Codicon.symbolCustomColor);\n    byKind.set(23 /* CompletionItemKind.Folder */, Codicon.symbolFolder);\n    byKind.set(24 /* CompletionItemKind.TypeParameter */, Codicon.symbolTypeParameter);\n    byKind.set(25 /* CompletionItemKind.User */, Codicon.account);\n    byKind.set(26 /* CompletionItemKind.Issue */, Codicon.issues);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let codicon = byKind.get(kind);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon;\n    }\n    CompletionItemKinds.toIcon = toIcon;\n    const data = new Map();\n    data.set('method', 0 /* CompletionItemKind.Method */);\n    data.set('function', 1 /* CompletionItemKind.Function */);\n    data.set('constructor', 2 /* CompletionItemKind.Constructor */);\n    data.set('field', 3 /* CompletionItemKind.Field */);\n    data.set('variable', 4 /* CompletionItemKind.Variable */);\n    data.set('class', 5 /* CompletionItemKind.Class */);\n    data.set('struct', 6 /* CompletionItemKind.Struct */);\n    data.set('interface', 7 /* CompletionItemKind.Interface */);\n    data.set('module', 8 /* CompletionItemKind.Module */);\n    data.set('property', 9 /* CompletionItemKind.Property */);\n    data.set('event', 10 /* CompletionItemKind.Event */);\n    data.set('operator', 11 /* CompletionItemKind.Operator */);\n    data.set('unit', 12 /* CompletionItemKind.Unit */);\n    data.set('value', 13 /* CompletionItemKind.Value */);\n    data.set('constant', 14 /* CompletionItemKind.Constant */);\n    data.set('enum', 15 /* CompletionItemKind.Enum */);\n    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);\n    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);\n    data.set('keyword', 17 /* CompletionItemKind.Keyword */);\n    data.set('snippet', 27 /* CompletionItemKind.Snippet */);\n    data.set('text', 18 /* CompletionItemKind.Text */);\n    data.set('color', 19 /* CompletionItemKind.Color */);\n    data.set('file', 20 /* CompletionItemKind.File */);\n    data.set('reference', 21 /* CompletionItemKind.Reference */);\n    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);\n    data.set('folder', 23 /* CompletionItemKind.Folder */);\n    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('account', 25 /* CompletionItemKind.User */);\n    data.set('issue', 26 /* CompletionItemKind.Issue */);\n    /**\n     * @internal\n     */\n    function fromString(value, strict) {\n        let res = data.get(value);\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* CompletionItemKind.Property */;\n        }\n        return res;\n    }\n    CompletionItemKinds.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport class SelectedSuggestionInfo {\n    constructor(range, text, completionKind, isSnippetText) {\n        this.range = range;\n        this.text = text;\n        this.completionKind = completionKind;\n        this.isSnippetText = isSnippetText;\n    }\n    equals(other) {\n        return Range.lift(this.range).equalsRange(other.range)\n            && this.text === other.text\n            && this.completionKind === other.completionKind\n            && this.isSnippetText === other.isSnippetText;\n    }\n}\n/**\n * @internal\n */\nexport var DocumentPasteTriggerKind;\n(function (DocumentPasteTriggerKind) {\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"PasteAs\"] = 1] = \"PasteAs\";\n})(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nexport function isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nexport const symbolKindNames = {\n    [17 /* SymbolKind.Array */]: localize('Array', \"array\"),\n    [16 /* SymbolKind.Boolean */]: localize('Boolean', \"boolean\"),\n    [4 /* SymbolKind.Class */]: localize('Class', \"class\"),\n    [13 /* SymbolKind.Constant */]: localize('Constant', \"constant\"),\n    [8 /* SymbolKind.Constructor */]: localize('Constructor', \"constructor\"),\n    [9 /* SymbolKind.Enum */]: localize('Enum', \"enumeration\"),\n    [21 /* SymbolKind.EnumMember */]: localize('EnumMember', \"enumeration member\"),\n    [23 /* SymbolKind.Event */]: localize('Event', \"event\"),\n    [7 /* SymbolKind.Field */]: localize('Field', \"field\"),\n    [0 /* SymbolKind.File */]: localize('File', \"file\"),\n    [11 /* SymbolKind.Function */]: localize('Function', \"function\"),\n    [10 /* SymbolKind.Interface */]: localize('Interface', \"interface\"),\n    [19 /* SymbolKind.Key */]: localize('Key', \"key\"),\n    [5 /* SymbolKind.Method */]: localize('Method', \"method\"),\n    [1 /* SymbolKind.Module */]: localize('Module', \"module\"),\n    [2 /* SymbolKind.Namespace */]: localize('Namespace', \"namespace\"),\n    [20 /* SymbolKind.Null */]: localize('Null', \"null\"),\n    [15 /* SymbolKind.Number */]: localize('Number', \"number\"),\n    [18 /* SymbolKind.Object */]: localize('Object', \"object\"),\n    [24 /* SymbolKind.Operator */]: localize('Operator', \"operator\"),\n    [3 /* SymbolKind.Package */]: localize('Package', \"package\"),\n    [6 /* SymbolKind.Property */]: localize('Property', \"property\"),\n    [14 /* SymbolKind.String */]: localize('String', \"string\"),\n    [22 /* SymbolKind.Struct */]: localize('Struct', \"struct\"),\n    [25 /* SymbolKind.TypeParameter */]: localize('TypeParameter', \"type parameter\"),\n    [12 /* SymbolKind.Variable */]: localize('Variable', \"variable\"),\n};\n/**\n * @internal\n */\nexport function getAriaLabelForSymbol(symbolName, kind) {\n    return localize('symbolAriaLabel', '{0} ({1})', symbolName, symbolKindNames[kind]);\n}\n/**\n * @internal\n */\nexport var SymbolKinds;\n(function (SymbolKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* SymbolKind.File */, Codicon.symbolFile);\n    byKind.set(1 /* SymbolKind.Module */, Codicon.symbolModule);\n    byKind.set(2 /* SymbolKind.Namespace */, Codicon.symbolNamespace);\n    byKind.set(3 /* SymbolKind.Package */, Codicon.symbolPackage);\n    byKind.set(4 /* SymbolKind.Class */, Codicon.symbolClass);\n    byKind.set(5 /* SymbolKind.Method */, Codicon.symbolMethod);\n    byKind.set(6 /* SymbolKind.Property */, Codicon.symbolProperty);\n    byKind.set(7 /* SymbolKind.Field */, Codicon.symbolField);\n    byKind.set(8 /* SymbolKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(9 /* SymbolKind.Enum */, Codicon.symbolEnum);\n    byKind.set(10 /* SymbolKind.Interface */, Codicon.symbolInterface);\n    byKind.set(11 /* SymbolKind.Function */, Codicon.symbolFunction);\n    byKind.set(12 /* SymbolKind.Variable */, Codicon.symbolVariable);\n    byKind.set(13 /* SymbolKind.Constant */, Codicon.symbolConstant);\n    byKind.set(14 /* SymbolKind.String */, Codicon.symbolString);\n    byKind.set(15 /* SymbolKind.Number */, Codicon.symbolNumber);\n    byKind.set(16 /* SymbolKind.Boolean */, Codicon.symbolBoolean);\n    byKind.set(17 /* SymbolKind.Array */, Codicon.symbolArray);\n    byKind.set(18 /* SymbolKind.Object */, Codicon.symbolObject);\n    byKind.set(19 /* SymbolKind.Key */, Codicon.symbolKey);\n    byKind.set(20 /* SymbolKind.Null */, Codicon.symbolNull);\n    byKind.set(21 /* SymbolKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(22 /* SymbolKind.Struct */, Codicon.symbolStruct);\n    byKind.set(23 /* SymbolKind.Event */, Codicon.symbolEvent);\n    byKind.set(24 /* SymbolKind.Operator */, Codicon.symbolOperator);\n    byKind.set(25 /* SymbolKind.TypeParameter */, Codicon.symbolTypeParameter);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let icon = byKind.get(kind);\n        if (!icon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            icon = Codicon.symbolProperty;\n        }\n        return icon;\n    }\n    SymbolKinds.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\n/** @internal */\nexport class TextEdit {\n}\nexport class FoldingRangeKind {\n    /**\n     * Kind for folding range representing a comment. The value of the kind is 'comment'.\n     */\n    static { this.Comment = new FoldingRangeKind('comment'); }\n    /**\n     * Kind for folding range representing a import. The value of the kind is 'imports'.\n     */\n    static { this.Imports = new FoldingRangeKind('imports'); }\n    /**\n     * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n     * The value of the kind is 'region'.\n     */\n    static { this.Region = new FoldingRangeKind('region'); }\n    /**\n     * Returns a {@link FoldingRangeKind} for the given value.\n     *\n     * @param value of the kind.\n     */\n    static fromValue(value) {\n        switch (value) {\n            case 'comment': return FoldingRangeKind.Comment;\n            case 'imports': return FoldingRangeKind.Imports;\n            case 'region': return FoldingRangeKind.Region;\n        }\n        return new FoldingRangeKind(value);\n    }\n    /**\n     * Creates a new {@link FoldingRangeKind}.\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\nexport var NewSymbolNameTag;\n(function (NewSymbolNameTag) {\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(NewSymbolNameTag || (NewSymbolNameTag = {}));\nexport var NewSymbolNameTriggerKind;\n(function (NewSymbolNameTriggerKind) {\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));\n/**\n * @internal\n */\nexport var Command;\n(function (Command) {\n    /**\n     * @internal\n     */\n    function is(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return false;\n        }\n        return typeof obj.id === 'string' &&\n            typeof obj.title === 'string';\n    }\n    Command.is = is;\n})(Command || (Command = {}));\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n/**\n * @internal\n */\nexport class LazyTokenizationSupport {\n    constructor(createSupport) {\n        this.createSupport = createSupport;\n        this._tokenizationSupport = null;\n    }\n    dispose() {\n        if (this._tokenizationSupport) {\n            this._tokenizationSupport.then((support) => {\n                if (support) {\n                    support.dispose();\n                }\n            });\n        }\n    }\n    get tokenizationSupport() {\n        if (!this._tokenizationSupport) {\n            this._tokenizationSupport = this.createSupport();\n        }\n        return this._tokenizationSupport;\n    }\n}\n/**\n * @internal\n */\nexport const TokenizationRegistry = new TokenizationRegistryImpl();\n/**\n * @internal\n */\nexport const TreeSitterTokenizationRegistry = new TokenizationRegistryImpl();\nexport var InlineEditTriggerKind;\n(function (InlineEditTriggerKind) {\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.\nexport var AccessibilitySupport;\n(function (AccessibilitySupport) {\n    /**\n     * This should be the browser case where it is not known if a screen reader is attached or no.\n     */\n    AccessibilitySupport[AccessibilitySupport[\"Unknown\"] = 0] = \"Unknown\";\n    AccessibilitySupport[AccessibilitySupport[\"Disabled\"] = 1] = \"Disabled\";\n    AccessibilitySupport[AccessibilitySupport[\"Enabled\"] = 2] = \"Enabled\";\n})(AccessibilitySupport || (AccessibilitySupport = {}));\nexport var CodeActionTriggerType;\n(function (CodeActionTriggerType) {\n    CodeActionTriggerType[CodeActionTriggerType[\"Invoke\"] = 1] = \"Invoke\";\n    CodeActionTriggerType[CodeActionTriggerType[\"Auto\"] = 2] = \"Auto\";\n})(CodeActionTriggerType || (CodeActionTriggerType = {}));\nexport var CompletionItemInsertTextRule;\n(function (CompletionItemInsertTextRule) {\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"None\"] = 0] = \"None\";\n    /**\n     * Adjust whitespace/indentation of multiline insert texts to\n     * match the current line indentation.\n     */\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"KeepWhitespace\"] = 1] = \"KeepWhitespace\";\n    /**\n     * `insertText` is a snippet.\n     */\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"InsertAsSnippet\"] = 4] = \"InsertAsSnippet\";\n})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind[CompletionItemKind[\"Method\"] = 0] = \"Method\";\n    CompletionItemKind[CompletionItemKind[\"Function\"] = 1] = \"Function\";\n    CompletionItemKind[CompletionItemKind[\"Constructor\"] = 2] = \"Constructor\";\n    CompletionItemKind[CompletionItemKind[\"Field\"] = 3] = \"Field\";\n    CompletionItemKind[CompletionItemKind[\"Variable\"] = 4] = \"Variable\";\n    CompletionItemKind[CompletionItemKind[\"Class\"] = 5] = \"Class\";\n    CompletionItemKind[CompletionItemKind[\"Struct\"] = 6] = \"Struct\";\n    CompletionItemKind[CompletionItemKind[\"Interface\"] = 7] = \"Interface\";\n    CompletionItemKind[CompletionItemKind[\"Module\"] = 8] = \"Module\";\n    CompletionItemKind[CompletionItemKind[\"Property\"] = 9] = \"Property\";\n    CompletionItemKind[CompletionItemKind[\"Event\"] = 10] = \"Event\";\n    CompletionItemKind[CompletionItemKind[\"Operator\"] = 11] = \"Operator\";\n    CompletionItemKind[CompletionItemKind[\"Unit\"] = 12] = \"Unit\";\n    CompletionItemKind[CompletionItemKind[\"Value\"] = 13] = \"Value\";\n    CompletionItemKind[CompletionItemKind[\"Constant\"] = 14] = \"Constant\";\n    CompletionItemKind[CompletionItemKind[\"Enum\"] = 15] = \"Enum\";\n    CompletionItemKind[CompletionItemKind[\"EnumMember\"] = 16] = \"EnumMember\";\n    CompletionItemKind[CompletionItemKind[\"Keyword\"] = 17] = \"Keyword\";\n    CompletionItemKind[CompletionItemKind[\"Text\"] = 18] = \"Text\";\n    CompletionItemKind[CompletionItemKind[\"Color\"] = 19] = \"Color\";\n    CompletionItemKind[CompletionItemKind[\"File\"] = 20] = \"File\";\n    CompletionItemKind[CompletionItemKind[\"Reference\"] = 21] = \"Reference\";\n    CompletionItemKind[CompletionItemKind[\"Customcolor\"] = 22] = \"Customcolor\";\n    CompletionItemKind[CompletionItemKind[\"Folder\"] = 23] = \"Folder\";\n    CompletionItemKind[CompletionItemKind[\"TypeParameter\"] = 24] = \"TypeParameter\";\n    CompletionItemKind[CompletionItemKind[\"User\"] = 25] = \"User\";\n    CompletionItemKind[CompletionItemKind[\"Issue\"] = 26] = \"Issue\";\n    CompletionItemKind[CompletionItemKind[\"Snippet\"] = 27] = \"Snippet\";\n})(CompletionItemKind || (CompletionItemKind = {}));\nexport var CompletionItemTag;\n(function (CompletionItemTag) {\n    CompletionItemTag[CompletionItemTag[\"Deprecated\"] = 1] = \"Deprecated\";\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * How a suggest provider was triggered.\n */\nexport var CompletionTriggerKind;\n(function (CompletionTriggerKind) {\n    CompletionTriggerKind[CompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\n})(CompletionTriggerKind || (CompletionTriggerKind = {}));\n/**\n * A positioning preference for rendering content widgets.\n */\nexport var ContentWidgetPositionPreference;\n(function (ContentWidgetPositionPreference) {\n    /**\n     * Place the content widget exactly at a position\n     */\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"EXACT\"] = 0] = \"EXACT\";\n    /**\n     * Place the content widget above a position\n     */\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"ABOVE\"] = 1] = \"ABOVE\";\n    /**\n     * Place the content widget below a position\n     */\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"BELOW\"] = 2] = \"BELOW\";\n})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));\n/**\n * Describes the reason the cursor has changed its position.\n */\nexport var CursorChangeReason;\n(function (CursorChangeReason) {\n    /**\n     * Unknown or not set.\n     */\n    CursorChangeReason[CursorChangeReason[\"NotSet\"] = 0] = \"NotSet\";\n    /**\n     * A `model.setValue()` was called.\n     */\n    CursorChangeReason[CursorChangeReason[\"ContentFlush\"] = 1] = \"ContentFlush\";\n    /**\n     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.\n     */\n    CursorChangeReason[CursorChangeReason[\"RecoverFromMarkers\"] = 2] = \"RecoverFromMarkers\";\n    /**\n     * There was an explicit user gesture.\n     */\n    CursorChangeReason[CursorChangeReason[\"Explicit\"] = 3] = \"Explicit\";\n    /**\n     * There was a Paste.\n     */\n    CursorChangeReason[CursorChangeReason[\"Paste\"] = 4] = \"Paste\";\n    /**\n     * There was an Undo.\n     */\n    CursorChangeReason[CursorChangeReason[\"Undo\"] = 5] = \"Undo\";\n    /**\n     * There was a Redo.\n     */\n    CursorChangeReason[CursorChangeReason[\"Redo\"] = 6] = \"Redo\";\n})(CursorChangeReason || (CursorChangeReason = {}));\n/**\n * The default end of line to use when instantiating models.\n */\nexport var DefaultEndOfLine;\n(function (DefaultEndOfLine) {\n    /**\n     * Use line feed (\\n) as the end of line character.\n     */\n    DefaultEndOfLine[DefaultEndOfLine[\"LF\"] = 1] = \"LF\";\n    /**\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\n     */\n    DefaultEndOfLine[DefaultEndOfLine[\"CRLF\"] = 2] = \"CRLF\";\n})(DefaultEndOfLine || (DefaultEndOfLine = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * Configuration options for auto indentation in the editor\n */\nexport var EditorAutoIndentStrategy;\n(function (EditorAutoIndentStrategy) {\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"None\"] = 0] = \"None\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Keep\"] = 1] = \"Keep\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Brackets\"] = 2] = \"Brackets\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Advanced\"] = 3] = \"Advanced\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Full\"] = 4] = \"Full\";\n})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));\nexport var EditorOption;\n(function (EditorOption) {\n    EditorOption[EditorOption[\"acceptSuggestionOnCommitCharacter\"] = 0] = \"acceptSuggestionOnCommitCharacter\";\n    EditorOption[EditorOption[\"acceptSuggestionOnEnter\"] = 1] = \"acceptSuggestionOnEnter\";\n    EditorOption[EditorOption[\"accessibilitySupport\"] = 2] = \"accessibilitySupport\";\n    EditorOption[EditorOption[\"accessibilityPageSize\"] = 3] = \"accessibilityPageSize\";\n    EditorOption[EditorOption[\"ariaLabel\"] = 4] = \"ariaLabel\";\n    EditorOption[EditorOption[\"ariaRequired\"] = 5] = \"ariaRequired\";\n    EditorOption[EditorOption[\"autoClosingBrackets\"] = 6] = \"autoClosingBrackets\";\n    EditorOption[EditorOption[\"autoClosingComments\"] = 7] = \"autoClosingComments\";\n    EditorOption[EditorOption[\"screenReaderAnnounceInlineSuggestion\"] = 8] = \"screenReaderAnnounceInlineSuggestion\";\n    EditorOption[EditorOption[\"autoClosingDelete\"] = 9] = \"autoClosingDelete\";\n    EditorOption[EditorOption[\"autoClosingOvertype\"] = 10] = \"autoClosingOvertype\";\n    EditorOption[EditorOption[\"autoClosingQuotes\"] = 11] = \"autoClosingQuotes\";\n    EditorOption[EditorOption[\"autoIndent\"] = 12] = \"autoIndent\";\n    EditorOption[EditorOption[\"automaticLayout\"] = 13] = \"automaticLayout\";\n    EditorOption[EditorOption[\"autoSurround\"] = 14] = \"autoSurround\";\n    EditorOption[EditorOption[\"bracketPairColorization\"] = 15] = \"bracketPairColorization\";\n    EditorOption[EditorOption[\"guides\"] = 16] = \"guides\";\n    EditorOption[EditorOption[\"codeLens\"] = 17] = \"codeLens\";\n    EditorOption[EditorOption[\"codeLensFontFamily\"] = 18] = \"codeLensFontFamily\";\n    EditorOption[EditorOption[\"codeLensFontSize\"] = 19] = \"codeLensFontSize\";\n    EditorOption[EditorOption[\"colorDecorators\"] = 20] = \"colorDecorators\";\n    EditorOption[EditorOption[\"colorDecoratorsLimit\"] = 21] = \"colorDecoratorsLimit\";\n    EditorOption[EditorOption[\"columnSelection\"] = 22] = \"columnSelection\";\n    EditorOption[EditorOption[\"comments\"] = 23] = \"comments\";\n    EditorOption[EditorOption[\"contextmenu\"] = 24] = \"contextmenu\";\n    EditorOption[EditorOption[\"copyWithSyntaxHighlighting\"] = 25] = \"copyWithSyntaxHighlighting\";\n    EditorOption[EditorOption[\"cursorBlinking\"] = 26] = \"cursorBlinking\";\n    EditorOption[EditorOption[\"cursorSmoothCaretAnimation\"] = 27] = \"cursorSmoothCaretAnimation\";\n    EditorOption[EditorOption[\"cursorStyle\"] = 28] = \"cursorStyle\";\n    EditorOption[EditorOption[\"cursorSurroundingLines\"] = 29] = \"cursorSurroundingLines\";\n    EditorOption[EditorOption[\"cursorSurroundingLinesStyle\"] = 30] = \"cursorSurroundingLinesStyle\";\n    EditorOption[EditorOption[\"cursorWidth\"] = 31] = \"cursorWidth\";\n    EditorOption[EditorOption[\"disableLayerHinting\"] = 32] = \"disableLayerHinting\";\n    EditorOption[EditorOption[\"disableMonospaceOptimizations\"] = 33] = \"disableMonospaceOptimizations\";\n    EditorOption[EditorOption[\"domReadOnly\"] = 34] = \"domReadOnly\";\n    EditorOption[EditorOption[\"dragAndDrop\"] = 35] = \"dragAndDrop\";\n    EditorOption[EditorOption[\"dropIntoEditor\"] = 36] = \"dropIntoEditor\";\n    EditorOption[EditorOption[\"emptySelectionClipboard\"] = 37] = \"emptySelectionClipboard\";\n    EditorOption[EditorOption[\"experimentalWhitespaceRendering\"] = 38] = \"experimentalWhitespaceRendering\";\n    EditorOption[EditorOption[\"extraEditorClassName\"] = 39] = \"extraEditorClassName\";\n    EditorOption[EditorOption[\"fastScrollSensitivity\"] = 40] = \"fastScrollSensitivity\";\n    EditorOption[EditorOption[\"find\"] = 41] = \"find\";\n    EditorOption[EditorOption[\"fixedOverflowWidgets\"] = 42] = \"fixedOverflowWidgets\";\n    EditorOption[EditorOption[\"folding\"] = 43] = \"folding\";\n    EditorOption[EditorOption[\"foldingStrategy\"] = 44] = \"foldingStrategy\";\n    EditorOption[EditorOption[\"foldingHighlight\"] = 45] = \"foldingHighlight\";\n    EditorOption[EditorOption[\"foldingImportsByDefault\"] = 46] = \"foldingImportsByDefault\";\n    EditorOption[EditorOption[\"foldingMaximumRegions\"] = 47] = \"foldingMaximumRegions\";\n    EditorOption[EditorOption[\"unfoldOnClickAfterEndOfLine\"] = 48] = \"unfoldOnClickAfterEndOfLine\";\n    EditorOption[EditorOption[\"fontFamily\"] = 49] = \"fontFamily\";\n    EditorOption[EditorOption[\"fontInfo\"] = 50] = \"fontInfo\";\n    EditorOption[EditorOption[\"fontLigatures\"] = 51] = \"fontLigatures\";\n    EditorOption[EditorOption[\"fontSize\"] = 52] = \"fontSize\";\n    EditorOption[EditorOption[\"fontWeight\"] = 53] = \"fontWeight\";\n    EditorOption[EditorOption[\"fontVariations\"] = 54] = \"fontVariations\";\n    EditorOption[EditorOption[\"formatOnPaste\"] = 55] = \"formatOnPaste\";\n    EditorOption[EditorOption[\"formatOnType\"] = 56] = \"formatOnType\";\n    EditorOption[EditorOption[\"glyphMargin\"] = 57] = \"glyphMargin\";\n    EditorOption[EditorOption[\"gotoLocation\"] = 58] = \"gotoLocation\";\n    EditorOption[EditorOption[\"hideCursorInOverviewRuler\"] = 59] = \"hideCursorInOverviewRuler\";\n    EditorOption[EditorOption[\"hover\"] = 60] = \"hover\";\n    EditorOption[EditorOption[\"inDiffEditor\"] = 61] = \"inDiffEditor\";\n    EditorOption[EditorOption[\"inlineSuggest\"] = 62] = \"inlineSuggest\";\n    EditorOption[EditorOption[\"inlineEdit\"] = 63] = \"inlineEdit\";\n    EditorOption[EditorOption[\"letterSpacing\"] = 64] = \"letterSpacing\";\n    EditorOption[EditorOption[\"lightbulb\"] = 65] = \"lightbulb\";\n    EditorOption[EditorOption[\"lineDecorationsWidth\"] = 66] = \"lineDecorationsWidth\";\n    EditorOption[EditorOption[\"lineHeight\"] = 67] = \"lineHeight\";\n    EditorOption[EditorOption[\"lineNumbers\"] = 68] = \"lineNumbers\";\n    EditorOption[EditorOption[\"lineNumbersMinChars\"] = 69] = \"lineNumbersMinChars\";\n    EditorOption[EditorOption[\"linkedEditing\"] = 70] = \"linkedEditing\";\n    EditorOption[EditorOption[\"links\"] = 71] = \"links\";\n    EditorOption[EditorOption[\"matchBrackets\"] = 72] = \"matchBrackets\";\n    EditorOption[EditorOption[\"minimap\"] = 73] = \"minimap\";\n    EditorOption[EditorOption[\"mouseStyle\"] = 74] = \"mouseStyle\";\n    EditorOption[EditorOption[\"mouseWheelScrollSensitivity\"] = 75] = \"mouseWheelScrollSensitivity\";\n    EditorOption[EditorOption[\"mouseWheelZoom\"] = 76] = \"mouseWheelZoom\";\n    EditorOption[EditorOption[\"multiCursorMergeOverlapping\"] = 77] = \"multiCursorMergeOverlapping\";\n    EditorOption[EditorOption[\"multiCursorModifier\"] = 78] = \"multiCursorModifier\";\n    EditorOption[EditorOption[\"multiCursorPaste\"] = 79] = \"multiCursorPaste\";\n    EditorOption[EditorOption[\"multiCursorLimit\"] = 80] = \"multiCursorLimit\";\n    EditorOption[EditorOption[\"occurrencesHighlight\"] = 81] = \"occurrencesHighlight\";\n    EditorOption[EditorOption[\"overviewRulerBorder\"] = 82] = \"overviewRulerBorder\";\n    EditorOption[EditorOption[\"overviewRulerLanes\"] = 83] = \"overviewRulerLanes\";\n    EditorOption[EditorOption[\"padding\"] = 84] = \"padding\";\n    EditorOption[EditorOption[\"pasteAs\"] = 85] = \"pasteAs\";\n    EditorOption[EditorOption[\"parameterHints\"] = 86] = \"parameterHints\";\n    EditorOption[EditorOption[\"peekWidgetDefaultFocus\"] = 87] = \"peekWidgetDefaultFocus\";\n    EditorOption[EditorOption[\"placeholder\"] = 88] = \"placeholder\";\n    EditorOption[EditorOption[\"definitionLinkOpensInPeek\"] = 89] = \"definitionLinkOpensInPeek\";\n    EditorOption[EditorOption[\"quickSuggestions\"] = 90] = \"quickSuggestions\";\n    EditorOption[EditorOption[\"quickSuggestionsDelay\"] = 91] = \"quickSuggestionsDelay\";\n    EditorOption[EditorOption[\"readOnly\"] = 92] = \"readOnly\";\n    EditorOption[EditorOption[\"readOnlyMessage\"] = 93] = \"readOnlyMessage\";\n    EditorOption[EditorOption[\"renameOnType\"] = 94] = \"renameOnType\";\n    EditorOption[EditorOption[\"renderControlCharacters\"] = 95] = \"renderControlCharacters\";\n    EditorOption[EditorOption[\"renderFinalNewline\"] = 96] = \"renderFinalNewline\";\n    EditorOption[EditorOption[\"renderLineHighlight\"] = 97] = \"renderLineHighlight\";\n    EditorOption[EditorOption[\"renderLineHighlightOnlyWhenFocus\"] = 98] = \"renderLineHighlightOnlyWhenFocus\";\n    EditorOption[EditorOption[\"renderValidationDecorations\"] = 99] = \"renderValidationDecorations\";\n    EditorOption[EditorOption[\"renderWhitespace\"] = 100] = \"renderWhitespace\";\n    EditorOption[EditorOption[\"revealHorizontalRightPadding\"] = 101] = \"revealHorizontalRightPadding\";\n    EditorOption[EditorOption[\"roundedSelection\"] = 102] = \"roundedSelection\";\n    EditorOption[EditorOption[\"rulers\"] = 103] = \"rulers\";\n    EditorOption[EditorOption[\"scrollbar\"] = 104] = \"scrollbar\";\n    EditorOption[EditorOption[\"scrollBeyondLastColumn\"] = 105] = \"scrollBeyondLastColumn\";\n    EditorOption[EditorOption[\"scrollBeyondLastLine\"] = 106] = \"scrollBeyondLastLine\";\n    EditorOption[EditorOption[\"scrollPredominantAxis\"] = 107] = \"scrollPredominantAxis\";\n    EditorOption[EditorOption[\"selectionClipboard\"] = 108] = \"selectionClipboard\";\n    EditorOption[EditorOption[\"selectionHighlight\"] = 109] = \"selectionHighlight\";\n    EditorOption[EditorOption[\"selectOnLineNumbers\"] = 110] = \"selectOnLineNumbers\";\n    EditorOption[EditorOption[\"showFoldingControls\"] = 111] = \"showFoldingControls\";\n    EditorOption[EditorOption[\"showUnused\"] = 112] = \"showUnused\";\n    EditorOption[EditorOption[\"snippetSuggestions\"] = 113] = \"snippetSuggestions\";\n    EditorOption[EditorOption[\"smartSelect\"] = 114] = \"smartSelect\";\n    EditorOption[EditorOption[\"smoothScrolling\"] = 115] = \"smoothScrolling\";\n    EditorOption[EditorOption[\"stickyScroll\"] = 116] = \"stickyScroll\";\n    EditorOption[EditorOption[\"stickyTabStops\"] = 117] = \"stickyTabStops\";\n    EditorOption[EditorOption[\"stopRenderingLineAfter\"] = 118] = \"stopRenderingLineAfter\";\n    EditorOption[EditorOption[\"suggest\"] = 119] = \"suggest\";\n    EditorOption[EditorOption[\"suggestFontSize\"] = 120] = \"suggestFontSize\";\n    EditorOption[EditorOption[\"suggestLineHeight\"] = 121] = \"suggestLineHeight\";\n    EditorOption[EditorOption[\"suggestOnTriggerCharacters\"] = 122] = \"suggestOnTriggerCharacters\";\n    EditorOption[EditorOption[\"suggestSelection\"] = 123] = \"suggestSelection\";\n    EditorOption[EditorOption[\"tabCompletion\"] = 124] = \"tabCompletion\";\n    EditorOption[EditorOption[\"tabIndex\"] = 125] = \"tabIndex\";\n    EditorOption[EditorOption[\"unicodeHighlighting\"] = 126] = \"unicodeHighlighting\";\n    EditorOption[EditorOption[\"unusualLineTerminators\"] = 127] = \"unusualLineTerminators\";\n    EditorOption[EditorOption[\"useShadowDOM\"] = 128] = \"useShadowDOM\";\n    EditorOption[EditorOption[\"useTabStops\"] = 129] = \"useTabStops\";\n    EditorOption[EditorOption[\"wordBreak\"] = 130] = \"wordBreak\";\n    EditorOption[EditorOption[\"wordSegmenterLocales\"] = 131] = \"wordSegmenterLocales\";\n    EditorOption[EditorOption[\"wordSeparators\"] = 132] = \"wordSeparators\";\n    EditorOption[EditorOption[\"wordWrap\"] = 133] = \"wordWrap\";\n    EditorOption[EditorOption[\"wordWrapBreakAfterCharacters\"] = 134] = \"wordWrapBreakAfterCharacters\";\n    EditorOption[EditorOption[\"wordWrapBreakBeforeCharacters\"] = 135] = \"wordWrapBreakBeforeCharacters\";\n    EditorOption[EditorOption[\"wordWrapColumn\"] = 136] = \"wordWrapColumn\";\n    EditorOption[EditorOption[\"wordWrapOverride1\"] = 137] = \"wordWrapOverride1\";\n    EditorOption[EditorOption[\"wordWrapOverride2\"] = 138] = \"wordWrapOverride2\";\n    EditorOption[EditorOption[\"wrappingIndent\"] = 139] = \"wrappingIndent\";\n    EditorOption[EditorOption[\"wrappingStrategy\"] = 140] = \"wrappingStrategy\";\n    EditorOption[EditorOption[\"showDeprecated\"] = 141] = \"showDeprecated\";\n    EditorOption[EditorOption[\"inlayHints\"] = 142] = \"inlayHints\";\n    EditorOption[EditorOption[\"editorClassName\"] = 143] = \"editorClassName\";\n    EditorOption[EditorOption[\"pixelRatio\"] = 144] = \"pixelRatio\";\n    EditorOption[EditorOption[\"tabFocusMode\"] = 145] = \"tabFocusMode\";\n    EditorOption[EditorOption[\"layoutInfo\"] = 146] = \"layoutInfo\";\n    EditorOption[EditorOption[\"wrappingInfo\"] = 147] = \"wrappingInfo\";\n    EditorOption[EditorOption[\"defaultColorDecorators\"] = 148] = \"defaultColorDecorators\";\n    EditorOption[EditorOption[\"colorDecoratorsActivatedOn\"] = 149] = \"colorDecoratorsActivatedOn\";\n    EditorOption[EditorOption[\"inlineCompletionsAccessibilityVerbose\"] = 150] = \"inlineCompletionsAccessibilityVerbose\";\n})(EditorOption || (EditorOption = {}));\n/**\n * End of line character preference.\n */\nexport var EndOfLinePreference;\n(function (EndOfLinePreference) {\n    /**\n     * Use the end of line character identified in the text buffer.\n     */\n    EndOfLinePreference[EndOfLinePreference[\"TextDefined\"] = 0] = \"TextDefined\";\n    /**\n     * Use line feed (\\n) as the end of line character.\n     */\n    EndOfLinePreference[EndOfLinePreference[\"LF\"] = 1] = \"LF\";\n    /**\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\n     */\n    EndOfLinePreference[EndOfLinePreference[\"CRLF\"] = 2] = \"CRLF\";\n})(EndOfLinePreference || (EndOfLinePreference = {}));\n/**\n * End of line character preference.\n */\nexport var EndOfLineSequence;\n(function (EndOfLineSequence) {\n    /**\n     * Use line feed (\\n) as the end of line character.\n     */\n    EndOfLineSequence[EndOfLineSequence[\"LF\"] = 0] = \"LF\";\n    /**\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\n     */\n    EndOfLineSequence[EndOfLineSequence[\"CRLF\"] = 1] = \"CRLF\";\n})(EndOfLineSequence || (EndOfLineSequence = {}));\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport var GlyphMarginLane;\n(function (GlyphMarginLane) {\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\n    GlyphMarginLane[GlyphMarginLane[\"Center\"] = 2] = \"Center\";\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 3] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {}));\nexport var HoverVerbosityAction;\n(function (HoverVerbosityAction) {\n    /**\n     * Increase the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\n    /**\n     * Decrease the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\n})(HoverVerbosityAction || (HoverVerbosityAction = {}));\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\nexport var InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport var InlineEditTriggerKind;\n(function (InlineEditTriggerKind) {\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));\n/**\n * Virtual Key Codes, the value does not hold any inherent meaning.\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n * But these are \"more general\", as they should work across browsers & OS`s.\n */\nexport var KeyCode;\n(function (KeyCode) {\n    KeyCode[KeyCode[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\n    /**\n     * Placed first to cover the 0 value of the enum.\n     */\n    KeyCode[KeyCode[\"Unknown\"] = 0] = \"Unknown\";\n    KeyCode[KeyCode[\"Backspace\"] = 1] = \"Backspace\";\n    KeyCode[KeyCode[\"Tab\"] = 2] = \"Tab\";\n    KeyCode[KeyCode[\"Enter\"] = 3] = \"Enter\";\n    KeyCode[KeyCode[\"Shift\"] = 4] = \"Shift\";\n    KeyCode[KeyCode[\"Ctrl\"] = 5] = \"Ctrl\";\n    KeyCode[KeyCode[\"Alt\"] = 6] = \"Alt\";\n    KeyCode[KeyCode[\"PauseBreak\"] = 7] = \"PauseBreak\";\n    KeyCode[KeyCode[\"CapsLock\"] = 8] = \"CapsLock\";\n    KeyCode[KeyCode[\"Escape\"] = 9] = \"Escape\";\n    KeyCode[KeyCode[\"Space\"] = 10] = \"Space\";\n    KeyCode[KeyCode[\"PageUp\"] = 11] = \"PageUp\";\n    KeyCode[KeyCode[\"PageDown\"] = 12] = \"PageDown\";\n    KeyCode[KeyCode[\"End\"] = 13] = \"End\";\n    KeyCode[KeyCode[\"Home\"] = 14] = \"Home\";\n    KeyCode[KeyCode[\"LeftArrow\"] = 15] = \"LeftArrow\";\n    KeyCode[KeyCode[\"UpArrow\"] = 16] = \"UpArrow\";\n    KeyCode[KeyCode[\"RightArrow\"] = 17] = \"RightArrow\";\n    KeyCode[KeyCode[\"DownArrow\"] = 18] = \"DownArrow\";\n    KeyCode[KeyCode[\"Insert\"] = 19] = \"Insert\";\n    KeyCode[KeyCode[\"Delete\"] = 20] = \"Delete\";\n    KeyCode[KeyCode[\"Digit0\"] = 21] = \"Digit0\";\n    KeyCode[KeyCode[\"Digit1\"] = 22] = \"Digit1\";\n    KeyCode[KeyCode[\"Digit2\"] = 23] = \"Digit2\";\n    KeyCode[KeyCode[\"Digit3\"] = 24] = \"Digit3\";\n    KeyCode[KeyCode[\"Digit4\"] = 25] = \"Digit4\";\n    KeyCode[KeyCode[\"Digit5\"] = 26] = \"Digit5\";\n    KeyCode[KeyCode[\"Digit6\"] = 27] = \"Digit6\";\n    KeyCode[KeyCode[\"Digit7\"] = 28] = \"Digit7\";\n    KeyCode[KeyCode[\"Digit8\"] = 29] = \"Digit8\";\n    KeyCode[KeyCode[\"Digit9\"] = 30] = \"Digit9\";\n    KeyCode[KeyCode[\"KeyA\"] = 31] = \"KeyA\";\n    KeyCode[KeyCode[\"KeyB\"] = 32] = \"KeyB\";\n    KeyCode[KeyCode[\"KeyC\"] = 33] = \"KeyC\";\n    KeyCode[KeyCode[\"KeyD\"] = 34] = \"KeyD\";\n    KeyCode[KeyCode[\"KeyE\"] = 35] = \"KeyE\";\n    KeyCode[KeyCode[\"KeyF\"] = 36] = \"KeyF\";\n    KeyCode[KeyCode[\"KeyG\"] = 37] = \"KeyG\";\n    KeyCode[KeyCode[\"KeyH\"] = 38] = \"KeyH\";\n    KeyCode[KeyCode[\"KeyI\"] = 39] = \"KeyI\";\n    KeyCode[KeyCode[\"KeyJ\"] = 40] = \"KeyJ\";\n    KeyCode[KeyCode[\"KeyK\"] = 41] = \"KeyK\";\n    KeyCode[KeyCode[\"KeyL\"] = 42] = \"KeyL\";\n    KeyCode[KeyCode[\"KeyM\"] = 43] = \"KeyM\";\n    KeyCode[KeyCode[\"KeyN\"] = 44] = \"KeyN\";\n    KeyCode[KeyCode[\"KeyO\"] = 45] = \"KeyO\";\n    KeyCode[KeyCode[\"KeyP\"] = 46] = \"KeyP\";\n    KeyCode[KeyCode[\"KeyQ\"] = 47] = \"KeyQ\";\n    KeyCode[KeyCode[\"KeyR\"] = 48] = \"KeyR\";\n    KeyCode[KeyCode[\"KeyS\"] = 49] = \"KeyS\";\n    KeyCode[KeyCode[\"KeyT\"] = 50] = \"KeyT\";\n    KeyCode[KeyCode[\"KeyU\"] = 51] = \"KeyU\";\n    KeyCode[KeyCode[\"KeyV\"] = 52] = \"KeyV\";\n    KeyCode[KeyCode[\"KeyW\"] = 53] = \"KeyW\";\n    KeyCode[KeyCode[\"KeyX\"] = 54] = \"KeyX\";\n    KeyCode[KeyCode[\"KeyY\"] = 55] = \"KeyY\";\n    KeyCode[KeyCode[\"KeyZ\"] = 56] = \"KeyZ\";\n    KeyCode[KeyCode[\"Meta\"] = 57] = \"Meta\";\n    KeyCode[KeyCode[\"ContextMenu\"] = 58] = \"ContextMenu\";\n    KeyCode[KeyCode[\"F1\"] = 59] = \"F1\";\n    KeyCode[KeyCode[\"F2\"] = 60] = \"F2\";\n    KeyCode[KeyCode[\"F3\"] = 61] = \"F3\";\n    KeyCode[KeyCode[\"F4\"] = 62] = \"F4\";\n    KeyCode[KeyCode[\"F5\"] = 63] = \"F5\";\n    KeyCode[KeyCode[\"F6\"] = 64] = \"F6\";\n    KeyCode[KeyCode[\"F7\"] = 65] = \"F7\";\n    KeyCode[KeyCode[\"F8\"] = 66] = \"F8\";\n    KeyCode[KeyCode[\"F9\"] = 67] = \"F9\";\n    KeyCode[KeyCode[\"F10\"] = 68] = \"F10\";\n    KeyCode[KeyCode[\"F11\"] = 69] = \"F11\";\n    KeyCode[KeyCode[\"F12\"] = 70] = \"F12\";\n    KeyCode[KeyCode[\"F13\"] = 71] = \"F13\";\n    KeyCode[KeyCode[\"F14\"] = 72] = \"F14\";\n    KeyCode[KeyCode[\"F15\"] = 73] = \"F15\";\n    KeyCode[KeyCode[\"F16\"] = 74] = \"F16\";\n    KeyCode[KeyCode[\"F17\"] = 75] = \"F17\";\n    KeyCode[KeyCode[\"F18\"] = 76] = \"F18\";\n    KeyCode[KeyCode[\"F19\"] = 77] = \"F19\";\n    KeyCode[KeyCode[\"F20\"] = 78] = \"F20\";\n    KeyCode[KeyCode[\"F21\"] = 79] = \"F21\";\n    KeyCode[KeyCode[\"F22\"] = 80] = \"F22\";\n    KeyCode[KeyCode[\"F23\"] = 81] = \"F23\";\n    KeyCode[KeyCode[\"F24\"] = 82] = \"F24\";\n    KeyCode[KeyCode[\"NumLock\"] = 83] = \"NumLock\";\n    KeyCode[KeyCode[\"ScrollLock\"] = 84] = \"ScrollLock\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ';:' key\n     */\n    KeyCode[KeyCode[\"Semicolon\"] = 85] = \"Semicolon\";\n    /**\n     * For any country/region, the '+' key\n     * For the US standard keyboard, the '=+' key\n     */\n    KeyCode[KeyCode[\"Equal\"] = 86] = \"Equal\";\n    /**\n     * For any country/region, the ',' key\n     * For the US standard keyboard, the ',<' key\n     */\n    KeyCode[KeyCode[\"Comma\"] = 87] = \"Comma\";\n    /**\n     * For any country/region, the '-' key\n     * For the US standard keyboard, the '-_' key\n     */\n    KeyCode[KeyCode[\"Minus\"] = 88] = \"Minus\";\n    /**\n     * For any country/region, the '.' key\n     * For the US standard keyboard, the '.>' key\n     */\n    KeyCode[KeyCode[\"Period\"] = 89] = \"Period\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '/?' key\n     */\n    KeyCode[KeyCode[\"Slash\"] = 90] = \"Slash\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '`~' key\n     */\n    KeyCode[KeyCode[\"Backquote\"] = 91] = \"Backquote\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '[{' key\n     */\n    KeyCode[KeyCode[\"BracketLeft\"] = 92] = \"BracketLeft\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '\\|' key\n     */\n    KeyCode[KeyCode[\"Backslash\"] = 93] = \"Backslash\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ']}' key\n     */\n    KeyCode[KeyCode[\"BracketRight\"] = 94] = \"BracketRight\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ''\"' key\n     */\n    KeyCode[KeyCode[\"Quote\"] = 95] = \"Quote\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     */\n    KeyCode[KeyCode[\"OEM_8\"] = 96] = \"OEM_8\";\n    /**\n     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\n     */\n    KeyCode[KeyCode[\"IntlBackslash\"] = 97] = \"IntlBackslash\";\n    KeyCode[KeyCode[\"Numpad0\"] = 98] = \"Numpad0\";\n    KeyCode[KeyCode[\"Numpad1\"] = 99] = \"Numpad1\";\n    KeyCode[KeyCode[\"Numpad2\"] = 100] = \"Numpad2\";\n    KeyCode[KeyCode[\"Numpad3\"] = 101] = \"Numpad3\";\n    KeyCode[KeyCode[\"Numpad4\"] = 102] = \"Numpad4\";\n    KeyCode[KeyCode[\"Numpad5\"] = 103] = \"Numpad5\";\n    KeyCode[KeyCode[\"Numpad6\"] = 104] = \"Numpad6\";\n    KeyCode[KeyCode[\"Numpad7\"] = 105] = \"Numpad7\";\n    KeyCode[KeyCode[\"Numpad8\"] = 106] = \"Numpad8\";\n    KeyCode[KeyCode[\"Numpad9\"] = 107] = \"Numpad9\";\n    KeyCode[KeyCode[\"NumpadMultiply\"] = 108] = \"NumpadMultiply\";\n    KeyCode[KeyCode[\"NumpadAdd\"] = 109] = \"NumpadAdd\";\n    KeyCode[KeyCode[\"NUMPAD_SEPARATOR\"] = 110] = \"NUMPAD_SEPARATOR\";\n    KeyCode[KeyCode[\"NumpadSubtract\"] = 111] = \"NumpadSubtract\";\n    KeyCode[KeyCode[\"NumpadDecimal\"] = 112] = \"NumpadDecimal\";\n    KeyCode[KeyCode[\"NumpadDivide\"] = 113] = \"NumpadDivide\";\n    /**\n     * Cover all key codes when IME is processing input.\n     */\n    KeyCode[KeyCode[\"KEY_IN_COMPOSITION\"] = 114] = \"KEY_IN_COMPOSITION\";\n    KeyCode[KeyCode[\"ABNT_C1\"] = 115] = \"ABNT_C1\";\n    KeyCode[KeyCode[\"ABNT_C2\"] = 116] = \"ABNT_C2\";\n    KeyCode[KeyCode[\"AudioVolumeMute\"] = 117] = \"AudioVolumeMute\";\n    KeyCode[KeyCode[\"AudioVolumeUp\"] = 118] = \"AudioVolumeUp\";\n    KeyCode[KeyCode[\"AudioVolumeDown\"] = 119] = \"AudioVolumeDown\";\n    KeyCode[KeyCode[\"BrowserSearch\"] = 120] = \"BrowserSearch\";\n    KeyCode[KeyCode[\"BrowserHome\"] = 121] = \"BrowserHome\";\n    KeyCode[KeyCode[\"BrowserBack\"] = 122] = \"BrowserBack\";\n    KeyCode[KeyCode[\"BrowserForward\"] = 123] = \"BrowserForward\";\n    KeyCode[KeyCode[\"MediaTrackNext\"] = 124] = \"MediaTrackNext\";\n    KeyCode[KeyCode[\"MediaTrackPrevious\"] = 125] = \"MediaTrackPrevious\";\n    KeyCode[KeyCode[\"MediaStop\"] = 126] = \"MediaStop\";\n    KeyCode[KeyCode[\"MediaPlayPause\"] = 127] = \"MediaPlayPause\";\n    KeyCode[KeyCode[\"LaunchMediaPlayer\"] = 128] = \"LaunchMediaPlayer\";\n    KeyCode[KeyCode[\"LaunchMail\"] = 129] = \"LaunchMail\";\n    KeyCode[KeyCode[\"LaunchApp2\"] = 130] = \"LaunchApp2\";\n    /**\n     * VK_CLEAR, 0x0C, CLEAR key\n     */\n    KeyCode[KeyCode[\"Clear\"] = 131] = \"Clear\";\n    /**\n     * Placed last to cover the length of the enum.\n     * Please do not depend on this value!\n     */\n    KeyCode[KeyCode[\"MAX_VALUE\"] = 132] = \"MAX_VALUE\";\n})(KeyCode || (KeyCode = {}));\nexport var MarkerSeverity;\n(function (MarkerSeverity) {\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}));\nexport var MarkerTag;\n(function (MarkerTag) {\n    MarkerTag[MarkerTag[\"Unnecessary\"] = 1] = \"Unnecessary\";\n    MarkerTag[MarkerTag[\"Deprecated\"] = 2] = \"Deprecated\";\n})(MarkerTag || (MarkerTag = {}));\n/**\n * Position in the minimap to render the decoration.\n */\nexport var MinimapPosition;\n(function (MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\n/**\n * Section header style.\n */\nexport var MinimapSectionHeaderStyle;\n(function (MinimapSectionHeaderStyle) {\n    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle[\"Normal\"] = 1] = \"Normal\";\n    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle[\"Underlined\"] = 2] = \"Underlined\";\n})(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));\n/**\n * Type of hit element with the mouse in the editor.\n */\nexport var MouseTargetType;\n(function (MouseTargetType) {\n    /**\n     * Mouse is on top of an unknown element.\n     */\n    MouseTargetType[MouseTargetType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n     * Mouse is on top of the textarea used for input.\n     */\n    MouseTargetType[MouseTargetType[\"TEXTAREA\"] = 1] = \"TEXTAREA\";\n    /**\n     * Mouse is on top of the glyph margin\n     */\n    MouseTargetType[MouseTargetType[\"GUTTER_GLYPH_MARGIN\"] = 2] = \"GUTTER_GLYPH_MARGIN\";\n    /**\n     * Mouse is on top of the line numbers\n     */\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_NUMBERS\"] = 3] = \"GUTTER_LINE_NUMBERS\";\n    /**\n     * Mouse is on top of the line decorations\n     */\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_DECORATIONS\"] = 4] = \"GUTTER_LINE_DECORATIONS\";\n    /**\n     * Mouse is on top of the whitespace left in the gutter by a view zone.\n     */\n    MouseTargetType[MouseTargetType[\"GUTTER_VIEW_ZONE\"] = 5] = \"GUTTER_VIEW_ZONE\";\n    /**\n     * Mouse is on top of text in the content.\n     */\n    MouseTargetType[MouseTargetType[\"CONTENT_TEXT\"] = 6] = \"CONTENT_TEXT\";\n    /**\n     * Mouse is on top of empty space in the content (e.g. after line text or below last line)\n     */\n    MouseTargetType[MouseTargetType[\"CONTENT_EMPTY\"] = 7] = \"CONTENT_EMPTY\";\n    /**\n     * Mouse is on top of a view zone in the content.\n     */\n    MouseTargetType[MouseTargetType[\"CONTENT_VIEW_ZONE\"] = 8] = \"CONTENT_VIEW_ZONE\";\n    /**\n     * Mouse is on top of a content widget.\n     */\n    MouseTargetType[MouseTargetType[\"CONTENT_WIDGET\"] = 9] = \"CONTENT_WIDGET\";\n    /**\n     * Mouse is on top of the decorations overview ruler.\n     */\n    MouseTargetType[MouseTargetType[\"OVERVIEW_RULER\"] = 10] = \"OVERVIEW_RULER\";\n    /**\n     * Mouse is on top of a scrollbar.\n     */\n    MouseTargetType[MouseTargetType[\"SCROLLBAR\"] = 11] = \"SCROLLBAR\";\n    /**\n     * Mouse is on top of an overlay widget.\n     */\n    MouseTargetType[MouseTargetType[\"OVERLAY_WIDGET\"] = 12] = \"OVERLAY_WIDGET\";\n    /**\n     * Mouse is outside of the editor.\n     */\n    MouseTargetType[MouseTargetType[\"OUTSIDE_EDITOR\"] = 13] = \"OUTSIDE_EDITOR\";\n})(MouseTargetType || (MouseTargetType = {}));\nexport var NewSymbolNameTag;\n(function (NewSymbolNameTag) {\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(NewSymbolNameTag || (NewSymbolNameTag = {}));\nexport var NewSymbolNameTriggerKind;\n(function (NewSymbolNameTriggerKind) {\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));\n/**\n * A positioning preference for rendering overlay widgets.\n */\nexport var OverlayWidgetPositionPreference;\n(function (OverlayWidgetPositionPreference) {\n    /**\n     * Position the overlay widget in the top right corner\n     */\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_RIGHT_CORNER\"] = 0] = \"TOP_RIGHT_CORNER\";\n    /**\n     * Position the overlay widget in the bottom right corner\n     */\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"BOTTOM_RIGHT_CORNER\"] = 1] = \"BOTTOM_RIGHT_CORNER\";\n    /**\n     * Position the overlay widget in the top center\n     */\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_CENTER\"] = 2] = \"TOP_CENTER\";\n})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * How a partial acceptance was triggered.\n */\nexport var PartialAcceptTriggerKind;\n(function (PartialAcceptTriggerKind) {\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Word\"] = 0] = \"Word\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Line\"] = 1] = \"Line\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Suggest\"] = 2] = \"Suggest\";\n})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));\nexport var PositionAffinity;\n(function (PositionAffinity) {\n    /**\n     * Prefers the left most position.\n    */\n    PositionAffinity[PositionAffinity[\"Left\"] = 0] = \"Left\";\n    /**\n     * Prefers the right most position.\n    */\n    PositionAffinity[PositionAffinity[\"Right\"] = 1] = \"Right\";\n    /**\n     * No preference.\n    */\n    PositionAffinity[PositionAffinity[\"None\"] = 2] = \"None\";\n    /**\n     * If the given position is on injected text, prefers the position left of it.\n    */\n    PositionAffinity[PositionAffinity[\"LeftOfInjectedText\"] = 3] = \"LeftOfInjectedText\";\n    /**\n     * If the given position is on injected text, prefers the position right of it.\n    */\n    PositionAffinity[PositionAffinity[\"RightOfInjectedText\"] = 4] = \"RightOfInjectedText\";\n})(PositionAffinity || (PositionAffinity = {}));\nexport var RenderLineNumbersType;\n(function (RenderLineNumbersType) {\n    RenderLineNumbersType[RenderLineNumbersType[\"Off\"] = 0] = \"Off\";\n    RenderLineNumbersType[RenderLineNumbersType[\"On\"] = 1] = \"On\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Relative\"] = 2] = \"Relative\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Interval\"] = 3] = \"Interval\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Custom\"] = 4] = \"Custom\";\n})(RenderLineNumbersType || (RenderLineNumbersType = {}));\nexport var RenderMinimap;\n(function (RenderMinimap) {\n    RenderMinimap[RenderMinimap[\"None\"] = 0] = \"None\";\n    RenderMinimap[RenderMinimap[\"Text\"] = 1] = \"Text\";\n    RenderMinimap[RenderMinimap[\"Blocks\"] = 2] = \"Blocks\";\n})(RenderMinimap || (RenderMinimap = {}));\nexport var ScrollType;\n(function (ScrollType) {\n    ScrollType[ScrollType[\"Smooth\"] = 0] = \"Smooth\";\n    ScrollType[ScrollType[\"Immediate\"] = 1] = \"Immediate\";\n})(ScrollType || (ScrollType = {}));\nexport var ScrollbarVisibility;\n(function (ScrollbarVisibility) {\n    ScrollbarVisibility[ScrollbarVisibility[\"Auto\"] = 1] = \"Auto\";\n    ScrollbarVisibility[ScrollbarVisibility[\"Hidden\"] = 2] = \"Hidden\";\n    ScrollbarVisibility[ScrollbarVisibility[\"Visible\"] = 3] = \"Visible\";\n})(ScrollbarVisibility || (ScrollbarVisibility = {}));\n/**\n * The direction of a selection.\n */\nexport var SelectionDirection;\n(function (SelectionDirection) {\n    /**\n     * The selection starts above where it ends.\n     */\n    SelectionDirection[SelectionDirection[\"LTR\"] = 0] = \"LTR\";\n    /**\n     * The selection starts below where it ends.\n     */\n    SelectionDirection[SelectionDirection[\"RTL\"] = 1] = \"RTL\";\n})(SelectionDirection || (SelectionDirection = {}));\nexport var ShowLightbulbIconMode;\n(function (ShowLightbulbIconMode) {\n    ShowLightbulbIconMode[\"Off\"] = \"off\";\n    ShowLightbulbIconMode[\"OnCode\"] = \"onCode\";\n    ShowLightbulbIconMode[\"On\"] = \"on\";\n})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A symbol kind.\n */\nexport var SymbolKind;\n(function (SymbolKind) {\n    SymbolKind[SymbolKind[\"File\"] = 0] = \"File\";\n    SymbolKind[SymbolKind[\"Module\"] = 1] = \"Module\";\n    SymbolKind[SymbolKind[\"Namespace\"] = 2] = \"Namespace\";\n    SymbolKind[SymbolKind[\"Package\"] = 3] = \"Package\";\n    SymbolKind[SymbolKind[\"Class\"] = 4] = \"Class\";\n    SymbolKind[SymbolKind[\"Method\"] = 5] = \"Method\";\n    SymbolKind[SymbolKind[\"Property\"] = 6] = \"Property\";\n    SymbolKind[SymbolKind[\"Field\"] = 7] = \"Field\";\n    SymbolKind[SymbolKind[\"Constructor\"] = 8] = \"Constructor\";\n    SymbolKind[SymbolKind[\"Enum\"] = 9] = \"Enum\";\n    SymbolKind[SymbolKind[\"Interface\"] = 10] = \"Interface\";\n    SymbolKind[SymbolKind[\"Function\"] = 11] = \"Function\";\n    SymbolKind[SymbolKind[\"Variable\"] = 12] = \"Variable\";\n    SymbolKind[SymbolKind[\"Constant\"] = 13] = \"Constant\";\n    SymbolKind[SymbolKind[\"String\"] = 14] = \"String\";\n    SymbolKind[SymbolKind[\"Number\"] = 15] = \"Number\";\n    SymbolKind[SymbolKind[\"Boolean\"] = 16] = \"Boolean\";\n    SymbolKind[SymbolKind[\"Array\"] = 17] = \"Array\";\n    SymbolKind[SymbolKind[\"Object\"] = 18] = \"Object\";\n    SymbolKind[SymbolKind[\"Key\"] = 19] = \"Key\";\n    SymbolKind[SymbolKind[\"Null\"] = 20] = \"Null\";\n    SymbolKind[SymbolKind[\"EnumMember\"] = 21] = \"EnumMember\";\n    SymbolKind[SymbolKind[\"Struct\"] = 22] = \"Struct\";\n    SymbolKind[SymbolKind[\"Event\"] = 23] = \"Event\";\n    SymbolKind[SymbolKind[\"Operator\"] = 24] = \"Operator\";\n    SymbolKind[SymbolKind[\"TypeParameter\"] = 25] = \"TypeParameter\";\n})(SymbolKind || (SymbolKind = {}));\nexport var SymbolTag;\n(function (SymbolTag) {\n    SymbolTag[SymbolTag[\"Deprecated\"] = 1] = \"Deprecated\";\n})(SymbolTag || (SymbolTag = {}));\n/**\n * The kind of animation in which the editor's cursor should be rendered.\n */\nexport var TextEditorCursorBlinkingStyle;\n(function (TextEditorCursorBlinkingStyle) {\n    /**\n     * Hidden\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Hidden\"] = 0] = \"Hidden\";\n    /**\n     * Blinking\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Blink\"] = 1] = \"Blink\";\n    /**\n     * Blinking with smooth fading\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Smooth\"] = 2] = \"Smooth\";\n    /**\n     * Blinking with prolonged filled state and smooth fading\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Phase\"] = 3] = \"Phase\";\n    /**\n     * Expand collapse animation on the y axis\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Expand\"] = 4] = \"Expand\";\n    /**\n     * No-Blinking\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Solid\"] = 5] = \"Solid\";\n})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));\n/**\n * The style in which the editor's cursor should be rendered.\n */\nexport var TextEditorCursorStyle;\n(function (TextEditorCursorStyle) {\n    /**\n     * As a vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\n    /**\n     * As a block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\n    /**\n     * As a horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\n    /**\n     * As a thin vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\n    /**\n     * As an outlined block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\n    /**\n     * As a thin horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\n/**\n * Describes the behavior of decorations when typing/editing near their edges.\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\n */\nexport var TrackedRangeStickiness;\n(function (TrackedRangeStickiness) {\n    TrackedRangeStickiness[TrackedRangeStickiness[\"AlwaysGrowsWhenTypingAtEdges\"] = 0] = \"AlwaysGrowsWhenTypingAtEdges\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"NeverGrowsWhenTypingAtEdges\"] = 1] = \"NeverGrowsWhenTypingAtEdges\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingBefore\"] = 2] = \"GrowsOnlyWhenTypingBefore\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingAfter\"] = 3] = \"GrowsOnlyWhenTypingAfter\";\n})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));\n/**\n * Describes how to indent wrapped lines.\n */\nexport var WrappingIndent;\n(function (WrappingIndent) {\n    /**\n     * No indentation => wrapped lines begin at column 1.\n     */\n    WrappingIndent[WrappingIndent[\"None\"] = 0] = \"None\";\n    /**\n     * Same => wrapped lines get the same indentation as the parent.\n     */\n    WrappingIndent[WrappingIndent[\"Same\"] = 1] = \"Same\";\n    /**\n     * Indent => wrapped lines get +1 indentation toward the parent.\n     */\n    WrappingIndent[WrappingIndent[\"Indent\"] = 2] = \"Indent\";\n    /**\n     * DeepIndent => wrapped lines get +2 indentation toward the parent.\n     */\n    WrappingIndent[WrappingIndent[\"DeepIndent\"] = 3] = \"DeepIndent\";\n})(WrappingIndent || (WrappingIndent = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { KeyChord } from '../../../base/common/keyCodes.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Token } from '../languages.js';\nimport * as standaloneEnums from '../standalone/standaloneEnums.js';\nexport class KeyMod {\n    static { this.CtrlCmd = 2048 /* ConstKeyMod.CtrlCmd */; }\n    static { this.Shift = 1024 /* ConstKeyMod.Shift */; }\n    static { this.Alt = 512 /* ConstKeyMod.Alt */; }\n    static { this.WinCtrl = 256 /* ConstKeyMod.WinCtrl */; }\n    static chord(firstPart, secondPart) {\n        return KeyChord(firstPart, secondPart);\n    }\n}\nexport function createMonacoBaseAPI() {\n    return {\n        editor: undefined, // undefined override expected here\n        languages: undefined, // undefined override expected here\n        CancellationTokenSource: CancellationTokenSource,\n        Emitter: Emitter,\n        KeyCode: standaloneEnums.KeyCode,\n        KeyMod: KeyMod,\n        Position: Position,\n        Range: Range,\n        Selection: Selection,\n        SelectionDirection: standaloneEnums.SelectionDirection,\n        MarkerSeverity: standaloneEnums.MarkerSeverity,\n        MarkerTag: standaloneEnums.MarkerTag,\n        Uri: URI,\n        Token: Token\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nexport const EditorZoom = new class {\n    constructor() {\n        this._zoomLevel = 0;\n        this._onDidChangeZoomLevel = new Emitter();\n        this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;\n    }\n    getZoomLevel() {\n        return this._zoomLevel;\n    }\n    setZoomLevel(zoomLevel) {\n        zoomLevel = Math.min(Math.max(-5, zoomLevel), 20);\n        if (this._zoomLevel === zoomLevel) {\n            return;\n        }\n        this._zoomLevel = zoomLevel;\n        this._onDidChangeZoomLevel.fire(this._zoomLevel);\n    }\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as platform from '../../../base/common/platform.js';\nimport { EditorFontVariations, EDITOR_FONT_DEFAULTS } from './editorOptions.js';\nimport { EditorZoom } from './editorZoom.js';\n/**\n * Determined from empirical observations.\n * @internal\n */\nconst GOLDEN_LINE_HEIGHT_RATIO = platform.isMacintosh ? 1.5 : 1.35;\n/**\n * @internal\n */\nconst MINIMUM_LINE_HEIGHT = 8;\nexport class BareFontInfo {\n    /**\n     * @internal\n     */\n    static createFromValidatedSettings(options, pixelRatio, ignoreEditorZoom) {\n        const fontFamily = options.get(49 /* EditorOption.fontFamily */);\n        const fontWeight = options.get(53 /* EditorOption.fontWeight */);\n        const fontSize = options.get(52 /* EditorOption.fontSize */);\n        const fontFeatureSettings = options.get(51 /* EditorOption.fontLigatures */);\n        const fontVariationSettings = options.get(54 /* EditorOption.fontVariations */);\n        const lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        const letterSpacing = options.get(64 /* EditorOption.letterSpacing */);\n        return BareFontInfo._create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom);\n    }\n    /**\n     * @internal\n     */\n    static _create(fontFamily, fontWeight, fontSize, fontFeatureSettings, fontVariationSettings, lineHeight, letterSpacing, pixelRatio, ignoreEditorZoom) {\n        if (lineHeight === 0) {\n            lineHeight = GOLDEN_LINE_HEIGHT_RATIO * fontSize;\n        }\n        else if (lineHeight < MINIMUM_LINE_HEIGHT) {\n            // Values too small to be line heights in pixels are in ems.\n            lineHeight = lineHeight * fontSize;\n        }\n        // Enforce integer, minimum constraints\n        lineHeight = Math.round(lineHeight);\n        if (lineHeight < MINIMUM_LINE_HEIGHT) {\n            lineHeight = MINIMUM_LINE_HEIGHT;\n        }\n        const editorZoomLevelMultiplier = 1 + (ignoreEditorZoom ? 0 : EditorZoom.getZoomLevel() * 0.1);\n        fontSize *= editorZoomLevelMultiplier;\n        lineHeight *= editorZoomLevelMultiplier;\n        if (fontVariationSettings === EditorFontVariations.TRANSLATE) {\n            if (fontWeight === 'normal' || fontWeight === 'bold') {\n                fontVariationSettings = EditorFontVariations.OFF;\n            }\n            else {\n                const fontWeightAsNumber = parseInt(fontWeight, 10);\n                fontVariationSettings = `'wght' ${fontWeightAsNumber}`;\n                fontWeight = 'normal';\n            }\n        }\n        return new BareFontInfo({\n            pixelRatio: pixelRatio,\n            fontFamily: fontFamily,\n            fontWeight: fontWeight,\n            fontSize: fontSize,\n            fontFeatureSettings: fontFeatureSettings,\n            fontVariationSettings,\n            lineHeight: lineHeight,\n            letterSpacing: letterSpacing\n        });\n    }\n    /**\n     * @internal\n     */\n    constructor(opts) {\n        this._bareFontInfoBrand = undefined;\n        this.pixelRatio = opts.pixelRatio;\n        this.fontFamily = String(opts.fontFamily);\n        this.fontWeight = String(opts.fontWeight);\n        this.fontSize = opts.fontSize;\n        this.fontFeatureSettings = opts.fontFeatureSettings;\n        this.fontVariationSettings = opts.fontVariationSettings;\n        this.lineHeight = opts.lineHeight | 0;\n        this.letterSpacing = opts.letterSpacing;\n    }\n    /**\n     * @internal\n     */\n    getId() {\n        return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.fontVariationSettings}-${this.lineHeight}-${this.letterSpacing}`;\n    }\n    /**\n     * @internal\n     */\n    getMassagedFontFamily() {\n        const fallbackFontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        const fontFamily = BareFontInfo._wrapInQuotes(this.fontFamily);\n        if (fallbackFontFamily && this.fontFamily !== fallbackFontFamily) {\n            return `${fontFamily}, ${fallbackFontFamily}`;\n        }\n        return fontFamily;\n    }\n    static _wrapInQuotes(fontFamily) {\n        if (/[,\"']/.test(fontFamily)) {\n            // Looks like the font family might be already escaped\n            return fontFamily;\n        }\n        if (/[+ ]/.test(fontFamily)) {\n            // Wrap a font family using + or <space> with quotes\n            return `\"${fontFamily}\"`;\n        }\n        return fontFamily;\n    }\n}\n// change this whenever `FontInfo` members are changed\nexport const SERIALIZED_FONT_INFO_VERSION = 2;\nexport class FontInfo extends BareFontInfo {\n    /**\n     * @internal\n     */\n    constructor(opts, isTrusted) {\n        super(opts);\n        this._editorStylingBrand = undefined;\n        this.version = SERIALIZED_FONT_INFO_VERSION;\n        this.isTrusted = isTrusted;\n        this.isMonospace = opts.isMonospace;\n        this.typicalHalfwidthCharacterWidth = opts.typicalHalfwidthCharacterWidth;\n        this.typicalFullwidthCharacterWidth = opts.typicalFullwidthCharacterWidth;\n        this.canUseHalfwidthRightwardsArrow = opts.canUseHalfwidthRightwardsArrow;\n        this.spaceWidth = opts.spaceWidth;\n        this.middotWidth = opts.middotWidth;\n        this.wsmiddotWidth = opts.wsmiddotWidth;\n        this.maxDigitWidth = opts.maxDigitWidth;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.fontFamily === other.fontFamily\n            && this.fontWeight === other.fontWeight\n            && this.fontSize === other.fontSize\n            && this.fontFeatureSettings === other.fontFeatureSettings\n            && this.fontVariationSettings === other.fontVariationSettings\n            && this.lineHeight === other.lineHeight\n            && this.letterSpacing === other.letterSpacing\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n            && this.typicalFullwidthCharacterWidth === other.typicalFullwidthCharacterWidth\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.spaceWidth === other.spaceWidth\n            && this.middotWidth === other.middotWidth\n            && this.wsmiddotWidth === other.wsmiddotWidth\n            && this.maxDigitWidth === other.maxDigitWidth);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IModelService = createDecorator('modelService');\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextModelService = createDecorator('textModelService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n        this.languageIdCodec = actual.languageIdCodec;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getLineLength() {\n        return this._lastCharOffset - this.firstCharOffset;\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n    toIViewLineTokens() {\n        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nexport function createBracketOrRegExp(pieces, options) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true, options);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Extensions as ConfigurationExtensions } from '../../../platform/configuration/common/configurationRegistry.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n    }\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return this._languages;\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_LANGUAGE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_LANGUAGE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: [Mimes.text]\n});\nRegistry.as(ConfigurationExtensions.Configuration)\n    .registerDefaultConfigurations([{\n        overrides: {\n            '[plaintext]': {\n                'editor.unicodeHighlight.ambiguousCharacters': false,\n                'editor.unicodeHighlight.invisibleCharacters': false\n            }\n        }\n    }]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { createBracketOrRegExp } from './richEditBrackets.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n    getBracketRegExp(options) {\n        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);\n        return createBracketOrRegExp(brackets, options);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return entries?.getResolvedConfiguration() || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nclass Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* State.Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* State.Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* CharacterClass.None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* State.Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* State.Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* CharCode.OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 41 /* CharCode.CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 91 /* CharCode.OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 93 /* CharCode.CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 123 /* CharCode.OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 125 /* CharCode.CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        // The following three rules make it that ' or \" or ` are allowed inside links\n                        // only if the link is wrapped by some other quote character\n                        case 39 /* CharCode.SingleQuote */:\n                        case 34 /* CharCode.DoubleQuote */:\n                        case 96 /* CharCode.BackTick */:\n                            if (linkBeginChCode === chCode) {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {\n                                chClass = 0 /* CharacterClass.None */;\n                            }\n                            else {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            break;\n                        case 42 /* CharCode.Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 124 /* CharCode.Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 32 /* CharCode.Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* State.End */) {\n                    let chClass;\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* CharacterClass.None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* State.Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* State.Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* State.Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* State.Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    static { this.INSTANCE = new BasicInplaceReplace(); }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorWorkerHost {\n    static { this.CHANNEL_NAME = 'editorWorkerHost'; }\n    static getChannel(workerServer) {\n        return workerServer.getChannel(EditorWorkerHost.CHANNEL_NAME);\n    }\n    static setChannel(workerClient, obj) {\n        workerClient.setChannel(EditorWorkerHost.CHANNEL_NAME, obj);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators, intlSegmenterLocales) {\n        super(0 /* WordCharacterClass.Regular */);\n        this._segmenter = null;\n        this._cachedLine = null;\n        this._cachedSegments = [];\n        this.intlSegmenterLocales = intlSegmenterLocales;\n        if (this.intlSegmenterLocales.length > 0) {\n            this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n        }\n        else {\n            this._segmenter = null;\n        }\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n    findPrevIntlWordBeforeOrAtOffset(line, offset) {\n        let candidate = null;\n        for (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n            if (segment.index > offset) {\n                break;\n            }\n            candidate = segment;\n        }\n        return candidate;\n    }\n    findNextIntlWordAtOrAfterOffset(lineContent, offset) {\n        for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n            if (segment.index < offset) {\n                continue;\n            }\n            return segment;\n        }\n        return null;\n    }\n    _getIntlSegmenterWordsOnLine(line) {\n        if (!this._segmenter) {\n            return [];\n        }\n        // Check if the line has changed from the previous call\n        if (this._cachedLine === line) {\n            return this._cachedSegments;\n        }\n        // Update the cache with the new line\n        this._cachedLine = line;\n        this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));\n        return this._cachedSegments;\n    }\n    _filterWordSegments(segments) {\n        const result = [];\n        for (const segment of segments) {\n            if (this._isWordLike(segment)) {\n                result.push(segment);\n            }\n        }\n        return result;\n    }\n    _isWordLike(segment) {\n        if (segment.isWordLike) {\n            return true;\n        }\n        return false;\n    }\n}\nconst wordClassifierCache = new LRUCache(10);\nexport function getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {\n    const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n    let result = wordClassifierCache.get(key);\n    if (!result) {\n        result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n        wordClassifierCache.set(key, result);\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../base/common/objects.js';\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport var GlyphMarginLane;\n(function (GlyphMarginLane) {\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\n    GlyphMarginLane[GlyphMarginLane[\"Center\"] = 2] = \"Center\";\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 3] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {}));\nexport var InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nexport class TextModelResolvedOptions {\n    get originalIndentSize() {\n        return this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n    }\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this._textModelResolvedOptionsBrand = undefined;\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        if (src.indentSize === 'tabSize') {\n            this.indentSize = this.tabSize;\n            this._indentSizeIsTabSize = true;\n        }\n        else {\n            this.indentSize = Math.max(1, src.indentSize | 0);\n            this._indentSizeIsTabSize = false;\n        }\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this._indentSizeIsTabSize === other._indentSizeIsTabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\n            && equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nexport class FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this._findMatchBrand = undefined;\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nexport function isITextSnapshot(obj) {\n    return (obj && typeof obj.read === 'function');\n}\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nexport class SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\nexport class UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n                    if (word && word.endColumn <= startIndex + 1) {\n                        // The word does not include the problematic character, ignore the word\n                        word = null;\n                    }\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n        switch (reason) {\n            case 0 /* SimpleHighlightReason.None */:\n                return null;\n            case 2 /* SimpleHighlightReason.Invisible */:\n                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };\n            case 3 /* SimpleHighlightReason.Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter((l) => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* SimpleHighlightReason.NonBasicASCII */:\n                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${strings.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of strings.InvisibleCharacters.codePoints) {\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n                    set.add(cp);\n                }\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character, wordContext) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* SimpleHighlightReason.NonBasicASCII */;\n        }\n        let hasBasicASCIICharacters = false;\n        let hasNonConfusableNonBasicAsciiCharacter = false;\n        if (wordContext) {\n            for (const char of wordContext) {\n                const codePoint = char.codePointAt(0);\n                const isBasicASCII = strings.isBasicASCII(char);\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n                if (!isBasicASCII &&\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\n                    !strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                    hasNonConfusableNonBasicAsciiCharacter = true;\n                }\n            }\n        }\n        if (\n        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.invisibleCharacters) {\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* SimpleHighlightReason.Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* SimpleHighlightReason.Ambiguous */;\n            }\n        }\n        return 0 /* SimpleHighlightReason.None */;\n    }\n}\nfunction isAllowedInvisibleCharacter(character) {\n    return character === ' ' || character === '\\n' || character === '\\t';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Sorted by original line ranges.\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n     */\n    moves, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    static ofLength(length) {\n        return new OffsetRange(0, length);\n    }\n    static ofStartAndLength(start, length) {\n        return new OffsetRange(start, start + length);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    deltaStart(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive);\n    }\n    deltaEnd(offset) {\n        return new OffsetRange(this.start, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n    intersects(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start < end;\n    }\n    isBefore(other) {\n        return this.endExclusive <= other.start;\n    }\n    isAfter(other) {\n        return this.start >= other.endExclusive;\n    }\n    slice(arr) {\n        return arr.slice(this.start, this.endExclusive);\n    }\n    substring(str) {\n        return str.substring(this.start, this.endExclusive);\n    }\n    /**\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n     * The range must not be empty.\n     */\n    clip(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    /**\n     * Returns `r := value + k * length` such that `r` is contained in this range.\n     * The range must not be empty.\n     *\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n     */\n    clipCyclic(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        if (value < this.start) {\n            return this.endExclusive - ((this.start - value) % this.length);\n        }\n        if (value >= this.endExclusive) {\n            return this.start + ((value - this.start) % this.length);\n        }\n        return value;\n    }\n    forEach(f) {\n        for (let i = this.start; i < this.endExclusive; i++) {\n            f(i);\n        }\n    }\n}\nexport class OffsetRangeSet {\n    constructor() {\n        this._sortedRanges = [];\n    }\n    addRange(range) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            this._sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, this._sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    toString() {\n        return this._sortedRanges.map(r => r.toString()).join(', ');\n    }\n    /**\n     * Returns of there is a value that is contained in this instance and the given range.\n     */\n    intersectsStrict(other) {\n        // TODO use binary search\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n            i++;\n        }\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n    intersectWithRange(other) {\n        // TODO use binary search + slice\n        const result = new OffsetRangeSet();\n        for (const range of this._sortedRanges) {\n            const intersection = range.intersect(other);\n            if (intersection) {\n                result.addRange(intersection);\n            }\n        }\n        return result;\n    }\n    intersectWithRangeLength(other) {\n        return this.intersectWithRange(other).length;\n    }\n    get length() {\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw new BugIndicatingError('lineRanges cannot be empty');\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    /**\n     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n    */\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nexport class LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n    static { this.zero = new TextLength(0, 0); }\n    static betweenPositions(position1, position2) {\n        if (position1.lineNumber === position2.lineNumber) {\n            return new TextLength(0, position2.column - position1.column);\n        }\n        else {\n            return new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n        }\n    }\n    static ofRange(range) {\n        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n    }\n    static ofText(text) {\n        let line = 0;\n        let column = 0;\n        for (const c of text) {\n            if (c === '\\n') {\n                line++;\n                column = 0;\n            }\n            else {\n                column++;\n            }\n        }\n        return new TextLength(line, column);\n    }\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    isGreaterThanOrEqualTo(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount >= other.columnCount;\n    }\n    createRange(startPosition) {\n        if (this.lineCount === 0) {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n        }\n        else {\n            return new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    addToPosition(position) {\n        if (this.lineCount === 0) {\n            return new Position(position.lineNumber, position.column + this.columnCount);\n        }\n        else {\n            return new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\n","import { OffsetRange } from './offsetRange.js';\nimport { TextLength } from './textLength.js';\nexport class PositionOffsetTransformer {\n    constructor(text) {\n        this.text = text;\n        this.lineStartOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n            }\n        }\n    }\n    getOffset(position) {\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n    }\n    getOffsetRange(range) {\n        return new OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));\n    }\n    get textLength() {\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n        return new TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\nexport class TextEdit {\n    constructor(edits) {\n        this.edits = edits;\n        assertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n    }\n    apply(text) {\n        let result = '';\n        let lastEditEnd = new Position(1, 1);\n        for (const edit of this.edits) {\n            const editRange = edit.range;\n            const editStart = editRange.getStartPosition();\n            const editEnd = editRange.getEndPosition();\n            const r = rangeFromPositions(lastEditEnd, editStart);\n            if (!r.isEmpty()) {\n                result += text.getValueOfRange(r);\n            }\n            result += edit.text;\n            lastEditEnd = editEnd;\n        }\n        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n        if (!r.isEmpty()) {\n            result += text.getValueOfRange(r);\n        }\n        return result;\n    }\n    applyToString(str) {\n        const strText = new StringText(str);\n        return this.apply(strText);\n    }\n    getNewRanges() {\n        const newRanges = [];\n        let previousEditEndLineNumber = 0;\n        let lineOffset = 0;\n        let columnOffset = 0;\n        for (const edit of this.edits) {\n            const textLength = TextLength.ofText(edit.text);\n            const newRangeStart = Position.lift({\n                lineNumber: edit.range.startLineNumber + lineOffset,\n                column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n            });\n            const newRange = textLength.createRange(newRangeStart);\n            newRanges.push(newRange);\n            lineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n            columnOffset = newRange.endColumn - edit.range.endColumn;\n            previousEditEndLineNumber = edit.range.endLineNumber;\n        }\n        return newRanges;\n    }\n}\nexport class SingleTextEdit {\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n    toSingleEditOperation() {\n        return {\n            range: this.range,\n            text: this.text,\n        };\n    }\n}\nfunction rangeFromPositions(start, end) {\n    if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n        return Range.fromPositions(end, end);\n    }\n    else if (!start.isBeforeOrEqual(end)) {\n        throw new BugIndicatingError('start must be before end');\n    }\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\nexport class AbstractText {\n    get endPositionExclusive() {\n        return this.length.addToPosition(new Position(1, 1));\n    }\n}\nexport class StringText extends AbstractText {\n    constructor(value) {\n        super();\n        this.value = value;\n        this._t = new PositionOffsetTransformer(this.value);\n    }\n    getValueOfRange(range) {\n        return this._t.getOffsetRange(range).substring(this.value);\n    }\n    get length() {\n        return this._t.textLength;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    static clip(mapping, originalRange, modifiedRange) {\n        const result = [];\n        for (const m of mapping) {\n            const original = m.original.intersect(originalRange);\n            const modified = m.modified.intersect(modifiedRange);\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\n                result.push(new LineRangeMapping(original, modified));\n            }\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping() {\n        const origInclusiveRange = this.original.toInclusiveRange();\n        const modInclusiveRange = this.modified.toInclusiveRange();\n        if (origInclusiveRange && modInclusiveRange) {\n            return new RangeMapping(origInclusiveRange, modInclusiveRange);\n        }\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n                // If one line range starts at 1, the other one must start at 1 as well.\n                throw new BugIndicatingError('not a valid diff');\n            }\n            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n            // Thus, `endLineNumberExclusive` is a valid line number.\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        else {\n            // We can assume here that both startLineNumbers are greater than 1.\n            return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n        }\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping2(original, modified) {\n        if (isValidLineNumber(this.original.endLineNumberExclusive, original)\n            && isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        if (!this.original.isEmpty && !this.modified.isEmpty) {\n            return new RangeMapping(Range.fromPositions(new Position(this.original.startLineNumber, 1), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(new Position(this.modified.startLineNumber, 1), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n        }\n        if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n            return new RangeMapping(Range.fromPositions(normalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(normalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n        }\n        // Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n        // I don't think this can happen.\n        throw new BugIndicatingError();\n    }\n}\nfunction normalizePosition(position, content) {\n    if (position.lineNumber < 1) {\n        return new Position(1, 1);\n    }\n    if (position.lineNumber > content.length) {\n        return new Position(content.length, content[content.length - 1].length + 1);\n    }\n    const line = content[position.lineNumber - 1];\n    if (position.column > line.length + 1) {\n        return new Position(position.lineNumber, line.length + 1);\n    }\n    return position;\n}\nfunction isValidLineNumber(lineNumber, lines) {\n    return lineNumber >= 1 && lineNumber <= lines.length;\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n    static fromRangeMappings(rangeMappings) {\n        const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n        const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        return new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n    }\n    withInnerChangesFromLineRanges() {\n        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    static assertSorted(rangeMappings) {\n        for (let i = 1; i < rangeMappings.length; i++) {\n            const previous = rangeMappings[i - 1];\n            const current = rangeMappings[i];\n            if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n                && previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {\n                throw new BugIndicatingError('Range mappings must be sorted');\n            }\n        }\n    }\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n    /**\n     * Creates a single text edit that describes the change from the original to the modified text.\n    */\n    toTextEdit(modified) {\n        const newText = modified.getValueOfRange(this.modifiedRange);\n        return new SingleTextEdit(this.originalRange, newText);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    static invert(sequenceDiffs, doc1Length) {\n        const result = [];\n        forEachAdjacent(sequenceDiffs, (a, b) => {\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\n        });\n        return result;\n    }\n    static fromOffsetPairs(start, endExclusive) {\n        return new SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n    }\n    static assertSorted(sequenceDiffs) {\n        let last = undefined;\n        for (const cur of sequenceDiffs) {\n            if (last) {\n                if (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n                    throw new BugIndicatingError('Sequence diffs must be sorted');\n                }\n            }\n            last = cur;\n        }\n    }\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    swap() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n    }\n    deltaStart(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n    }\n    deltaEnd(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n    }\n    intersect(other) {\n        const i1 = this.seq1Range.intersect(other.seq1Range);\n        const i2 = this.seq2Range.intersect(other.seq2Range);\n        if (!i1 || !i2) {\n            return undefined;\n        }\n        return new SequenceDiff(i1, i2);\n    }\n    getStarts() {\n        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n    }\n    getEndExclusives() {\n        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n    }\n}\nexport class OffsetPair {\n    static { this.zero = new OffsetPair(0, 0); }\n    static { this.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER); }\n    constructor(offset1, offset2) {\n        this.offset1 = offset1;\n        this.offset2 = offset2;\n    }\n    toString() {\n        return `${this.offset1} <-> ${this.offset2}`;\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n    }\n    equals(other) {\n        return this.offset1 === other.offset1 && this.offset2 === other.offset2;\n    }\n}\nexport class InfiniteTimeout {\n    static { this.instance = new InfiniteTimeout(); }\n    isValid() {\n        return true;\n    }\n}\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\nexport function isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nexport class LineRangeFragment {\n    static { this.chrKeys = new Map(); }\n    static getKey(chr) {\n        let key = this.chrKeys.get(chr);\n        if (key === undefined) {\n            key = this.chrKeys.size;\n            this.chrKeys.set(chr, key);\n        }\n        return key;\n    }\n    constructor(range, lines, source) {\n        this.range = range;\n        this.lines = lines;\n        this.source = source;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = LineRangeFragment.getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = LineRangeFragment.getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1; // Text on the x axis\n        const seqY = seq2; // Text on the y axis\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        // k=1 -> (1,0),(2,1)\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                let step = 0;\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n                step++;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                step++;\n                if (x > seqX.length || y > seqY.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n    constructor(lines, range, considerWhitespaceChanges) {\n        this.lines = lines;\n        this.range = range;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstElementOffsetByLineIdx = [];\n        this.lineStartOffsets = [];\n        this.trimmedWsLengthsByLineIdx = [];\n        this.firstElementOffsetByLineIdx.push(0);\n        for (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n            let line = lines[lineNumber - 1];\n            let lineStartOffset = 0;\n            if (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n                lineStartOffset = this.range.startColumn - 1;\n                line = line.substring(lineStartOffset);\n            }\n            this.lineStartOffsets.push(lineStartOffset);\n            let trimmedWsLength = 0;\n            if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                trimmedWsLength = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n            const lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n            for (let i = 0; i < lineLength; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            if (lineNumber < this.range.endLineNumber) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstElementOffsetByLineIdx.push(this.elements.length);\n            }\n        }\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // prefer the linebreak before the change\n            return 150;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset, preference = 'right') {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        const i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n        const lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n        return new Position(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i]));\n    }\n    translateRange(range) {\n        const pos1 = this.translateOffset(range.start, 'right');\n        const pos2 = this.translateOffset(range.endExclusive, 'left');\n        if (pos2.isBefore(pos1)) {\n            return Range.fromPositions(pos2, pos2);\n        }\n        return Range.fromPositions(pos1, pos2);\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        const start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n        const end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Separator */]: 30,\n    [6 /* CharBoundaryCategory.Space */]: 3,\n    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 8 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 7 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 6 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n        return 5 /* CharBoundaryCategory.Separator */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { Range } from '../../core/range.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n        const originalText = lines.join('\\n');\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction countWhere(arr, predicate) {\n    let count = 0;\n    for (const t of arr) {\n        if (predicate(t)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false), new LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    // Sometimes, calling this function twice improves the result.\n    // Uncomment the second invocation and run the tests to see the difference.\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n    const additional = [];\n    let lastPoint = new OffsetPair(0, 0);\n    function scanWord(pair, equalMapping) {\n        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n            return;\n        }\n        const w1 = sequence1.findWordContaining(pair.offset1);\n        const w2 = sequence2.findWordContaining(pair.offset2);\n        if (!w1 || !w2) {\n            return;\n        }\n        let w = new SequenceDiff(w1, w2);\n        const equalPart = w.intersect(equalMapping);\n        let equalChars1 = equalPart.seq1Range.length;\n        let equalChars2 = equalPart.seq2Range.length;\n        // The words do not touch previous equals mappings, as we would have processed them already.\n        // But they might touch the next ones.\n        while (equalMappings.length > 0) {\n            const next = equalMappings[0];\n            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n            if (!intersects) {\n                break;\n            }\n            const v1 = sequence1.findWordContaining(next.seq1Range.start);\n            const v2 = sequence2.findWordContaining(next.seq2Range.start);\n            // Because there is an intersection, we know that the words are not empty.\n            const v = new SequenceDiff(v1, v2);\n            const equalPart = v.intersect(next);\n            equalChars1 += equalPart.seq1Range.length;\n            equalChars2 += equalPart.seq2Range.length;\n            w = w.join(v);\n            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n                // The word extends beyond the next equal mapping.\n                equalMappings.shift();\n            }\n            else {\n                break;\n            }\n        }\n        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n            additional.push(w);\n        }\n        lastPoint = w.getEndExclusives();\n    }\n    while (equalMappings.length > 0) {\n        const next = equalMappings.shift();\n        if (next.seq1Range.isEmpty) {\n            continue;\n        }\n        scanWord(next.getStarts(), next);\n        // The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n        scanWord(next.getEndExclusives().delta(-1), next);\n    }\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n        }\n        else {\n            newDiffs.push(result);\n        }\n    });\n    return newDiffs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from '../rangeMapping.js';\nexport class DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return new LinesDiff([], [], false);\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return new LinesDiff([\n                new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                    new RangeMapping(new Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))\n                ])\n            ], [], false);\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(originalLinesHashes, originalLines);\n        const sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return new MovedText(m, mappings);\n        });\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const lineRangeMapping = toLineRangeMapping(diff);\n        const rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n        const slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        const check = false;\n        let diffs = diffResult.diffs;\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        if (check) {\n            SequenceDiff.assertSorted(diffs);\n        }\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        if (check) {\n            RangeMapping.assertSorted(result);\n        }\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine && changes.length > 0) {\n            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n                return false;\n            }\n            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction toLineRangeMapping(sequenceDiff) {\n    return new LineRangeMapping(new LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1), new LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    getLegacy: () => new LegacyLinesDiffComputer(),\n    getDefault: () => new DefaultLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color, HSLA } from '../../../base/common/color.js';\nfunction _parseCaptureGroups(captureGroups) {\n    const values = [];\n    for (const captureGroup of captureGroups) {\n        const parsedNumber = Number(captureGroup);\n        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n            values.push(parsedNumber);\n        }\n    }\n    return values;\n}\nfunction _toIColor(r, g, b, a) {\n    return {\n        red: r / 255,\n        blue: b / 255,\n        green: g / 255,\n        alpha: a\n    };\n}\nfunction _findRange(model, match) {\n    const index = match.index;\n    const length = match[0].length;\n    if (!index) {\n        return;\n    }\n    const startPosition = model.positionAt(index);\n    const range = {\n        startLineNumber: startPosition.lineNumber,\n        startColumn: startPosition.column,\n        endLineNumber: startPosition.lineNumber,\n        endColumn: startPosition.column + length\n    };\n    return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n    if (!range) {\n        return;\n    }\n    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n    if (!parsedHexColor) {\n        return;\n    }\n    return {\n        range: range,\n        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n    };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    return {\n        range: range,\n        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n    };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n    return {\n        range: range,\n        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n    };\n}\nfunction _findMatches(model, regex) {\n    if (typeof model === 'string') {\n        return [...model.matchAll(regex)];\n    }\n    else {\n        return model.findMatches(regex);\n    }\n}\nfunction computeColors(model) {\n    const result = [];\n    // Early validation for RGB and HSL\n    const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{3})\\b|(#)([A-Fa-f0-9]{4})\\b|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n    const initialValidationMatches = _findMatches(model, initialValidationRegex);\n    // Potential colors have been found, validate the parameters\n    if (initialValidationMatches.length > 0) {\n        for (const initialMatch of initialValidationMatches) {\n            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n            const colorScheme = initialCaptureGroups[1];\n            const colorParameters = initialCaptureGroups[2];\n            if (!colorParameters) {\n                continue;\n            }\n            let colorInformation;\n            if (colorScheme === 'rgb') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'rgba') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === 'hsl') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'hsla') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === '#') {\n                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n            }\n            if (colorInformation) {\n                result.push(colorInformation);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Returns an array of all default document colors in the provided document\n */\nexport function computeDefaultDocumentColors(model) {\n    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return computeColors(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst markRegex = new RegExp('\\\\bMARK:\\\\s*(.*)$', 'd');\nconst trimDashesRegex = /^-+|-+$/g;\n/**\n * Find section headers in the model.\n *\n * @param model the text model to search in\n * @param options options to search with\n * @returns an array of section headers\n */\nexport function findSectionHeaders(model, options) {\n    let headers = [];\n    if (options.findRegionSectionHeaders && options.foldingRules?.markers) {\n        const regionHeaders = collectRegionHeaders(model, options);\n        headers = headers.concat(regionHeaders);\n    }\n    if (options.findMarkSectionHeaders) {\n        const markHeaders = collectMarkHeaders(model);\n        headers = headers.concat(markHeaders);\n    }\n    return headers;\n}\nfunction collectRegionHeaders(model, options) {\n    const regionHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const match = lineContent.match(options.foldingRules.markers.start);\n        if (match) {\n            const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\n            if (range.endColumn > range.startColumn) {\n                const sectionHeader = {\n                    range,\n                    ...getHeaderText(lineContent.substring(match[0].length)),\n                    shouldBeInComments: false\n                };\n                if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                    regionHeaders.push(sectionHeader);\n                }\n            }\n        }\n    }\n    return regionHeaders;\n}\nfunction collectMarkHeaders(model) {\n    const markHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);\n    }\n    return markHeaders;\n}\nfunction addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {\n    markRegex.lastIndex = 0;\n    const match = markRegex.exec(lineContent);\n    if (match) {\n        const column = match.indices[1][0] + 1;\n        const endColumn = match.indices[1][1] + 1;\n        const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: endColumn };\n        if (range.endColumn > range.startColumn) {\n            const sectionHeader = {\n                range,\n                ...getHeaderText(match[1]),\n                shouldBeInComments: true\n            };\n            if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                sectionHeaders.push(sectionHeader);\n            }\n        }\n    }\n}\nfunction getHeaderText(text) {\n    text = text.trim();\n    const hasSeparatorLine = text.startsWith('-');\n    text = text.replace(trimDashesRegex, '');\n    return { text, hasSeparatorLine };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\nexport class PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    setValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, count) {\n        startIndex = toUint32(startIndex);\n        count = toUint32(count);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        const maxCount = oldValues.length - startIndex;\n        if (count >= maxCount) {\n            count = maxCount;\n        }\n        if (count === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - count);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalSum() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getPrefixSum(this.values.length - 1);\n    }\n    /**\n     * Returns the sum of the first `index + 1` many items.\n     * @returns `SUM(0 <= j <= index, values[j])`.\n     */\n    getPrefixSum(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getPrefixSum(index);\n    }\n    _getPrefixSum(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(sum) {\n        sum = Math.floor(sum);\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalSum();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (sum < midStart) {\n                high = mid - 1;\n            }\n            else if (sum >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\n    }\n}\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n    constructor(values) {\n        this._values = values;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._prefixSum = [];\n        this._indexBySum = [];\n    }\n    /**\n     * @returns SUM(0 <= j < values.length, values[j])\n     */\n    getTotalSum() {\n        this._ensureValid();\n        return this._indexBySum.length;\n    }\n    /**\n     * Returns the sum of the first `count` many items.\n     * @returns `SUM(0 <= j < count, values[j])`.\n     */\n    getPrefixSum(count) {\n        this._ensureValid();\n        if (count === 0) {\n            return 0;\n        }\n        return this._prefixSum[count - 1];\n    }\n    /**\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n     */\n    getIndexOf(sum) {\n        this._ensureValid();\n        const idx = this._indexBySum[sum];\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n    }\n    removeValues(start, deleteCount) {\n        this._values.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._values = arrayInsert(this._values, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n            const value = this._values[i];\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n            this._prefixSum[i] = sumAbove + value;\n            for (let j = 0; j < value; j++) {\n                this._indexBySum[sumAbove + j] = i;\n            }\n        }\n        // trim things\n        this._prefixSum.length = this._values.length;\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._values.length - 1;\n    }\n    setValue(index, value) {\n        if (this._values[index] === value) {\n            // no change\n            return;\n        }\n        this._values[index] = value;\n        this._invalidate(index);\n    }\n}\nexport class PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n        this._prefixSumIndexOfResultBrand = undefined;\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer } from '../../../../base/common/async.js';\nimport { Disposable, DisposableStore, dispose, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../../core/wordHelper.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../../model/mirrorTextModel.js';\n/**\n * Stop syncing a model to the worker if it was not needed for 1 min.\n */\nexport const STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;\nexport class WorkerTextModelSyncClient extends Disposable {\n    constructor(proxy, modelService, keepIdleModels = false) {\n        super();\n        this._syncedModels = Object.create(null);\n        this._syncedModelsLastUsedTime = Object.create(null);\n        this._proxy = proxy;\n        this._modelService = modelService;\n        if (!keepIdleModels) {\n            const timer = new IntervalTimer();\n            timer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));\n            this._register(timer);\n        }\n    }\n    dispose() {\n        for (const modelUrl in this._syncedModels) {\n            dispose(this._syncedModels[modelUrl]);\n        }\n        this._syncedModels = Object.create(null);\n        this._syncedModelsLastUsedTime = Object.create(null);\n        super.dispose();\n    }\n    ensureSyncedResources(resources, forceLargeModels = false) {\n        for (const resource of resources) {\n            const resourceStr = resource.toString();\n            if (!this._syncedModels[resourceStr]) {\n                this._beginModelSync(resource, forceLargeModels);\n            }\n            if (this._syncedModels[resourceStr]) {\n                this._syncedModelsLastUsedTime[resourceStr] = (new Date()).getTime();\n            }\n        }\n    }\n    _checkStopModelSync() {\n        const currentTime = (new Date()).getTime();\n        const toRemove = [];\n        for (const modelUrl in this._syncedModelsLastUsedTime) {\n            const elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];\n            if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {\n                toRemove.push(modelUrl);\n            }\n        }\n        for (const e of toRemove) {\n            this._stopModelSync(e);\n        }\n    }\n    _beginModelSync(resource, forceLargeModels) {\n        const model = this._modelService.getModel(resource);\n        if (!model) {\n            return;\n        }\n        if (!forceLargeModels && model.isTooLargeForSyncing()) {\n            return;\n        }\n        const modelUrl = resource.toString();\n        this._proxy.$acceptNewModel({\n            url: model.uri.toString(),\n            lines: model.getLinesContent(),\n            EOL: model.getEOL(),\n            versionId: model.getVersionId()\n        });\n        const toDispose = new DisposableStore();\n        toDispose.add(model.onDidChangeContent((e) => {\n            this._proxy.$acceptModelChanged(modelUrl.toString(), e);\n        }));\n        toDispose.add(model.onWillDispose(() => {\n            this._stopModelSync(modelUrl);\n        }));\n        toDispose.add(toDisposable(() => {\n            this._proxy.$acceptRemovedModel(modelUrl);\n        }));\n        this._syncedModels[modelUrl] = toDispose;\n    }\n    _stopModelSync(modelUrl) {\n        const toDispose = this._syncedModels[modelUrl];\n        delete this._syncedModels[modelUrl];\n        delete this._syncedModelsLastUsedTime[modelUrl];\n        dispose(toDispose);\n    }\n}\nexport class WorkerTextModelSyncServer {\n    constructor() {\n        this._models = Object.create(null);\n    }\n    getModel(uri) {\n        return this._models[uri];\n    }\n    getModels() {\n        const all = [];\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\n        return all;\n    }\n    $acceptNewModel(data) {\n        this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n    }\n    $acceptModelChanged(uri, e) {\n        if (!this._models[uri]) {\n            return;\n        }\n        const model = this._models[uri];\n        model.onEvents(e);\n    }\n    $acceptRemovedModel(uri) {\n        if (!this._models[uri]) {\n            return;\n        }\n        delete this._models[uri];\n    }\n}\nexport class MirrorModel extends BaseMirrorModel {\n    get uri() {\n        return this._uri;\n    }\n    get eol() {\n        return this._eol;\n    }\n    getValue() {\n        return this.getText();\n    }\n    findMatches(regex) {\n        const matches = [];\n        for (let i = 0; i < this._lines.length; i++) {\n            const line = this._lines[i];\n            const offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n            const iteratorOverMatches = line.matchAll(regex);\n            for (const match of iteratorOverMatches) {\n                if (match.index || match.index === 0) {\n                    match.index = match.index + offsetToAdd;\n                }\n                matches.push(match);\n            }\n        }\n        return matches;\n    }\n    getLinesContent() {\n        return this._lines.slice(0);\n    }\n    getLineCount() {\n        return this._lines.length;\n    }\n    getLineContent(lineNumber) {\n        return this._lines[lineNumber - 1];\n    }\n    getWordAtPosition(position, wordDefinition) {\n        const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n        }\n        return null;\n    }\n    words(wordDefinition) {\n        const lines = this._lines;\n        const wordenize = this._wordenize.bind(this);\n        let lineNumber = 0;\n        let lineText = '';\n        let wordRangesIdx = 0;\n        let wordRanges = [];\n        return {\n            *[Symbol.iterator]() {\n                while (true) {\n                    if (wordRangesIdx < wordRanges.length) {\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                        wordRangesIdx += 1;\n                        yield value;\n                    }\n                    else {\n                        if (lineNumber < lines.length) {\n                            lineText = lines[lineNumber];\n                            wordRanges = wordenize(lineText, wordDefinition);\n                            wordRangesIdx = 0;\n                            lineNumber += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    getLineWords(lineNumber, wordDefinition) {\n        const content = this._lines[lineNumber - 1];\n        const ranges = this._wordenize(content, wordDefinition);\n        const words = [];\n        for (const range of ranges) {\n            words.push({\n                word: content.substring(range.start, range.end),\n                startColumn: range.start + 1,\n                endColumn: range.end + 1\n            });\n        }\n        return words;\n    }\n    _wordenize(content, wordDefinition) {\n        const result = [];\n        let match;\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                // it did match the empty string\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    }\n    getValueInRange(range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        const lineEnding = this._eol;\n        const startLineIndex = range.startLineNumber - 1;\n        const endLineIndex = range.endLineNumber - 1;\n        const resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    }\n    offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n    }\n    positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        const out = this._lineStarts.getIndexOf(offset);\n        const lineLength = this._lines[out.index].length;\n        // Ensure we return a valid position\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    }\n    _validateRange(range) {\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    }\n    _validatePosition(position) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('bad position');\n        }\n        let { lineNumber, column } = position;\n        let hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            const maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber, column };\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { Range } from '../core/range.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { EditorWorkerHost } from './editorWorkerHost.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';\nimport { FileAccess } from '../../../base/common/network.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\nimport { findSectionHeaders } from './findSectionHeaders.js';\nimport { WorkerTextModelSyncServer } from './textModelSync/textModelSync.impl.js';\n// ESM-comment-begin\n// const isESM = false;\n// ESM-comment-end\n// ESM-uncomment-begin\nconst isESM = true;\n/**\n * @internal\n */\nexport class BaseEditorSimpleWorker {\n    constructor() {\n        this._workerTextModelSyncServer = new WorkerTextModelSyncServer();\n    }\n    dispose() {\n    }\n    _getModel(uri) {\n        return this._workerTextModelSyncServer.getModel(uri);\n    }\n    _getModels() {\n        return this._workerTextModelSyncServer.getModels();\n    }\n    $acceptNewModel(data) {\n        this._workerTextModelSyncServer.$acceptNewModel(data);\n    }\n    $acceptModelChanged(uri, e) {\n        this._workerTextModelSyncServer.$acceptModelChanged(uri, e);\n    }\n    $acceptRemovedModel(uri) {\n        this._workerTextModelSyncServer.$acceptRemovedModel(uri);\n    }\n    async $computeUnicodeHighlights(url, options, range) {\n        const model = this._getModel(url);\n        if (!model) {\n            return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n        }\n        return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n    }\n    async $findSectionHeaders(url, options) {\n        const model = this._getModel(url);\n        if (!model) {\n            return [];\n        }\n        return findSectionHeaders(model, options);\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    async $computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n        const original = this._getModel(originalUrl);\n        const modified = this._getModel(modifiedUrl);\n        if (!original || !modified) {\n            return null;\n        }\n        const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n        return result;\n    }\n    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n        const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n        const originalLines = originalTextModel.getLinesContent();\n        const modifiedLines = modifiedTextModel.getLinesContent();\n        const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n        const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n        function getLineChanges(changes) {\n            return changes.map(m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [\n                    m.originalRange.startLineNumber,\n                    m.originalRange.startColumn,\n                    m.originalRange.endLineNumber,\n                    m.originalRange.endColumn,\n                    m.modifiedRange.startLineNumber,\n                    m.modifiedRange.startColumn,\n                    m.modifiedRange.endLineNumber,\n                    m.modifiedRange.endColumn,\n                ])]));\n        }\n        return {\n            identical,\n            quitEarly: result.hitTimeout,\n            changes: getLineChanges(result.changes),\n            moves: result.moves.map(m => ([\n                m.lineRangeMapping.original.startLineNumber,\n                m.lineRangeMapping.original.endLineNumberExclusive,\n                m.lineRangeMapping.modified.startLineNumber,\n                m.lineRangeMapping.modified.endLineNumberExclusive,\n                getLineChanges(m.changes)\n            ])),\n        };\n    }\n    static _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // ---- END diff --------------------------------------------------------------------------\n    // ---- BEGIN minimal edits ---------------------------------------------------------------\n    static { this._diffLimit = 100000; }\n    async $computeMoreMinimalEdits(modelUrl, edits, pretty) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return edits;\n        }\n        const result = [];\n        let lastEol = undefined;\n        edits = edits.slice(0).sort((a, b) => {\n            if (a.range && b.range) {\n                return Range.compareRangesUsingStarts(a.range, b.range);\n            }\n            // eol only changes should go to the end\n            const aRng = a.range ? 0 : 1;\n            const bRng = b.range ? 0 : 1;\n            return aRng - bRng;\n        });\n        // merge adjacent edits\n        let writeIndex = 0;\n        for (let readIndex = 1; readIndex < edits.length; readIndex++) {\n            if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n                edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n                edits[writeIndex].text += edits[readIndex].text;\n            }\n            else {\n                writeIndex++;\n                edits[writeIndex] = edits[readIndex];\n            }\n        }\n        edits.length = writeIndex + 1;\n        for (let { range, text, eol } of edits) {\n            if (typeof eol === 'number') {\n                lastEol = eol;\n            }\n            if (Range.isEmpty(range) && !text) {\n                // empty change\n                continue;\n            }\n            const original = model.getValueInRange(range);\n            text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n            if (original === text) {\n                // noop\n                continue;\n            }\n            // make sure diff won't take too long\n            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                result.push({ range, text });\n                continue;\n            }\n            // compute diff between original and edit.text\n            const changes = stringDiff(original, text, pretty);\n            const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n            for (const change of changes) {\n                const start = model.positionAt(editOffset + change.originalStart);\n                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                const newEdit = {\n                    text: text.substr(change.modifiedStart, change.modifiedLength),\n                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                };\n                if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                    result.push(newEdit);\n                }\n            }\n        }\n        if (typeof lastEol === 'number') {\n            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n        }\n        return result;\n    }\n    // ---- END minimal edits ---------------------------------------------------------------\n    async $computeLinks(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeLinks(model);\n    }\n    // --- BEGIN default document colors -----------------------------------------------------------\n    async $computeDefaultDocumentColors(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeDefaultDocumentColors(model);\n    }\n    // ---- BEGIN suggest --------------------------------------------------------------------------\n    static { this._suggestionsLimit = 10000; }\n    async $textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n        const sw = new StopWatch();\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        const seen = new Set();\n        outer: for (const url of modelUrls) {\n            const model = this._getModel(url);\n            if (!model) {\n                continue;\n            }\n            for (const word of model.words(wordDefRegExp)) {\n                if (word === leadingWord || !isNaN(Number(word))) {\n                    continue;\n                }\n                seen.add(word);\n                if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                    break outer;\n                }\n            }\n        }\n        return { words: Array.from(seen), duration: sw.elapsed() };\n    }\n    // ---- END suggest --------------------------------------------------------------------------\n    //#region -- word ranges --\n    async $computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return Object.create(null);\n        }\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        const result = Object.create(null);\n        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n            const words = model.getLineWords(line, wordDefRegExp);\n            for (const word of words) {\n                if (!isNaN(Number(word.word))) {\n                    continue;\n                }\n                let array = result[word.word];\n                if (!array) {\n                    array = [];\n                    result[word.word] = array;\n                }\n                array.push({\n                    startLineNumber: line,\n                    startColumn: word.startColumn,\n                    endLineNumber: line,\n                    endColumn: word.endColumn\n                });\n            }\n        }\n        return result;\n    }\n    //#endregion\n    async $navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        if (range.startColumn === range.endColumn) {\n            range = {\n                startLineNumber: range.startLineNumber,\n                startColumn: range.startColumn,\n                endLineNumber: range.endLineNumber,\n                endColumn: range.endColumn + 1\n            };\n        }\n        const selectionText = model.getValueInRange(range);\n        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n        if (!wordRange) {\n            return null;\n        }\n        const word = model.getValueInRange(wordRange);\n        const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n        return result;\n    }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker extends BaseEditorSimpleWorker {\n    constructor(_host, _foreignModuleFactory) {\n        super();\n        this._host = _host;\n        this._foreignModuleFactory = _foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    async $ping() {\n        return 'pong';\n    }\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    $loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.$fhr(method, args);\n        };\n        const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n        const ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            return Promise.resolve(getAllMethodNames(this._foreignModule));\n        }\n        return new Promise((resolve, reject) => {\n            const onModuleCallback = (foreignModule) => {\n                this._foreignModule = foreignModule.create(ctx, createData);\n                resolve(getAllMethodNames(this._foreignModule));\n            };\n            if (!isESM) {\n                require([`${moduleId}`], onModuleCallback, reject);\n            }\n            else {\n                const url = FileAccess.asBrowserUri(`${moduleId}.js`).toString(true);\n                import(`${url}`).then(onModuleCallback).catch(reject);\n            }\n        });\n    }\n    // foreign method request\n    $fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\n/**\n * Defines the worker entry point. Must be exported and named `create`.\n * @skipMangle\n * @internal\n */\nexport function create(workerServer) {\n    return new EditorSimpleWorker(EditorWorkerHost.getChannel(workerServer), null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    globalThis.monaco = createMonacoBaseAPI();\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');\nexport const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageFeaturesService = createDecorator('ILanguageFeaturesService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { doHash } from '../../../base/common/hash.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { clamp, MovingAverage, SlidingWindowAverage } from '../../../base/common/numbers.js';\nimport { IEnvironmentService } from '../../../platform/environment/common/environment.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { matchesScheme } from '../../../base/common/network.js';\nexport const ILanguageFeatureDebounceService = createDecorator('ILanguageFeatureDebounceService');\nvar IdentityHash;\n(function (IdentityHash) {\n    const _hashes = new WeakMap();\n    let pool = 0;\n    function of(obj) {\n        let value = _hashes.get(obj);\n        if (value === undefined) {\n            value = ++pool;\n            _hashes.set(obj, value);\n        }\n        return value;\n    }\n    IdentityHash.of = of;\n})(IdentityHash || (IdentityHash = {}));\nclass NullDebounceInformation {\n    constructor(_default) {\n        this._default = _default;\n    }\n    get(_model) {\n        return this._default;\n    }\n    update(_model, _value) {\n        return this._default;\n    }\n    default() {\n        return this._default;\n    }\n}\nclass FeatureDebounceInformation {\n    constructor(_logService, _name, _registry, _default, _min, _max) {\n        this._logService = _logService;\n        this._name = _name;\n        this._registry = _registry;\n        this._default = _default;\n        this._min = _min;\n        this._max = _max;\n        this._cache = new LRUCache(50, 0.7);\n    }\n    _key(model) {\n        return model.id + this._registry.all(model).reduce((hashVal, obj) => doHash(IdentityHash.of(obj), hashVal), 0);\n    }\n    get(model) {\n        const key = this._key(model);\n        const avg = this._cache.get(key);\n        return avg\n            ? clamp(avg.value, this._min, this._max)\n            : this.default();\n    }\n    update(model, value) {\n        const key = this._key(model);\n        let avg = this._cache.get(key);\n        if (!avg) {\n            avg = new SlidingWindowAverage(6);\n            this._cache.set(key, avg);\n        }\n        const newValue = clamp(avg.update(value), this._min, this._max);\n        if (!matchesScheme(model.uri, 'output')) {\n            this._logService.trace(`[DEBOUNCE: ${this._name}] for ${model.uri.toString()} is ${newValue}ms`);\n        }\n        return newValue;\n    }\n    _overall() {\n        const result = new MovingAverage();\n        for (const [, avg] of this._cache) {\n            result.update(avg.value);\n        }\n        return result.value;\n    }\n    default() {\n        const value = (this._overall() | 0) || this._default;\n        return clamp(value, this._min, this._max);\n    }\n}\nlet LanguageFeatureDebounceService = class LanguageFeatureDebounceService {\n    constructor(_logService, envService) {\n        this._logService = _logService;\n        this._data = new Map();\n        this._isDev = envService.isExtensionDevelopment || !envService.isBuilt;\n    }\n    for(feature, name, config) {\n        const min = config?.min ?? 50;\n        const max = config?.max ?? min ** 2;\n        const extra = config?.key ?? undefined;\n        const key = `${IdentityHash.of(feature)},${min}${extra ? ',' + extra : ''}`;\n        let info = this._data.get(key);\n        if (!info) {\n            if (this._isDev) {\n                this._logService.debug(`[DEBOUNCE: ${name}] is disabled in developed mode`);\n                info = new NullDebounceInformation(min * 1.5);\n            }\n            else {\n                info = new FeatureDebounceInformation(this._logService, name, feature, (this._overallAverage() | 0) || (min * 1.5), // default is overall default or derived from min-value\n                min, max);\n            }\n            this._data.set(key, info);\n        }\n        return info;\n    }\n    _overallAverage() {\n        // Average of all language features. Not a great value but an approximation\n        const result = new MovingAverage();\n        for (const info of this._data.values()) {\n            result.update(info.default());\n        }\n        return result.value;\n    }\n};\nLanguageFeatureDebounceService = __decorate([\n    __param(0, ILogService),\n    __param(1, IEnvironmentService)\n], LanguageFeatureDebounceService);\nexport { LanguageFeatureDebounceService };\nregisterSingleton(ILanguageFeatureDebounceService, LanguageFeatureDebounceService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves to continue right after the deletion\n                    tokenDeltaLine = startDeltaLine;\n                    tokenStartCharacter = startCharacter;\n                    tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* CharCode.Digit0 */ && firstCharCode <= 57 /* CharCode.Digit9 */)\n                || (firstCharCode >= 65 /* CharCode.A */ && firstCharCode <= 90 /* CharCode.Z */)\n                || (firstCharCode >= 97 /* CharCode.a */ && firstCharCode <= 122 /* CharCode.z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from '../languages/language.js';\nconst ENABLE_TRACE = false;\nlet SemanticTokensProviderStyling = class SemanticTokensProviderStyling {\n    constructor(_legend, _themeService, _languageService, _logService) {\n        this._legend = _legend;\n        this._themeService = _themeService;\n        this._languageService = _languageService;\n        this._logService = _logService;\n        this._hasWarnedOverlappingTokens = false;\n        this._hasWarnedInvalidLengthTokens = false;\n        this._hasWarnedInvalidEditStart = false;\n        this._hashTable = new HashTable();\n    }\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n        const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n        let metadata;\n        if (entry) {\n            metadata = entry.metadata;\n            if (ENABLE_TRACE && this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        else {\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n            const tokenModifiers = [];\n            if (tokenType) {\n                let modifierSet = tokenModifierSet;\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n                    if (modifierSet & 1) {\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n                    }\n                    modifierSet = modifierSet >> 1;\n                }\n                if (ENABLE_TRACE && modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n                    tokenModifiers.push('not-in-legend');\n                }\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n                if (typeof tokenStyle === 'undefined') {\n                    metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                }\n                else {\n                    metadata = 0;\n                    if (typeof tokenStyle.italic !== 'undefined') {\n                        const italicBit = (tokenStyle.italic ? 1 /* FontStyle.Italic */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= italicBit | 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */;\n                    }\n                    if (typeof tokenStyle.bold !== 'undefined') {\n                        const boldBit = (tokenStyle.bold ? 2 /* FontStyle.Bold */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= boldBit | 2 /* MetadataConsts.SEMANTIC_USE_BOLD */;\n                    }\n                    if (typeof tokenStyle.underline !== 'undefined') {\n                        const underlineBit = (tokenStyle.underline ? 4 /* FontStyle.Underline */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= underlineBit | 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */;\n                    }\n                    if (typeof tokenStyle.strikethrough !== 'undefined') {\n                        const strikethroughBit = (tokenStyle.strikethrough ? 8 /* FontStyle.Strikethrough */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= strikethroughBit | 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */;\n                    }\n                    if (tokenStyle.foreground) {\n                        const foregroundBits = (tokenStyle.foreground) << 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n                        metadata |= foregroundBits | 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */;\n                    }\n                    if (metadata === 0) {\n                        // Nothing!\n                        metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                    }\n                }\n            }\n            else {\n                if (ENABLE_TRACE && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n                }\n                metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                tokenType = 'not-in-legend';\n            }\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n            if (ENABLE_TRACE && this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        return metadata;\n    }\n    warnOverlappingSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedOverlappingTokens) {\n            this._hasWarnedOverlappingTokens = true;\n            this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidLengthSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedInvalidLengthTokens) {\n            this._hasWarnedInvalidLengthTokens = true;\n            this._logService.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {\n        if (!this._hasWarnedInvalidEditStart) {\n            this._hasWarnedInvalidEditStart = true;\n            this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);\n        }\n    }\n};\nSemanticTokensProviderStyling = __decorate([\n    __param(1, IThemeService),\n    __param(2, ILanguageService),\n    __param(3, ILogService)\n], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n    const srcData = tokens.data;\n    const tokenCount = (tokens.data.length / 5) | 0;\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* SemanticColoringConstants.DesiredMaxAreas */), 400 /* SemanticColoringConstants.DesiredTokensPerArea */);\n    const result = [];\n    let tokenIndex = 0;\n    let lastLineNumber = 1;\n    let lastStartCharacter = 0;\n    while (tokenIndex < tokenCount) {\n        const tokenStartIndex = tokenIndex;\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n        // Keep tokens on the same line in the same area...\n        if (tokenEndIndex < tokenCount) {\n            let smallTokenEndIndex = tokenEndIndex;\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n                smallTokenEndIndex--;\n            }\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\n                // there are so many tokens on this line that our area would be empty, we must now go right\n                let bigTokenEndIndex = tokenEndIndex;\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n                    bigTokenEndIndex++;\n                }\n                tokenEndIndex = bigTokenEndIndex;\n            }\n            else {\n                tokenEndIndex = smallTokenEndIndex;\n            }\n        }\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n        let destOffset = 0;\n        let areaLine = 0;\n        let prevLineNumber = 0;\n        let prevEndCharacter = 0;\n        while (tokenIndex < tokenEndIndex) {\n            const srcOffset = 5 * tokenIndex;\n            const deltaLine = srcData[srcOffset];\n            const deltaCharacter = srcData[srcOffset + 1];\n            // Casting both `lineNumber`, `startCharacter` and `endCharacter` here to uint32 using `|0`\n            // to validate below with the actual values that will be inserted in the Uint32Array result\n            const lineNumber = (lastLineNumber + deltaLine) | 0;\n            const startCharacter = (deltaLine === 0 ? (lastStartCharacter + deltaCharacter) | 0 : deltaCharacter);\n            const length = srcData[srcOffset + 2];\n            const endCharacter = (startCharacter + length) | 0;\n            const tokenTypeIndex = srcData[srcOffset + 3];\n            const tokenModifierSet = srcData[srcOffset + 4];\n            if (endCharacter <= startCharacter) {\n                // this token is invalid (most likely a negative length casted to uint32)\n                styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n                // this token overlaps with the previous token\n                styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else {\n                const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n                if (metadata !== 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */) {\n                    if (areaLine === 0) {\n                        areaLine = lineNumber;\n                    }\n                    destData[destOffset] = lineNumber - areaLine;\n                    destData[destOffset + 1] = startCharacter;\n                    destData[destOffset + 2] = endCharacter;\n                    destData[destOffset + 3] = metadata;\n                    destOffset += 4;\n                    prevLineNumber = lineNumber;\n                    prevEndCharacter = endCharacter;\n                }\n            }\n            lastLineNumber = lineNumber;\n            lastStartCharacter = startCharacter;\n            tokenIndex++;\n        }\n        if (destOffset !== destData.length) {\n            destData = destData.subarray(0, destOffset);\n        }\n        const tokens = SparseMultilineTokens.create(areaLine, destData);\n        result.push(tokens);\n    }\n    return result;\n}\nclass HashTableEntry {\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this.tokenTypeIndex = tokenTypeIndex;\n        this.tokenModifierSet = tokenModifierSet;\n        this.languageId = languageId;\n        this.metadata = metadata;\n        this.next = null;\n    }\n}\nclass HashTable {\n    static { this._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143]; }\n    constructor() {\n        this._elementsCount = 0;\n        this._currentLengthIndex = 0;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n    }\n    static _nullOutEntries(entries, length) {\n        for (let i = 0; i < length; i++) {\n            entries[i] = null;\n        }\n    }\n    _hash2(n1, n2) {\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\n    }\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n        let p = this._elements[hash];\n        while (p) {\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n                return p;\n            }\n            p = p.next;\n        }\n        return null;\n    }\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this._elementsCount++;\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n            // expand!\n            const oldElements = this._elements;\n            this._currentLengthIndex++;\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n            this._elements = [];\n            HashTable._nullOutEntries(this._elements, this._currentLength);\n            for (const first of oldElements) {\n                let p = first;\n                while (p) {\n                    const oldNext = p.next;\n                    p.next = null;\n                    this._add(p);\n                    p = oldNext;\n                }\n            }\n        }\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n    _add(element) {\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n        element.next = this._elements[hash];\n        this._elements[hash] = element;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ISemanticTokensStylingService = createDecorator('semanticTokensStylingService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { SemanticTokensProviderStyling } from './semanticTokensProviderStyling.js';\nimport { ISemanticTokensStylingService } from './semanticTokensStyling.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nlet SemanticTokensStylingService = class SemanticTokensStylingService extends Disposable {\n    constructor(_themeService, _logService, _languageService) {\n        super();\n        this._themeService = _themeService;\n        this._logService = _logService;\n        this._languageService = _languageService;\n        this._caches = new WeakMap();\n        this._register(this._themeService.onDidColorThemeChange(() => {\n            this._caches = new WeakMap();\n        }));\n    }\n    getStyling(provider) {\n        if (!this._caches.has(provider)) {\n            this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._languageService, this._logService));\n        }\n        return this._caches.get(provider);\n    }\n};\nSemanticTokensStylingService = __decorate([\n    __param(0, IThemeService),\n    __param(1, ILogService),\n    __param(2, ILanguageService)\n], SemanticTokensStylingService);\nexport { SemanticTokensStylingService };\nregisterSingleton(ISemanticTokensStylingService, SemanticTokensStylingService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        // selector targets a notebook -> use the notebook uri instead\n        // of the \"normal\" document uri.\n        if (notebookType && candidateNotebookUri) {\n            candidateUri = candidateNotebookUri;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*' && candidateNotebookType !== undefined) {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = { ...pattern, base: normalize(pattern.base) };\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType, recursive) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n        this.recursive = recursive;\n    }\n    equals(other) {\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && this.notebookUri?.toString() === other.notebookUri?.toString()\n            && this.recursive === other.recursive;\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model, false);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model, recursive = false) {\n        const result = [];\n        this._orderedForEach(model, recursive, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, false, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, recursive, callback) {\n        this._updateScores(model, recursive);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model, recursive) {\n        const notebookInfo = this._notebookInfoResolver?.(model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type, recursive)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined, recursive);\n        if (this._lastCandidate?.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                if (recursive) {\n                    entry._score = 0;\n                }\n                else {\n                    // support for one exclusive selector that overwrites\n                    // any other selector\n                    for (const entry of this._entries) {\n                        entry._score = 0;\n                    }\n                    entry._score = 1000;\n                    break;\n                }\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        // De-prioritize built-in providers\n        if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n            return 1;\n        }\n        else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n            return -1;\n        }\n        if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction isBuiltinSelector(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    if (Array.isArray(selector)) {\n        return selector.some(isBuiltinSelector);\n    }\n    return Boolean(selector.isBuiltin);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageFeatureRegistry } from '../languageFeatureRegistry.js';\nimport { ILanguageFeaturesService } from './languageFeatures.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageFeaturesService {\n    constructor() {\n        this.referenceProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.renameProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.newSymbolNamesProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.codeActionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.definitionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.typeDefinitionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.declarationProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.implementationProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentSymbolProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.inlayHintsProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.colorProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.codeLensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentRangeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.onTypeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.signatureHelpProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.hoverProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.multiDocumentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.selectionRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.foldingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.linkProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.inlineCompletionsProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.inlineEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.completionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.linkedEditingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentRangeSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentDropEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentPasteEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n    }\n    _score(uri) {\n        return this._notebookTypeResolver?.(uri);\n    }\n}\nregisterSingleton(ILanguageFeaturesService, LanguageFeaturesService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)\n};\nexport async function tokenizeToString(languageService, text, languageId) {\n    if (!languageId) {\n        return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n    }\n    const tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);\n    return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* CharCode.Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* CharCode.LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* CharCode.Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* CharCode.UTF8_BOM */:\n                case 8232 /* CharCode.LINE_SEPARATOR */:\n                case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                case 133 /* CharCode.NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CharCode.CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* CharCode.Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const diffEditorDefaultOptions = {\n    enableSplitViewResizing: true,\n    splitViewDefaultRatio: 0.5,\n    renderSideBySide: true,\n    renderMarginRevertIcon: true,\n    renderGutterMenu: true,\n    maxComputationTime: 5000,\n    maxFileSize: 50,\n    ignoreTrimWhitespace: true,\n    renderIndicators: true,\n    originalEditable: false,\n    diffCodeLens: false,\n    renderOverviewRuler: true,\n    diffWordWrap: 'inherit',\n    diffAlgorithm: 'advanced',\n    accessibilityVerbose: false,\n    experimental: {\n        showMoves: false,\n        showEmptyDecorations: true,\n        useTrueInlineView: false,\n    },\n    hideUnchangedRegions: {\n        enabled: false,\n        contextLineCount: 3,\n        minimumLineCount: 3,\n        revealLineCount: 20,\n    },\n    isInEmbeddedEditor: false,\n    onlyShowAccessibleDiffViewer: false,\n    renderSideBySideInlineBreakpoint: 900,\n    useInlineViewWhenSpaceIsLimited: true,\n    compactMode: false,\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { diffEditorDefaultOptions } from './diffEditor.js';\nimport { editorOptionsRegistry } from './editorOptions.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport * as nls from '../../../nls.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nexport const editorConfigurationBaseNode = Object.freeze({\n    id: 'editor',\n    order: 5,\n    type: 'object',\n    title: nls.localize('editorConfigurationTitle', \"Editor\"),\n    scope: 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */,\n});\nconst editorConfiguration = {\n    ...editorConfigurationBaseNode,\n    properties: {\n        'editor.tabSize': {\n            type: 'number',\n            default: EDITOR_MODEL_DEFAULTS.tabSize,\n            minimum: 1,\n            markdownDescription: nls.localize('tabSize', \"The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.\", '`#editor.detectIndentation#`')\n        },\n        'editor.indentSize': {\n            'anyOf': [\n                {\n                    type: 'string',\n                    enum: ['tabSize']\n                },\n                {\n                    type: 'number',\n                    minimum: 1\n                }\n            ],\n            default: 'tabSize',\n            markdownDescription: nls.localize('indentSize', \"The number of spaces used for indentation or `\\\"tabSize\\\"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.\")\n        },\n        'editor.insertSpaces': {\n            type: 'boolean',\n            default: EDITOR_MODEL_DEFAULTS.insertSpaces,\n            markdownDescription: nls.localize('insertSpaces', \"Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.\", '`#editor.detectIndentation#`')\n        },\n        'editor.detectIndentation': {\n            type: 'boolean',\n            default: EDITOR_MODEL_DEFAULTS.detectIndentation,\n            markdownDescription: nls.localize('detectIndentation', \"Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.\", '`#editor.tabSize#`', '`#editor.insertSpaces#`')\n        },\n        'editor.trimAutoWhitespace': {\n            type: 'boolean',\n            default: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n            description: nls.localize('trimAutoWhitespace', \"Remove trailing auto inserted whitespace.\")\n        },\n        'editor.largeFileOptimizations': {\n            type: 'boolean',\n            default: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n            description: nls.localize('largeFileOptimizations', \"Special handling for large files to disable certain memory intensive features.\")\n        },\n        'editor.wordBasedSuggestions': {\n            enum: ['off', 'currentDocument', 'matchingDocuments', 'allDocuments'],\n            default: 'matchingDocuments',\n            enumDescriptions: [\n                nls.localize('wordBasedSuggestions.off', 'Turn off Word Based Suggestions.'),\n                nls.localize('wordBasedSuggestions.currentDocument', 'Only suggest words from the active document.'),\n                nls.localize('wordBasedSuggestions.matchingDocuments', 'Suggest words from all open documents of the same language.'),\n                nls.localize('wordBasedSuggestions.allDocuments', 'Suggest words from all open documents.')\n            ],\n            description: nls.localize('wordBasedSuggestions', \"Controls whether completions should be computed based on words in the document and from which documents they are computed.\")\n        },\n        'editor.semanticHighlighting.enabled': {\n            enum: [true, false, 'configuredByTheme'],\n            enumDescriptions: [\n                nls.localize('semanticHighlighting.true', 'Semantic highlighting enabled for all color themes.'),\n                nls.localize('semanticHighlighting.false', 'Semantic highlighting disabled for all color themes.'),\n                nls.localize('semanticHighlighting.configuredByTheme', 'Semantic highlighting is configured by the current color theme\\'s `semanticHighlighting` setting.')\n            ],\n            default: 'configuredByTheme',\n            description: nls.localize('semanticHighlighting.enabled', \"Controls whether the semanticHighlighting is shown for the languages that support it.\")\n        },\n        'editor.stablePeek': {\n            type: 'boolean',\n            default: false,\n            markdownDescription: nls.localize('stablePeek', \"Keep peek editors open even when double-clicking their content or when hitting `Escape`.\")\n        },\n        'editor.maxTokenizationLineLength': {\n            type: 'integer',\n            default: 20_000,\n            description: nls.localize('maxTokenizationLineLength', \"Lines above this length will not be tokenized for performance reasons\")\n        },\n        'editor.experimental.asyncTokenization': {\n            type: 'boolean',\n            default: true,\n            description: nls.localize('editor.experimental.asyncTokenization', \"Controls whether the tokenization should happen asynchronously on a web worker.\"),\n            tags: ['experimental'],\n        },\n        'editor.experimental.asyncTokenizationLogging': {\n            type: 'boolean',\n            default: false,\n            description: nls.localize('editor.experimental.asyncTokenizationLogging', \"Controls whether async tokenization should be logged. For debugging only.\"),\n        },\n        'editor.experimental.asyncTokenizationVerification': {\n            type: 'boolean',\n            default: false,\n            description: nls.localize('editor.experimental.asyncTokenizationVerification', \"Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only.\"),\n            tags: ['experimental'],\n        },\n        'editor.experimental.treeSitterTelemetry': {\n            type: 'boolean',\n            default: false,\n            markdownDescription: nls.localize('editor.experimental.treeSitterTelemetry', \"Controls whether tree sitter parsing should be turned on and telemetry collected. Setting `editor.experimental.preferTreeSitter` for specific languages will take precedence.\"),\n            tags: ['experimental']\n        },\n        'editor.language.brackets': {\n            type: ['array', 'null'],\n            default: null, // We want to distinguish the empty array from not configured.\n            description: nls.localize('schema.brackets', 'Defines the bracket symbols that increase or decrease the indentation.'),\n            items: {\n                type: 'array',\n                items: [\n                    {\n                        type: 'string',\n                        description: nls.localize('schema.openBracket', 'The opening bracket character or string sequence.')\n                    },\n                    {\n                        type: 'string',\n                        description: nls.localize('schema.closeBracket', 'The closing bracket character or string sequence.')\n                    }\n                ]\n            }\n        },\n        'editor.language.colorizedBracketPairs': {\n            type: ['array', 'null'],\n            default: null, // We want to distinguish the empty array from not configured.\n            description: nls.localize('schema.colorizedBracketPairs', 'Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled.'),\n            items: {\n                type: 'array',\n                items: [\n                    {\n                        type: 'string',\n                        description: nls.localize('schema.openBracket', 'The opening bracket character or string sequence.')\n                    },\n                    {\n                        type: 'string',\n                        description: nls.localize('schema.closeBracket', 'The closing bracket character or string sequence.')\n                    }\n                ]\n            }\n        },\n        'diffEditor.maxComputationTime': {\n            type: 'number',\n            default: diffEditorDefaultOptions.maxComputationTime,\n            description: nls.localize('maxComputationTime', \"Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.\")\n        },\n        'diffEditor.maxFileSize': {\n            type: 'number',\n            default: diffEditorDefaultOptions.maxFileSize,\n            description: nls.localize('maxFileSize', \"Maximum file size in MB for which to compute diffs. Use 0 for no limit.\")\n        },\n        'diffEditor.renderSideBySide': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.renderSideBySide,\n            description: nls.localize('sideBySide', \"Controls whether the diff editor shows the diff side by side or inline.\")\n        },\n        'diffEditor.renderSideBySideInlineBreakpoint': {\n            type: 'number',\n            default: diffEditorDefaultOptions.renderSideBySideInlineBreakpoint,\n            description: nls.localize('renderSideBySideInlineBreakpoint', \"If the diff editor width is smaller than this value, the inline view is used.\")\n        },\n        'diffEditor.useInlineViewWhenSpaceIsLimited': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.useInlineViewWhenSpaceIsLimited,\n            description: nls.localize('useInlineViewWhenSpaceIsLimited', \"If enabled and the editor width is too small, the inline view is used.\")\n        },\n        'diffEditor.renderMarginRevertIcon': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.renderMarginRevertIcon,\n            description: nls.localize('renderMarginRevertIcon', \"When enabled, the diff editor shows arrows in its glyph margin to revert changes.\")\n        },\n        'diffEditor.renderGutterMenu': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.renderGutterMenu,\n            description: nls.localize('renderGutterMenu', \"When enabled, the diff editor shows a special gutter for revert and stage actions.\")\n        },\n        'diffEditor.ignoreTrimWhitespace': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.ignoreTrimWhitespace,\n            description: nls.localize('ignoreTrimWhitespace', \"When enabled, the diff editor ignores changes in leading or trailing whitespace.\")\n        },\n        'diffEditor.renderIndicators': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.renderIndicators,\n            description: nls.localize('renderIndicators', \"Controls whether the diff editor shows +/- indicators for added/removed changes.\")\n        },\n        'diffEditor.codeLens': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.diffCodeLens,\n            description: nls.localize('codeLens', \"Controls whether the editor shows CodeLens.\")\n        },\n        'diffEditor.wordWrap': {\n            type: 'string',\n            enum: ['off', 'on', 'inherit'],\n            default: diffEditorDefaultOptions.diffWordWrap,\n            markdownEnumDescriptions: [\n                nls.localize('wordWrap.off', \"Lines will never wrap.\"),\n                nls.localize('wordWrap.on', \"Lines will wrap at the viewport width.\"),\n                nls.localize('wordWrap.inherit', \"Lines will wrap according to the {0} setting.\", '`#editor.wordWrap#`'),\n            ]\n        },\n        'diffEditor.diffAlgorithm': {\n            type: 'string',\n            enum: ['legacy', 'advanced'],\n            default: diffEditorDefaultOptions.diffAlgorithm,\n            markdownEnumDescriptions: [\n                nls.localize('diffAlgorithm.legacy', \"Uses the legacy diffing algorithm.\"),\n                nls.localize('diffAlgorithm.advanced', \"Uses the advanced diffing algorithm.\"),\n            ],\n            tags: ['experimental'],\n        },\n        'diffEditor.hideUnchangedRegions.enabled': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.hideUnchangedRegions.enabled,\n            markdownDescription: nls.localize('hideUnchangedRegions.enabled', \"Controls whether the diff editor shows unchanged regions.\"),\n        },\n        'diffEditor.hideUnchangedRegions.revealLineCount': {\n            type: 'integer',\n            default: diffEditorDefaultOptions.hideUnchangedRegions.revealLineCount,\n            markdownDescription: nls.localize('hideUnchangedRegions.revealLineCount', \"Controls how many lines are used for unchanged regions.\"),\n            minimum: 1,\n        },\n        'diffEditor.hideUnchangedRegions.minimumLineCount': {\n            type: 'integer',\n            default: diffEditorDefaultOptions.hideUnchangedRegions.minimumLineCount,\n            markdownDescription: nls.localize('hideUnchangedRegions.minimumLineCount', \"Controls how many lines are used as a minimum for unchanged regions.\"),\n            minimum: 1,\n        },\n        'diffEditor.hideUnchangedRegions.contextLineCount': {\n            type: 'integer',\n            default: diffEditorDefaultOptions.hideUnchangedRegions.contextLineCount,\n            markdownDescription: nls.localize('hideUnchangedRegions.contextLineCount', \"Controls how many lines are used as context when comparing unchanged regions.\"),\n            minimum: 1,\n        },\n        'diffEditor.experimental.showMoves': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.experimental.showMoves,\n            markdownDescription: nls.localize('showMoves', \"Controls whether the diff editor should show detected code moves.\")\n        },\n        'diffEditor.experimental.showEmptyDecorations': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.experimental.showEmptyDecorations,\n            description: nls.localize('showEmptyDecorations', \"Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted.\"),\n        },\n        'diffEditor.experimental.useTrueInlineView': {\n            type: 'boolean',\n            default: diffEditorDefaultOptions.experimental.useTrueInlineView,\n            description: nls.localize('useTrueInlineView', \"If enabled and the editor uses the inline view, word changes are rendered inline.\"),\n        },\n    }\n};\nfunction isConfigurationPropertySchema(x) {\n    return (typeof x.type !== 'undefined' || typeof x.anyOf !== 'undefined');\n}\n// Add properties from the Editor Option Registry\nfor (const editorOption of editorOptionsRegistry) {\n    const schema = editorOption.schema;\n    if (typeof schema !== 'undefined') {\n        if (isConfigurationPropertySchema(schema)) {\n            // This is a single schema contribution\n            editorConfiguration.properties[`editor.${editorOption.name}`] = schema;\n        }\n        else {\n            for (const key in schema) {\n                if (Object.hasOwnProperty.call(schema, key)) {\n                    editorConfiguration.properties[key] = schema[key];\n                }\n            }\n        }\n    }\n}\nlet cachedEditorConfigurationKeys = null;\nfunction getEditorConfigurationKeys() {\n    if (cachedEditorConfigurationKeys === null) {\n        cachedEditorConfigurationKeys = Object.create(null);\n        Object.keys(editorConfiguration.properties).forEach((prop) => {\n            cachedEditorConfigurationKeys[prop] = true;\n        });\n    }\n    return cachedEditorConfigurationKeys;\n}\nexport function isEditorConfigurationKey(key) {\n    const editorConfigurationKeys = getEditorConfigurationKeys();\n    return (editorConfigurationKeys[`editor.${key}`] || false);\n}\nexport function isDiffEditorConfigurationKey(key) {\n    const editorConfigurationKeys = getEditorConfigurationKeys();\n    return (editorConfigurationKeys[`diffEditor.${key}`] || false);\n}\nconst configurationRegistry = Registry.as(Extensions.Configuration);\nconfigurationRegistry.registerConfiguration(editorConfiguration);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nexport var InspectTokensNLS;\n(function (InspectTokensNLS) {\n    InspectTokensNLS.inspectTokensAction = nls.localize('inspectTokens', \"Developer: Inspect Tokens\");\n})(InspectTokensNLS || (InspectTokensNLS = {}));\nexport var GoToLineNLS;\n(function (GoToLineNLS) {\n    GoToLineNLS.gotoLineActionLabel = nls.localize('gotoLineActionLabel', \"Go to Line/Column...\");\n})(GoToLineNLS || (GoToLineNLS = {}));\nexport var QuickHelpNLS;\n(function (QuickHelpNLS) {\n    QuickHelpNLS.helpQuickAccessActionLabel = nls.localize('helpQuickAccess', \"Show all Quick Access Providers\");\n})(QuickHelpNLS || (QuickHelpNLS = {}));\nexport var QuickCommandNLS;\n(function (QuickCommandNLS) {\n    QuickCommandNLS.quickCommandActionLabel = nls.localize('quickCommandActionLabel', \"Command Palette\");\n    QuickCommandNLS.quickCommandHelp = nls.localize('quickCommandActionHelp', \"Show And Run Commands\");\n})(QuickCommandNLS || (QuickCommandNLS = {}));\nexport var QuickOutlineNLS;\n(function (QuickOutlineNLS) {\n    QuickOutlineNLS.quickOutlineActionLabel = nls.localize('quickOutlineActionLabel', \"Go to Symbol...\");\n    QuickOutlineNLS.quickOutlineByCategoryActionLabel = nls.localize('quickOutlineByCategoryActionLabel', \"Go to Symbol by Category...\");\n})(QuickOutlineNLS || (QuickOutlineNLS = {}));\nexport var StandaloneCodeEditorNLS;\n(function (StandaloneCodeEditorNLS) {\n    StandaloneCodeEditorNLS.editorViewAccessibleLabel = nls.localize('editorViewAccessibleLabel', \"Editor content\");\n})(StandaloneCodeEditorNLS || (StandaloneCodeEditorNLS = {}));\nexport var ToggleHighContrastNLS;\n(function (ToggleHighContrastNLS) {\n    ToggleHighContrastNLS.toggleHighContrast = nls.localize('toggleHighContrast', \"Toggle High Contrast Theme\");\n})(ToggleHighContrastNLS || (ToggleHighContrastNLS = {}));\nexport var StandaloneServicesNLS;\n(function (StandaloneServicesNLS) {\n    StandaloneServicesNLS.bulkEditServiceSummary = nls.localize('bulkEditServiceSummary', \"Made {0} edits in {1} files\");\n})(StandaloneServicesNLS || (StandaloneServicesNLS = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { parse } from '../../../base/common/glob.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { basename, posix } from '../../../base/common/path.js';\nimport { DataUri } from '../../../base/common/resources.js';\nimport { startsWithUTF8BOM } from '../../../base/common/strings.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nlet registeredAssociations = [];\nlet nonUserRegisteredAssociations = [];\nlet userRegisteredAssociations = [];\n/**\n * Associate a language to the registry (platform).\n * * **NOTE**: This association will lose over associations registered using `registerConfiguredLanguageAssociation`.\n * * **NOTE**: Use `clearPlatformLanguageAssociations` to remove all associations registered using this function.\n */\nexport function registerPlatformLanguageAssociation(association, warnOnOverwrite = false) {\n    _registerLanguageAssociation(association, false, warnOnOverwrite);\n}\nfunction _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {\n    // Register\n    const associationItem = toLanguageAssociationItem(association, userConfigured);\n    registeredAssociations.push(associationItem);\n    if (!associationItem.userConfigured) {\n        nonUserRegisteredAssociations.push(associationItem);\n    }\n    else {\n        userRegisteredAssociations.push(associationItem);\n    }\n    // Check for conflicts unless this is a user configured association\n    if (warnOnOverwrite && !associationItem.userConfigured) {\n        registeredAssociations.forEach(a => {\n            if (a.mime === associationItem.mime || a.userConfigured) {\n                return; // same mime or userConfigured is ok\n            }\n            if (associationItem.extension && a.extension === associationItem.extension) {\n                console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.filename && a.filename === associationItem.filename) {\n                console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {\n                console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.firstline && a.firstline === associationItem.firstline) {\n                console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n        });\n    }\n}\nfunction toLanguageAssociationItem(association, userConfigured) {\n    return {\n        id: association.id,\n        mime: association.mime,\n        filename: association.filename,\n        extension: association.extension,\n        filepattern: association.filepattern,\n        firstline: association.firstline,\n        userConfigured: userConfigured,\n        filenameLowercase: association.filename ? association.filename.toLowerCase() : undefined,\n        extensionLowercase: association.extension ? association.extension.toLowerCase() : undefined,\n        filepatternLowercase: association.filepattern ? parse(association.filepattern.toLowerCase()) : undefined,\n        filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false\n    };\n}\n/**\n * Clear language associations from the registry (platform).\n */\nexport function clearPlatformLanguageAssociations() {\n    registeredAssociations = registeredAssociations.filter(a => a.userConfigured);\n    nonUserRegisteredAssociations = [];\n}\n/**\n * @see `getMimeTypes`\n */\nexport function getLanguageIds(resource, firstLine) {\n    return getAssociations(resource, firstLine).map(item => item.id);\n}\nfunction getAssociations(resource, firstLine) {\n    let path;\n    if (resource) {\n        switch (resource.scheme) {\n            case Schemas.file:\n                path = resource.fsPath;\n                break;\n            case Schemas.data: {\n                const metadata = DataUri.parseMetaData(resource);\n                path = metadata.get(DataUri.META_DATA_LABEL);\n                break;\n            }\n            case Schemas.vscodeNotebookCell:\n                // File path not relevant for language detection of cell\n                path = undefined;\n                break;\n            default:\n                path = resource.path;\n        }\n    }\n    if (!path) {\n        return [{ id: 'unknown', mime: Mimes.unknown }];\n    }\n    path = path.toLowerCase();\n    const filename = basename(path);\n    // 1.) User configured mappings have highest priority\n    const configuredLanguage = getAssociationByPath(path, filename, userRegisteredAssociations);\n    if (configuredLanguage) {\n        return [configuredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n    }\n    // 2.) Registered mappings have middle priority\n    const registeredLanguage = getAssociationByPath(path, filename, nonUserRegisteredAssociations);\n    if (registeredLanguage) {\n        return [registeredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n    }\n    // 3.) Firstline has lowest priority\n    if (firstLine) {\n        const firstlineLanguage = getAssociationByFirstline(firstLine);\n        if (firstlineLanguage) {\n            return [firstlineLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n        }\n    }\n    return [{ id: 'unknown', mime: Mimes.unknown }];\n}\nfunction getAssociationByPath(path, filename, associations) {\n    let filenameMatch = undefined;\n    let patternMatch = undefined;\n    let extensionMatch = undefined;\n    // We want to prioritize associations based on the order they are registered so that the last registered\n    // association wins over all other. This is for https://github.com/microsoft/vscode/issues/20074\n    for (let i = associations.length - 1; i >= 0; i--) {\n        const association = associations[i];\n        // First exact name match\n        if (filename === association.filenameLowercase) {\n            filenameMatch = association;\n            break; // take it!\n        }\n        // Longest pattern match\n        if (association.filepattern) {\n            if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {\n                const target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator\n                if (association.filepatternLowercase?.(target)) {\n                    patternMatch = association;\n                }\n            }\n        }\n        // Longest extension match\n        if (association.extension) {\n            if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {\n                if (filename.endsWith(association.extensionLowercase)) {\n                    extensionMatch = association;\n                }\n            }\n        }\n    }\n    // 1.) Exact name match has second highest priority\n    if (filenameMatch) {\n        return filenameMatch;\n    }\n    // 2.) Match on pattern\n    if (patternMatch) {\n        return patternMatch;\n    }\n    // 3.) Match on extension comes next\n    if (extensionMatch) {\n        return extensionMatch;\n    }\n    return undefined;\n}\nfunction getAssociationByFirstline(firstLine) {\n    if (startsWithUTF8BOM(firstLine)) {\n        firstLine = firstLine.substr(1);\n    }\n    if (firstLine.length > 0) {\n        // We want to prioritize associations based on the order they are registered so that the last registered\n        // association wins over all other. This is for https://github.com/microsoft/vscode/issues/20074\n        for (let i = registeredAssociations.length - 1; i >= 0; i--) {\n            const association = registeredAssociations[i];\n            if (!association.firstline) {\n                continue;\n            }\n            const matches = firstLine.match(association.firstline);\n            if (matches && matches.length > 0) {\n                return association;\n            }\n        }\n    }\n    return undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\nimport { clearPlatformLanguageAssociations, getLanguageIds, registerPlatformLanguageAssociation } from './languagesAssociations.js';\nimport { ModesRegistry, PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst NULL_LANGUAGE_ID = 'vs.editor.nullLanguage';\nexport class LanguageIdCodec {\n    constructor() {\n        this._languageIdToLanguage = [];\n        this._languageToLanguageId = new Map();\n        this._register(NULL_LANGUAGE_ID, 0 /* LanguageId.Null */);\n        this._register(PLAINTEXT_LANGUAGE_ID, 1 /* LanguageId.PlainText */);\n        this._nextLanguageId = 2;\n    }\n    _register(language, languageId) {\n        this._languageIdToLanguage[languageId] = language;\n        this._languageToLanguageId.set(language, languageId);\n    }\n    register(language) {\n        if (this._languageToLanguageId.has(language)) {\n            return;\n        }\n        const languageId = this._nextLanguageId++;\n        this._register(language, languageId);\n    }\n    encodeLanguageId(languageId) {\n        return this._languageToLanguageId.get(languageId) || 0 /* LanguageId.Null */;\n    }\n    decodeLanguageId(languageId) {\n        return this._languageIdToLanguage[languageId] || NULL_LANGUAGE_ID;\n    }\n}\nexport class LanguagesRegistry extends Disposable {\n    static { this.instanceCount = 0; }\n    constructor(useModesRegistry = true, warnOnOverwrite = false) {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        LanguagesRegistry.instanceCount++;\n        this._warnOnOverwrite = warnOnOverwrite;\n        this.languageIdCodec = new LanguageIdCodec();\n        this._dynamicLanguages = [];\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        if (useModesRegistry) {\n            this._initializeFromRegistry();\n            this._register(ModesRegistry.onDidChangeLanguages((m) => {\n                this._initializeFromRegistry();\n            }));\n        }\n    }\n    dispose() {\n        LanguagesRegistry.instanceCount--;\n        super.dispose();\n    }\n    _initializeFromRegistry() {\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        clearPlatformLanguageAssociations();\n        const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);\n        this._registerLanguages(desc);\n    }\n    _registerLanguages(desc) {\n        for (const d of desc) {\n            this._registerLanguage(d);\n        }\n        // Rebuild fast path maps\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        Object.keys(this._languages).forEach((langId) => {\n            const language = this._languages[langId];\n            if (language.name) {\n                this._nameMap[language.name] = language.identifier;\n            }\n            language.aliases.forEach((alias) => {\n                this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;\n            });\n            language.mimetypes.forEach((mimetype) => {\n                this._mimeTypesMap[mimetype] = language.identifier;\n            });\n        });\n        Registry.as(Extensions.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds());\n        this._onDidChange.fire();\n    }\n    _registerLanguage(lang) {\n        const langId = lang.id;\n        let resolvedLanguage;\n        if (hasOwnProperty.call(this._languages, langId)) {\n            resolvedLanguage = this._languages[langId];\n        }\n        else {\n            this.languageIdCodec.register(langId);\n            resolvedLanguage = {\n                identifier: langId,\n                name: null,\n                mimetypes: [],\n                aliases: [],\n                extensions: [],\n                filenames: [],\n                configurationFiles: [],\n                icons: []\n            };\n            this._languages[langId] = resolvedLanguage;\n        }\n        this._mergeLanguage(resolvedLanguage, lang);\n    }\n    _mergeLanguage(resolvedLanguage, lang) {\n        const langId = lang.id;\n        let primaryMime = null;\n        if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {\n            resolvedLanguage.mimetypes.push(...lang.mimetypes);\n            primaryMime = lang.mimetypes[0];\n        }\n        if (!primaryMime) {\n            primaryMime = `text/x-${langId}`;\n            resolvedLanguage.mimetypes.push(primaryMime);\n        }\n        if (Array.isArray(lang.extensions)) {\n            if (lang.configuration) {\n                // insert first as this appears to be the 'primary' language definition\n                resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);\n            }\n            else {\n                resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);\n            }\n            for (const extension of lang.extensions) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, extension: extension }, this._warnOnOverwrite);\n            }\n        }\n        if (Array.isArray(lang.filenames)) {\n            for (const filename of lang.filenames) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filename: filename }, this._warnOnOverwrite);\n                resolvedLanguage.filenames.push(filename);\n            }\n        }\n        if (Array.isArray(lang.filenamePatterns)) {\n            for (const filenamePattern of lang.filenamePatterns) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);\n            }\n        }\n        if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {\n            let firstLineRegexStr = lang.firstLine;\n            if (firstLineRegexStr.charAt(0) !== '^') {\n                firstLineRegexStr = '^' + firstLineRegexStr;\n            }\n            try {\n                const firstLineRegex = new RegExp(firstLineRegexStr);\n                if (!regExpLeadsToEndlessLoop(firstLineRegex)) {\n                    registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);\n                }\n            }\n            catch (err) {\n                // Most likely, the regex was bad\n                console.warn(`[${lang.id}]: Invalid regular expression \\`${firstLineRegexStr}\\`: `, err);\n            }\n        }\n        resolvedLanguage.aliases.push(langId);\n        let langAliases = null;\n        if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {\n            if (lang.aliases.length === 0) {\n                // signal that this language should not get a name\n                langAliases = [null];\n            }\n            else {\n                langAliases = lang.aliases;\n            }\n        }\n        if (langAliases !== null) {\n            for (const langAlias of langAliases) {\n                if (!langAlias || langAlias.length === 0) {\n                    continue;\n                }\n                resolvedLanguage.aliases.push(langAlias);\n            }\n        }\n        const containsAliases = (langAliases !== null && langAliases.length > 0);\n        if (containsAliases && langAliases[0] === null) {\n            // signal that this language should not get a name\n        }\n        else {\n            const bestName = (containsAliases ? langAliases[0] : null) || langId;\n            if (containsAliases || !resolvedLanguage.name) {\n                resolvedLanguage.name = bestName;\n            }\n        }\n        if (lang.configuration) {\n            resolvedLanguage.configurationFiles.push(lang.configuration);\n        }\n        if (lang.icon) {\n            resolvedLanguage.icons.push(lang.icon);\n        }\n    }\n    isRegisteredLanguageId(languageId) {\n        if (!languageId) {\n            return false;\n        }\n        return hasOwnProperty.call(this._languages, languageId);\n    }\n    getRegisteredLanguageIds() {\n        return Object.keys(this._languages);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        const languageNameLower = languageName.toLowerCase();\n        if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {\n            return null;\n        }\n        return this._lowercaseNameMap[languageNameLower];\n    }\n    getLanguageIdByMimeType(mimeType) {\n        if (!mimeType) {\n            return null;\n        }\n        if (hasOwnProperty.call(this._mimeTypesMap, mimeType)) {\n            return this._mimeTypesMap[mimeType];\n        }\n        return null;\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        if (!resource && !firstLine) {\n            return [];\n        }\n        return getLanguageIds(resource, firstLine);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LanguagesRegistry } from './languagesRegistry.js';\nimport { firstOrDefault } from '../../../base/common/arrays.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { observableFromEvent } from '../../../base/common/observable.js';\nexport class LanguageService extends Disposable {\n    static { this.instanceCount = 0; }\n    constructor(warnOnOverwrite = false) {\n        super();\n        this._onDidRequestBasicLanguageFeatures = this._register(new Emitter());\n        this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event;\n        this._onDidRequestRichLanguageFeatures = this._register(new Emitter());\n        this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event;\n        this._onDidChange = this._register(new Emitter({ leakWarningThreshold: 200 /* https://github.com/microsoft/vscode/issues/119968 */ }));\n        this.onDidChange = this._onDidChange.event;\n        this._requestedBasicLanguages = new Set();\n        this._requestedRichLanguages = new Set();\n        LanguageService.instanceCount++;\n        this._registry = this._register(new LanguagesRegistry(true, warnOnOverwrite));\n        this.languageIdCodec = this._registry.languageIdCodec;\n        this._register(this._registry.onDidChange(() => this._onDidChange.fire()));\n    }\n    dispose() {\n        LanguageService.instanceCount--;\n        super.dispose();\n    }\n    isRegisteredLanguageId(languageId) {\n        return this._registry.isRegisteredLanguageId(languageId);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        return this._registry.getLanguageIdByLanguageName(languageName);\n    }\n    getLanguageIdByMimeType(mimeType) {\n        return this._registry.getLanguageIdByMimeType(mimeType);\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        const languageIds = this._registry.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n        return firstOrDefault(languageIds, null);\n    }\n    createById(languageId) {\n        return new LanguageSelection(this.onDidChange, () => {\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    createByFilepathOrFirstLine(resource, firstLine) {\n        return new LanguageSelection(this.onDidChange, () => {\n            const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    _createAndGetLanguageIdentifier(languageId) {\n        if (!languageId || !this.isRegisteredLanguageId(languageId)) {\n            // Fall back to plain text if language is unknown\n            languageId = PLAINTEXT_LANGUAGE_ID;\n        }\n        return languageId;\n    }\n    requestBasicLanguageFeatures(languageId) {\n        if (!this._requestedBasicLanguages.has(languageId)) {\n            this._requestedBasicLanguages.add(languageId);\n            this._onDidRequestBasicLanguageFeatures.fire(languageId);\n        }\n    }\n    requestRichLanguageFeatures(languageId) {\n        if (!this._requestedRichLanguages.has(languageId)) {\n            this._requestedRichLanguages.add(languageId);\n            // Ensure basic features are requested\n            this.requestBasicLanguageFeatures(languageId);\n            // Ensure tokenizers are created\n            TokenizationRegistry.getOrCreate(languageId);\n            this._onDidRequestRichLanguageFeatures.fire(languageId);\n        }\n    }\n}\nclass LanguageSelection {\n    constructor(onDidChangeLanguages, selector) {\n        this._value = observableFromEvent(this, onDidChangeLanguages, () => selector());\n        this.onDidChange = Event.fromObservable(this._value);\n    }\n    get languageId() {\n        return this._value.get();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IEditorWorkerService = createDecorator('editorWorkerService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight, editorWarningBackground } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', null, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'));\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'));\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorPrimaryForeground = registerColor('editorMultiCursor.primary.foreground', editorCursorForeground, nls.localize('editorMultiCursorPrimaryForeground', 'Color of the primary editor cursor when multiple cursors are present.'));\nexport const editorMultiCursorPrimaryBackground = registerColor('editorMultiCursor.primary.background', editorCursorBackground, nls.localize('editorMultiCursorPrimaryBackground', 'The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorSecondaryForeground = registerColor('editorMultiCursor.secondary.foreground', editorCursorForeground, nls.localize('editorMultiCursorSecondaryForeground', 'Color of secondary editor cursors when multiple cursors are present.'));\nexport const editorMultiCursorSecondaryBackground = registerColor('editorMultiCursor.secondary.background', editorCursorBackground, nls.localize('editorMultiCursorSecondaryBackground', 'The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nexport const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', editorWhitespaces, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nexport const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', editorWhitespaces, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\nexport const editorIndentGuide1 = registerColor('editorIndentGuide.background1', deprecatedEditorIndentGuides, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));\nexport const editorIndentGuide2 = registerColor('editorIndentGuide.background2', '#00000000', nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));\nexport const editorIndentGuide3 = registerColor('editorIndentGuide.background3', '#00000000', nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));\nexport const editorIndentGuide4 = registerColor('editorIndentGuide.background4', '#00000000', nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));\nexport const editorIndentGuide5 = registerColor('editorIndentGuide.background5', '#00000000', nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));\nexport const editorIndentGuide6 = registerColor('editorIndentGuide.background6', '#00000000', nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));\nexport const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', deprecatedEditorActiveIndentGuides, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));\nexport const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', '#00000000', nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));\nexport const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', '#00000000', nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));\nexport const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', '#00000000', nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));\nexport const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', '#00000000', nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));\nexport const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', '#00000000', nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', deprecatedEditorActiveLineNumber, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', null, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', editorBackground, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', null, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', rulerRangeDefault, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', '#00000000', nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', '#00000000', nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', '#00000000', nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: 'new Color(new RGBA(255, 50, 50, 1))', hcLight: '#B5200D' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', '#00000000', nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', '#00000000', nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', '#00000000', nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', '#00000000', nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', '#00000000', nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', '#00000000', nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', '#00000000', nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', '#00000000', nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', '#00000000', nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', '#00000000', nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', '#00000000', nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', '#00000000', nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', editorWarningForeground, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', editorWarningBackground, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { IMarkerService, MarkerSeverity } from '../../../platform/markers/common/markers.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { OverviewRulerLane } from '../model.js';\nimport { themeColorFromId } from '../../../platform/theme/common/themeService.js';\nimport { overviewRulerWarning, overviewRulerInfo, overviewRulerError } from '../core/editorColorRegistry.js';\nimport { IModelService } from './model.js';\nimport { Range } from '../core/range.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { minimapInfo, minimapWarning, minimapError } from '../../../platform/theme/common/colorRegistry.js';\nimport { BidirectionalMap, ResourceMap } from '../../../base/common/map.js';\nimport { diffSets } from '../../../base/common/collections.js';\nlet MarkerDecorationsService = class MarkerDecorationsService extends Disposable {\n    constructor(modelService, _markerService) {\n        super();\n        this._markerService = _markerService;\n        this._onDidChangeMarker = this._register(new Emitter());\n        this._markerDecorations = new ResourceMap();\n        modelService.getModels().forEach(model => this._onModelAdded(model));\n        this._register(modelService.onModelAdded(this._onModelAdded, this));\n        this._register(modelService.onModelRemoved(this._onModelRemoved, this));\n        this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));\n    }\n    dispose() {\n        super.dispose();\n        this._markerDecorations.forEach(value => value.dispose());\n        this._markerDecorations.clear();\n    }\n    getMarker(uri, decoration) {\n        const markerDecorations = this._markerDecorations.get(uri);\n        return markerDecorations ? (markerDecorations.getMarker(decoration) || null) : null;\n    }\n    _handleMarkerChange(changedResources) {\n        changedResources.forEach((resource) => {\n            const markerDecorations = this._markerDecorations.get(resource);\n            if (markerDecorations) {\n                this._updateDecorations(markerDecorations);\n            }\n        });\n    }\n    _onModelAdded(model) {\n        const markerDecorations = new MarkerDecorations(model);\n        this._markerDecorations.set(model.uri, markerDecorations);\n        this._updateDecorations(markerDecorations);\n    }\n    _onModelRemoved(model) {\n        const markerDecorations = this._markerDecorations.get(model.uri);\n        if (markerDecorations) {\n            markerDecorations.dispose();\n            this._markerDecorations.delete(model.uri);\n        }\n        // clean up markers for internal, transient models\n        if (model.uri.scheme === Schemas.inMemory\n            || model.uri.scheme === Schemas.internal\n            || model.uri.scheme === Schemas.vscode) {\n            this._markerService?.read({ resource: model.uri }).map(marker => marker.owner).forEach(owner => this._markerService.remove(owner, [model.uri]));\n        }\n    }\n    _updateDecorations(markerDecorations) {\n        // Limit to the first 500 errors/warnings\n        const markers = this._markerService.read({ resource: markerDecorations.model.uri, take: 500 });\n        if (markerDecorations.update(markers)) {\n            this._onDidChangeMarker.fire(markerDecorations.model);\n        }\n    }\n};\nMarkerDecorationsService = __decorate([\n    __param(0, IModelService),\n    __param(1, IMarkerService)\n], MarkerDecorationsService);\nexport { MarkerDecorationsService };\nclass MarkerDecorations extends Disposable {\n    constructor(model) {\n        super();\n        this.model = model;\n        this._map = new BidirectionalMap();\n        this._register(toDisposable(() => {\n            this.model.deltaDecorations([...this._map.values()], []);\n            this._map.clear();\n        }));\n    }\n    update(markers) {\n        // We use the fact that marker instances are not recreated when different owners\n        // update. So we can compare references to find out what changed since the last update.\n        const { added, removed } = diffSets(new Set(this._map.keys()), new Set(markers));\n        if (added.length === 0 && removed.length === 0) {\n            return false;\n        }\n        const oldIds = removed.map(marker => this._map.get(marker));\n        const newDecorations = added.map(marker => {\n            return {\n                range: this._createDecorationRange(this.model, marker),\n                options: this._createDecorationOption(marker)\n            };\n        });\n        const ids = this.model.deltaDecorations(oldIds, newDecorations);\n        for (const removedMarker of removed) {\n            this._map.delete(removedMarker);\n        }\n        for (let index = 0; index < ids.length; index++) {\n            this._map.set(added[index], ids[index]);\n        }\n        return true;\n    }\n    getMarker(decoration) {\n        return this._map.getKey(decoration.id);\n    }\n    _createDecorationRange(model, rawMarker) {\n        let ret = Range.lift(rawMarker);\n        if (rawMarker.severity === MarkerSeverity.Hint && !this._hasMarkerTag(rawMarker, 1 /* MarkerTag.Unnecessary */) && !this._hasMarkerTag(rawMarker, 2 /* MarkerTag.Deprecated */)) {\n            // * never render hints on multiple lines\n            // * make enough space for three dots\n            ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn + 2);\n        }\n        ret = model.validateRange(ret);\n        if (ret.isEmpty()) {\n            const maxColumn = model.getLineLastNonWhitespaceColumn(ret.startLineNumber) ||\n                model.getLineMaxColumn(ret.startLineNumber);\n            if (maxColumn === 1 || ret.endColumn >= maxColumn) {\n                // empty line or behind eol\n                // keep the range as is, it will be rendered 1ch wide\n                return ret;\n            }\n            const word = model.getWordAtPosition(ret.getStartPosition());\n            if (word) {\n                ret = new Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);\n            }\n        }\n        else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {\n            const minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);\n            if (minColumn < ret.endColumn) {\n                ret = new Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);\n                rawMarker.startColumn = minColumn;\n            }\n        }\n        return ret;\n    }\n    _createDecorationOption(marker) {\n        let className;\n        let color = undefined;\n        let zIndex;\n        let inlineClassName = undefined;\n        let minimap;\n        switch (marker.severity) {\n            case MarkerSeverity.Hint:\n                if (this._hasMarkerTag(marker, 2 /* MarkerTag.Deprecated */)) {\n                    className = undefined;\n                }\n                else if (this._hasMarkerTag(marker, 1 /* MarkerTag.Unnecessary */)) {\n                    className = \"squiggly-unnecessary\" /* ClassName.EditorUnnecessaryDecoration */;\n                }\n                else {\n                    className = \"squiggly-hint\" /* ClassName.EditorHintDecoration */;\n                }\n                zIndex = 0;\n                break;\n            case MarkerSeverity.Info:\n                className = \"squiggly-info\" /* ClassName.EditorInfoDecoration */;\n                color = themeColorFromId(overviewRulerInfo);\n                zIndex = 10;\n                minimap = {\n                    color: themeColorFromId(minimapInfo),\n                    position: 1 /* MinimapPosition.Inline */\n                };\n                break;\n            case MarkerSeverity.Warning:\n                className = \"squiggly-warning\" /* ClassName.EditorWarningDecoration */;\n                color = themeColorFromId(overviewRulerWarning);\n                zIndex = 20;\n                minimap = {\n                    color: themeColorFromId(minimapWarning),\n                    position: 1 /* MinimapPosition.Inline */\n                };\n                break;\n            case MarkerSeverity.Error:\n            default:\n                className = \"squiggly-error\" /* ClassName.EditorErrorDecoration */;\n                color = themeColorFromId(overviewRulerError);\n                zIndex = 30;\n                minimap = {\n                    color: themeColorFromId(minimapError),\n                    position: 1 /* MinimapPosition.Inline */\n                };\n                break;\n        }\n        if (marker.tags) {\n            if (marker.tags.indexOf(1 /* MarkerTag.Unnecessary */) !== -1) {\n                inlineClassName = \"squiggly-inline-unnecessary\" /* ClassName.EditorUnnecessaryInlineDecoration */;\n            }\n            if (marker.tags.indexOf(2 /* MarkerTag.Deprecated */) !== -1) {\n                inlineClassName = \"squiggly-inline-deprecated\" /* ClassName.EditorDeprecatedInlineDecoration */;\n            }\n        }\n        return {\n            description: 'marker-decoration',\n            stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n            className,\n            showIfCollapsed: true,\n            overviewRuler: {\n                color,\n                position: OverviewRulerLane.Right\n            },\n            minimap,\n            zIndex,\n            inlineClassName,\n        };\n    }\n    _hasMarkerTag(marker, tag) {\n        if (marker.tags) {\n            return marker.tags.indexOf(tag) >= 0;\n        }\n        return false;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IMarkerDecorationsService = createDecorator('markerDecorationsService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITreeSitterParserService = createDecorator('treeSitterParserService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* InlineDecorationType.Regular */ || d.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* InlineDecorationType.Before */\n                ? 2 /* LinePartMetadata.PSEUDO_BEFORE */\n                : d.type === 2 /* InlineDecorationType.After */\n                    ? 4 /* LinePartMetadata.PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinePart {\n    constructor(\n    /**\n     * last char index of this token (not inclusive).\n     */\n    endIndex, type, metadata, containsRTL) {\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n        this.containsRTL = containsRTL;\n        this._linePartBrand = undefined;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* LinePartMetadata.IS_WHITESPACE_MASK */ ? true : false);\n    }\n    isPseudoAfter() {\n        return (this.metadata & 4 /* LinePartMetadata.PSEUDO_AFTER_MASK */ ? true : false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* RenderWhitespace.All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* RenderWhitespace.Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* RenderWhitespace.Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* RenderWhitespace.Trailing */\n                        : 0 /* RenderWhitespace.None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._horizontalOffset = new Uint32Array(this.length);\n    }\n    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n        const partData = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n    getHorizontalOffset(column) {\n        if (this._horizontalOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._horizontalOffset[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* ForeignElementType.None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                    sb.appendString(`<span class=\"`);\n                    sb.appendString(lineDecoration.className);\n                    sb.appendString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                        containsForeignElements |= 1 /* ForeignElementType.Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                        containsForeignElements |= 2 /* ForeignElementType.After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = new StringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.overflowingCharCount = overflowingCharCount;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let overflowingCharCount;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        overflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        overflowingCharCount = 0;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* RenderWhitespace.All */ ||\n        input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ ||\n        (input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine) ||\n        (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */ && !input.continuesWithWrappedLine)) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* ForeignElementType.None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                containsForeignElements |= 2 /* ForeignElementType.After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n    }\n    let startOffset = fauxIndentLength;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n            result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n            break;\n        }\n        const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n        result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n        startOffset = endIndex;\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* Constants.LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* Constants.LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* CharCode.Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0, false);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* RenderWhitespace.Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* CharCode.Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n                    isInWhitespace = (nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (isInWhitespace && tokenContainsRTL) {\n            // If the token contains RTL text, breaking it up into multiple line parts\n            // to render whitespace might affect the browser's bidi layout.\n            //\n            // We render whitespace in such tokens only if the whitespace\n            // is the leading or the trailing whitespace of the line,\n            // which doesn't affect the browser's bidi layout.\n            if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n                isInWhitespace = false;\n            }\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* CharCode.Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenContainsRTL = tokens[tokenIndex].containsRTL;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* CharCode.Space */ && (prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const overflowingCharCount = input.overflowingCharCount;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0; // the character offset in the current part\n    let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n    let partDisplacement = 0;\n    if (containsRTL) {\n        sb.appendString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partContainsRTL = part.containsRTL;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendString('<span ');\n        if (partContainsRTL) {\n            sb.appendString('style=\"unicode-bidi:isolate\" ');\n        }\n        sb.appendString('class=\"');\n        sb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCIICharCode(34 /* CharCode.DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partWidth = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* CharCode.Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partWidth += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendString(' style=\"width:');\n                sb.appendString(String(spaceWidth * partWidth));\n                sb.appendString('px\"');\n            }\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters;\n                let charWidth;\n                if (charCode === 9 /* CharCode.Tab */) {\n                    producedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n                    charWidth = producedCharacters;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.appendCharCode(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    producedCharacters = 2;\n                    charWidth = 1;\n                    sb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n                    sb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        else {\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* CharCode.Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.appendCharCode(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* CharCode.Space */:\n                        sb.appendCharCode(0xA0); // &nbsp;\n                        break;\n                    case 60 /* CharCode.LessThan */:\n                        sb.appendString('&lt;');\n                        break;\n                    case 62 /* CharCode.GreaterThan */:\n                        sb.appendString('&gt;');\n                        break;\n                    case 38 /* CharCode.Ampersand */:\n                        sb.appendString('&amp;');\n                        break;\n                    case 0 /* CharCode.Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.appendCharCode(9216);\n                        }\n                        else {\n                            sb.appendString('&#00;');\n                        }\n                        break;\n                    case 65279 /* CharCode.UTF8_BOM */:\n                    case 8232 /* CharCode.LINE_SEPARATOR */:\n                    case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                    case 133 /* CharCode.NEXT_LINE */:\n                        sb.appendCharCode(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.appendCharCode(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.appendCharCode(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendString('[U+');\n                            sb.appendString(to4CharHex(charCode));\n                            sb.appendString(']');\n                            producedCharacters = 8;\n                            charWidth = producedCharacters;\n                        }\n                        else {\n                            sb.appendCharCode(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n        }\n        sb.appendString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n    }\n    if (isOverflowing) {\n        sb.appendString('<span class=\"mtkoverflow\">');\n        sb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n        sb.appendString('</span>');\n    }\n    sb.appendString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\nfunction renderOverflowingCharCount(n) {\n    if (n < 1024) {\n        return nls.localize('overflow.chars', \"{0} chars\", n);\n    }\n    if (n < 1024 * 1024) {\n        return `${(n / 1024).toFixed(1)} KB`;\n    }\n    return `${(n / 1024 / 1024).toFixed(1)} MB`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../base/common/arrays.js';\nimport * as strings from '../../base/common/strings.js';\nimport { Range } from './core/range.js';\nexport class Viewport {\n    constructor(top, left, width, height) {\n        this._viewportBrand = undefined;\n        this.top = top | 0;\n        this.left = left | 0;\n        this.width = width | 0;\n        this.height = height | 0;\n    }\n}\nexport class MinimapLinesRenderingData {\n    constructor(tabSize, data) {\n        this.tabSize = tabSize;\n        this.data = data;\n    }\n}\nexport class ViewLineData {\n    constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations) {\n        this._viewLineDataBrand = undefined;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.startVisibleColumn = startVisibleColumn;\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n    }\n}\nexport class ViewLineRenderingData {\n    constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n    }\n    static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n        if (mightContainNonBasicASCII) {\n            return strings.isBasicASCII(lineContent);\n        }\n        return true;\n    }\n    static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n        if (!isBasicASCII && mightContainRTL) {\n            return strings.containsRTL(lineContent);\n        }\n        return false;\n    }\n}\nexport class InlineDecoration {\n    constructor(range, inlineClassName, type) {\n        this.range = range;\n        this.inlineClassName = inlineClassName;\n        this.type = type;\n    }\n}\nexport class SingleLineInlineDecoration {\n    constructor(startOffset, endOffset, inlineClassName, inlineClassNameAffectsLetterSpacing) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.inlineClassName = inlineClassName;\n        this.inlineClassNameAffectsLetterSpacing = inlineClassNameAffectsLetterSpacing;\n    }\n    toInlineDecoration(lineNumber) {\n        return new InlineDecoration(new Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n    }\n}\nexport class ViewModelDecoration {\n    constructor(range, options) {\n        this._viewModelDecorationBrand = undefined;\n        this.range = range;\n        this.options = options;\n    }\n}\nexport class OverviewRulerDecorationsGroup {\n    constructor(color, zIndex, \n    /**\n     * Decorations are encoded in a number array using the following scheme:\n     *  - 3*i = lane\n     *  - 3*i+1 = startLineNumber\n     *  - 3*i+2 = endLineNumber\n     */\n    data) {\n        this.color = color;\n        this.zIndex = zIndex;\n        this.data = data;\n    }\n    static compareByRenderingProps(a, b) {\n        if (a.zIndex === b.zIndex) {\n            if (a.color < b.color) {\n                return -1;\n            }\n            if (a.color > b.color) {\n                return 1;\n            }\n            return 0;\n        }\n        return a.zIndex - b.zIndex;\n    }\n    static equals(a, b) {\n        return (a.color === b.color\n            && a.zIndex === b.zIndex\n            && arrays.equals(a.data, b.data));\n    }\n    static equalsArr(a, b) {\n        return arrays.equals(a, b, OverviewRulerDecorationsGroup.equals);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewEventHandler extends Disposable {\n    constructor() {\n        super();\n        this._shouldRender = true;\n    }\n    shouldRender() {\n        return this._shouldRender;\n    }\n    forceShouldRender() {\n        this._shouldRender = true;\n    }\n    setShouldRender() {\n        this._shouldRender = true;\n    }\n    onDidRender() {\n        this._shouldRender = false;\n    }\n    // --- begin event handlers\n    onCompositionStart(e) {\n        return false;\n    }\n    onCompositionEnd(e) {\n        return false;\n    }\n    onConfigurationChanged(e) {\n        return false;\n    }\n    onCursorStateChanged(e) {\n        return false;\n    }\n    onDecorationsChanged(e) {\n        return false;\n    }\n    onFlushed(e) {\n        return false;\n    }\n    onFocusChanged(e) {\n        return false;\n    }\n    onLanguageConfigurationChanged(e) {\n        return false;\n    }\n    onLineMappingChanged(e) {\n        return false;\n    }\n    onLinesChanged(e) {\n        return false;\n    }\n    onLinesDeleted(e) {\n        return false;\n    }\n    onLinesInserted(e) {\n        return false;\n    }\n    onRevealRangeRequest(e) {\n        return false;\n    }\n    onScrollChanged(e) {\n        return false;\n    }\n    onThemeChanged(e) {\n        return false;\n    }\n    onTokensChanged(e) {\n        return false;\n    }\n    onTokensColorsChanged(e) {\n        return false;\n    }\n    onZonesChanged(e) {\n        return false;\n    }\n    // --- end event handlers\n    handleEvents(events) {\n        let shouldRender = false;\n        for (let i = 0, len = events.length; i < len; i++) {\n            const e = events[i];\n            switch (e.type) {\n                case 0 /* viewEvents.ViewEventType.ViewCompositionStart */:\n                    if (this.onCompositionStart(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 1 /* viewEvents.ViewEventType.ViewCompositionEnd */:\n                    if (this.onCompositionEnd(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 2 /* viewEvents.ViewEventType.ViewConfigurationChanged */:\n                    if (this.onConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 3 /* viewEvents.ViewEventType.ViewCursorStateChanged */:\n                    if (this.onCursorStateChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 4 /* viewEvents.ViewEventType.ViewDecorationsChanged */:\n                    if (this.onDecorationsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 5 /* viewEvents.ViewEventType.ViewFlushed */:\n                    if (this.onFlushed(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 6 /* viewEvents.ViewEventType.ViewFocusChanged */:\n                    if (this.onFocusChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 7 /* viewEvents.ViewEventType.ViewLanguageConfigurationChanged */:\n                    if (this.onLanguageConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 8 /* viewEvents.ViewEventType.ViewLineMappingChanged */:\n                    if (this.onLineMappingChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 9 /* viewEvents.ViewEventType.ViewLinesChanged */:\n                    if (this.onLinesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 10 /* viewEvents.ViewEventType.ViewLinesDeleted */:\n                    if (this.onLinesDeleted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 11 /* viewEvents.ViewEventType.ViewLinesInserted */:\n                    if (this.onLinesInserted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 12 /* viewEvents.ViewEventType.ViewRevealRangeRequest */:\n                    if (this.onRevealRangeRequest(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 13 /* viewEvents.ViewEventType.ViewScrollChanged */:\n                    if (this.onScrollChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 15 /* viewEvents.ViewEventType.ViewTokensChanged */:\n                    if (this.onTokensChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 14 /* viewEvents.ViewEventType.ViewThemeChanged */:\n                    if (this.onThemeChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 16 /* viewEvents.ViewEventType.ViewTokensColorsChanged */:\n                    if (this.onTokensColorsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 17 /* viewEvents.ViewEventType.ViewZonesChanged */:\n                    if (this.onZonesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                default:\n                    console.info('View received unknown event: ');\n                    console.info(e);\n            }\n        }\n        if (shouldRender) {\n            this._shouldRender = true;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    static shouldRecreate(e) {\n        return (e.hasChanged(146 /* EditorOption.layoutInfo */)\n            || e.hasChanged(132 /* EditorOption.wordSeparators */)\n            || e.hasChanged(37 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(77 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(79 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(80 /* EditorOption.multiCursorLimit */)\n            || e.hasChanged(6 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(7 /* EditorOption.autoClosingComments */)\n            || e.hasChanged(11 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(9 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(10 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(14 /* EditorOption.autoSurround */)\n            || e.hasChanged(129 /* EditorOption.useTabStops */)\n            || e.hasChanged(50 /* EditorOption.fontInfo */)\n            || e.hasChanged(92 /* EditorOption.readOnly */)\n            || e.hasChanged(131 /* EditorOption.wordSegmenterLocales */));\n    }\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        this.readOnly = options.get(92 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(117 /* EditorOption.stickyTabStops */);\n        this.lineHeight = fontInfo.lineHeight;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(129 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(132 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(77 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(79 /* EditorOption.multiCursorPaste */);\n        this.multiCursorLimit = options.get(80 /* EditorOption.multiCursorLimit */);\n        this.autoClosingBrackets = options.get(6 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingComments = options.get(7 /* EditorOption.autoClosingComments */);\n        this.autoClosingQuotes = options.get(11 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(9 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(10 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(14 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(12 /* EditorOption.autoIndent */);\n        this.wordSegmenterLocales = options.get(131 /* EditorOption.wordSegmenterLocales */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes, true),\n            comment: this._getShouldAutoClose(languageId, this.autoClosingComments, false),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets, false),\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n        const commentsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        this.blockCommentStartToken = commentsConfiguration?.blockCommentStartToken ?? null;\n    }\n    get electricChars() {\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter?.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig, forQuotes) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId, forQuotes);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId, forQuotes) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet(forQuotes);\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0 /* SelectionStartKind.Simple */, 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this.selectionStart = selectionStart;\n        this.selectionStartKind = selectionStartKind;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this._singleCursorStateBrand = undefined;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.selectionStartKind === other.selectionStartKind\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Selection } from '../core/selection.js';\nexport class ReplaceCommand {\n    constructor(range, text, insertsAutoWhitespace = false) {\n        this._range = range;\n        this._text = text;\n        this.insertsAutoWhitespace = insertsAutoWhitespace;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const srcRange = inverseEditOperations[0].range;\n        return Selection.fromPositions(srcRange.getEndPosition());\n    }\n}\nexport class ReplaceCommandThatSelectsText {\n    constructor(range, text) {\n        this._range = range;\n        this._text = text;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const srcRange = inverseEditOperations[0].range;\n        return Selection.fromRange(srcRange, 0 /* SelectionDirection.LTR */);\n    }\n}\nexport class ReplaceCommandWithoutChangingPosition {\n    constructor(range, text, insertsAutoWhitespace = false) {\n        this._range = range;\n        this._text = text;\n        this.insertsAutoWhitespace = insertsAutoWhitespace;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const srcRange = inverseEditOperations[0].range;\n        return Selection.fromPositions(srcRange.getStartPosition());\n    }\n}\nexport class ReplaceCommandWithOffsetCursorState {\n    constructor(range, text, lineNumberDeltaOffset, columnDeltaOffset, insertsAutoWhitespace = false) {\n        this._range = range;\n        this._text = text;\n        this._columnDeltaOffset = columnDeltaOffset;\n        this._lineNumberDeltaOffset = lineNumberDeltaOffset;\n        this.insertsAutoWhitespace = insertsAutoWhitespace;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const srcRange = inverseEditOperations[0].range;\n        return Selection.fromPositions(srcRange.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));\n    }\n}\nexport class ReplaceCommandThatPreservesSelection {\n    constructor(editRange, text, initialSelection, forceMoveMarkers = false) {\n        this._range = editRange;\n        this._text = text;\n        this._initialSelection = initialSelection;\n        this._forceMoveMarkers = forceMoveMarkers;\n        this._selectionId = null;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers);\n        this._selectionId = builder.trackSelection(this._initialSelection);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this._selectionId);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let i = 0;\n        let r;\n        do {\n            r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n            const np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n            if (np.lineNumber > lineNumber) {\n                break;\n            }\n        } while (i++ < 10 && lineNumber + i < model.getLineCount());\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && lastCutRange?.endLineNumber !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _createIntlWord(intlWord, nextCharClass) {\n        // console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n        return { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: 1 /* WordType.Regular */, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return this._createIntlWord(previousIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index) {\n                return this._createIntlWord(nextIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType, hasMulticursor) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (!hasMulticursor // avoid having multiple cursors stop at different locations when doing word start\n                && prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, _intlSegmenterLocales, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position, hasMulticursor) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */, hasMulticursor),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */, hasMulticursor),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.metadata = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { createScopedLineTokens } from '../supports.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\n/**\n * This class is a wrapper class around {@link IndentRulesSupport}.\n * It processes the lines by removing the language configuration brackets from the regex, string and comment tokens.\n * It then calls into the {@link IndentRulesSupport} to validate the indentation conditions.\n */\nexport class ProcessedIndentRulesSupport {\n    constructor(model, indentRulesSupport, languageConfigurationService) {\n        this._indentRulesSupport = indentRulesSupport;\n        this._indentationLineProcessor = new IndentationLineProcessor(model, languageConfigurationService);\n    }\n    /**\n     * Apply the new indentation and return whether the indentation level should be increased after the given line number\n     */\n    shouldIncrease(lineNumber, newIndentation) {\n        const processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n        return this._indentRulesSupport.shouldIncrease(processedLine);\n    }\n    /**\n     * Apply the new indentation and return whether the indentation level should be decreased after the given line number\n     */\n    shouldDecrease(lineNumber, newIndentation) {\n        const processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n        return this._indentRulesSupport.shouldDecrease(processedLine);\n    }\n    /**\n     * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number\n     */\n    shouldIgnore(lineNumber, newIndentation) {\n        const processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n        return this._indentRulesSupport.shouldIgnore(processedLine);\n    }\n    /**\n     * Apply the new indentation and return whether the indentation level should increase on the line after the given line number\n     */\n    shouldIndentNextLine(lineNumber, newIndentation) {\n        const processedLine = this._indentationLineProcessor.getProcessedLine(lineNumber, newIndentation);\n        return this._indentRulesSupport.shouldIndentNextLine(processedLine);\n    }\n}\n/**\n * This class fetches the processed text around a range which can be used for indentation evaluation.\n * It returns:\n * - The processed text before the given range and on the same start line\n * - The processed text after the given range and on the same end line\n * - The processed text on the previous line\n */\nexport class IndentationContextProcessor {\n    constructor(model, languageConfigurationService) {\n        this.model = model;\n        this.indentationLineProcessor = new IndentationLineProcessor(model, languageConfigurationService);\n    }\n    /**\n     * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range\n     */\n    getProcessedTokenContextAroundRange(range) {\n        const beforeRangeProcessedTokens = this._getProcessedTokensBeforeRange(range);\n        const afterRangeProcessedTokens = this._getProcessedTokensAfterRange(range);\n        const previousLineProcessedTokens = this._getProcessedPreviousLineTokens(range);\n        return { beforeRangeProcessedTokens, afterRangeProcessedTokens, previousLineProcessedTokens };\n    }\n    _getProcessedTokensBeforeRange(range) {\n        this.model.tokenization.forceTokenization(range.startLineNumber);\n        const lineTokens = this.model.tokenization.getLineTokens(range.startLineNumber);\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n        let slicedTokens;\n        if (isLanguageDifferentFromLineStart(this.model, range.getStartPosition())) {\n            const columnIndexWithinScope = (range.startColumn - 1) - scopedLineTokens.firstCharOffset;\n            const firstCharacterOffset = scopedLineTokens.firstCharOffset;\n            const lastCharacterOffset = firstCharacterOffset + columnIndexWithinScope;\n            slicedTokens = lineTokens.sliceAndInflate(firstCharacterOffset, lastCharacterOffset, 0);\n        }\n        else {\n            const columnWithinLine = range.startColumn - 1;\n            slicedTokens = lineTokens.sliceAndInflate(0, columnWithinLine, 0);\n        }\n        const processedTokens = this.indentationLineProcessor.getProcessedTokens(slicedTokens);\n        return processedTokens;\n    }\n    _getProcessedTokensAfterRange(range) {\n        const position = range.isEmpty() ? range.getStartPosition() : range.getEndPosition();\n        this.model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = this.model.tokenization.getLineTokens(position.lineNumber);\n        const scopedLineTokens = createScopedLineTokens(lineTokens, position.column - 1);\n        const columnIndexWithinScope = position.column - 1 - scopedLineTokens.firstCharOffset;\n        const firstCharacterOffset = scopedLineTokens.firstCharOffset + columnIndexWithinScope;\n        const lastCharacterOffset = scopedLineTokens.firstCharOffset + scopedLineTokens.getLineLength();\n        const slicedTokens = lineTokens.sliceAndInflate(firstCharacterOffset, lastCharacterOffset, 0);\n        const processedTokens = this.indentationLineProcessor.getProcessedTokens(slicedTokens);\n        return processedTokens;\n    }\n    _getProcessedPreviousLineTokens(range) {\n        const getScopedLineTokensAtEndColumnOfLine = (lineNumber) => {\n            this.model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const endColumnOfLine = this.model.getLineMaxColumn(lineNumber) - 1;\n            const scopedLineTokensAtEndColumn = createScopedLineTokens(lineTokens, endColumnOfLine);\n            return scopedLineTokensAtEndColumn;\n        };\n        this.model.tokenization.forceTokenization(range.startLineNumber);\n        const lineTokens = this.model.tokenization.getLineTokens(range.startLineNumber);\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n        const emptyTokens = LineTokens.createEmpty('', scopedLineTokens.languageIdCodec);\n        const previousLineNumber = range.startLineNumber - 1;\n        const isFirstLine = previousLineNumber === 0;\n        if (isFirstLine) {\n            return emptyTokens;\n        }\n        const canScopeExtendOnPreviousLine = scopedLineTokens.firstCharOffset === 0;\n        if (!canScopeExtendOnPreviousLine) {\n            return emptyTokens;\n        }\n        const scopedLineTokensAtEndColumnOfPreviousLine = getScopedLineTokensAtEndColumnOfLine(previousLineNumber);\n        const doesLanguageContinueOnPreviousLine = scopedLineTokens.languageId === scopedLineTokensAtEndColumnOfPreviousLine.languageId;\n        if (!doesLanguageContinueOnPreviousLine) {\n            return emptyTokens;\n        }\n        const previousSlicedLineTokens = scopedLineTokensAtEndColumnOfPreviousLine.toIViewLineTokens();\n        const processedTokens = this.indentationLineProcessor.getProcessedTokens(previousSlicedLineTokens);\n        return processedTokens;\n    }\n}\n/**\n * This class performs the actual processing of the indentation lines.\n * The brackets of the language configuration are removed from the regex, string and comment tokens.\n */\nclass IndentationLineProcessor {\n    constructor(model, languageConfigurationService) {\n        this.model = model;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    /**\n     * Get the processed line for the given line number and potentially adjust the indentation level.\n     * Remove the language configuration brackets from the regex, string and comment tokens.\n     */\n    getProcessedLine(lineNumber, newIndentation) {\n        const replaceIndentation = (line, newIndentation) => {\n            const currentIndentation = strings.getLeadingWhitespace(line);\n            const adjustedLine = newIndentation + line.substring(currentIndentation.length);\n            return adjustedLine;\n        };\n        this.model.tokenization.forceTokenization?.(lineNumber);\n        const tokens = this.model.tokenization.getLineTokens(lineNumber);\n        let processedLine = this.getProcessedTokens(tokens).getLineContent();\n        if (newIndentation !== undefined) {\n            processedLine = replaceIndentation(processedLine, newIndentation);\n        }\n        return processedLine;\n    }\n    /**\n     * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.\n     */\n    getProcessedTokens(tokens) {\n        const shouldRemoveBracketsFromTokenType = (tokenType) => {\n            return tokenType === 2 /* StandardTokenType.String */\n                || tokenType === 3 /* StandardTokenType.RegEx */\n                || tokenType === 1 /* StandardTokenType.Comment */;\n        };\n        const languageId = tokens.getLanguageId(0);\n        const bracketsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        const bracketsRegExp = bracketsConfiguration.getBracketRegExp({ global: true });\n        const textAndMetadata = [];\n        tokens.forEach((tokenIndex) => {\n            const tokenType = tokens.getStandardTokenType(tokenIndex);\n            let text = tokens.getTokenText(tokenIndex);\n            if (shouldRemoveBracketsFromTokenType(tokenType)) {\n                text = text.replace(bracketsRegExp, '');\n            }\n            const metadata = tokens.getMetadata(tokenIndex);\n            textAndMetadata.push({ text, metadata });\n        });\n        const processedLineTokens = LineTokens.createFromTextAndMetadata(textAndMetadata, tokens.languageIdCodec);\n        return processedLineTokens;\n    }\n}\nexport function isLanguageDifferentFromLineStart(model, position) {\n    model.tokenization.forceTokenization(position.lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, position.column - 1);\n    const doesScopeStartAtOffsetZero = scopedLineTokens.firstCharOffset === 0;\n    const isScopedLanguageEqualToFirstLanguageOnLine = lineTokens.getLanguageId(0) === scopedLineTokens.languageId;\n    const languageIsDifferentFromLineStart = !doesScopeStartAtOffsetZero && !isScopedLanguageEqualToFirstLanguageOnLine;\n    return languageIsDifferentFromLineStart;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndentAction } from './languageConfiguration.js';\nimport { getIndentationAtPosition } from './languageConfigurationRegistry.js';\nimport { IndentationContextProcessor } from './supports/indentationLineProcessor.js';\nexport function getEnterAction(autoIndent, model, range, languageConfigurationService) {\n    model.tokenization.forceTokenization(range.startLineNumber);\n    const languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n    const processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n    const previousLineText = processedContextTokens.previousLineProcessedTokens.getLineContent();\n    const beforeEnterText = processedContextTokens.beforeRangeProcessedTokens.getLineContent();\n    const afterEnterText = processedContextTokens.afterRangeProcessedTokens.getLineContent();\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    if (!enterResult) {\n        return null;\n    }\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0;\n    // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n    if (!appendText) {\n        if ((indentAction === IndentAction.Indent) ||\n            (indentAction === IndentAction.IndentOutdent)) {\n            appendText = '\\t';\n        }\n        else {\n            appendText = '';\n        }\n    }\n    else if (indentAction === IndentAction.Indent) {\n        appendText = '\\t' + appendText;\n    }\n    let indentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    if (removeText) {\n        indentation = indentation.substring(0, indentation.length - removeText);\n    }\n    return {\n        indentAction: indentAction,\n        appendText: appendText,\n        removeText: removeText,\n        indentation: indentation\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ShiftCommand_1;\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nfunction cachedStringRepeat(str, count) {\n    if (count <= 0) {\n        return '';\n    }\n    if (!repeatCache[str]) {\n        repeatCache[str] = ['', str];\n    }\n    const cache = repeatCache[str];\n    for (let i = cache.length; i <= count; i++) {\n        cache[i] = cache[i - 1] + str;\n    }\n    return cache[count];\n}\nlet ShiftCommand = ShiftCommand_1 = class ShiftCommand {\n    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    constructor(range, opts, _languageConfigurationService) {\n        this._languageConfigurationService = _languageConfigurationService;\n        this._opts = opts;\n        this._selection = range;\n        this._selectionId = null;\n        this._useLastEditRangeForCursorEndPosition = false;\n        this._selectionStartColumnStaysPut = false;\n    }\n    _addEditOperation(builder, range, text) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            builder.addTrackedEditOperation(range, text);\n        }\n        else {\n            builder.addEditOperation(range, text);\n        }\n    }\n    getEditOperations(model, builder) {\n        const startLine = this._selection.startLineNumber;\n        let endLine = this._selection.endLineNumber;\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\n            endLine = endLine - 1;\n        }\n        const { tabSize, indentSize, insertSpaces } = this._opts;\n        const shouldIndentEmptyLines = (startLine === endLine);\n        if (this._opts.useTabStops) {\n            // if indenting or outdenting on a whitespace only line\n            if (this._selection.isEmpty()) {\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\n                    this._useLastEditRangeForCursorEndPosition = true;\n                }\n            }\n            // keep track of previous line's \"miss-alignment\"\n            let previousLineExtraSpaces = 0, extraSpaces = 0;\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n                extraSpaces = 0;\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (lineNumber > 1) {\n                    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n                    if (contentStartVisibleColumn % indentSize !== 0) {\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\n                        // This can only happen when it has trailing commas in the indent\n                        if (model.tokenization.isCheapToTokenize(lineNumber - 1)) {\n                            const enterAction = getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)), this._languageConfigurationService);\n                            if (enterAction) {\n                                extraSpaces = previousLineExtraSpaces;\n                                if (enterAction.appendText) {\n                                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* CharCode.Space */) {\n                                            extraSpaces++;\n                                        }\n                                        else {\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (enterAction.removeText) {\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                                }\n                                // Act as if `prefixSpaces` is not part of the indentation\n                                for (let j = 0; j < extraSpaces; j++) {\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* CharCode.Space */) {\n                                        break;\n                                    }\n                                    indentationEndIndex--;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                let desiredIndent;\n                if (this._opts.isUnshift) {\n                    desiredIndent = ShiftCommand_1.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                else {\n                    desiredIndent = ShiftCommand_1.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\n                    // Force the startColumn to stay put because we're inserting after it\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n                }\n            }\n        }\n        else {\n            // if indenting or outdenting on a whitespace only line\n            if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n                this._useLastEditRangeForCursorEndPosition = true;\n            }\n            const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (this._opts.isUnshift) {\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n                    for (let i = 0; i < indentationEndIndex; i++) {\n                        const chr = lineText.charCodeAt(i);\n                        if (chr === 9 /* CharCode.Tab */) {\n                            indentationEndIndex = i + 1;\n                            break;\n                        }\n                    }\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n                }\n                else {\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\n                        // Force the startColumn to stay put because we're inserting after it\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            const lastOp = helper.getInverseEditOperations()[0];\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n        }\n        const result = helper.getTrackedSelection(this._selectionId);\n        if (this._selectionStartColumnStaysPut) {\n            // The selection start should not move\n            const initialStartColumn = this._selection.startColumn;\n            const resultStartColumn = result.startColumn;\n            if (resultStartColumn <= initialStartColumn) {\n                return result;\n            }\n            if (result.getDirection() === 0 /* SelectionDirection.LTR */) {\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n            }\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n        }\n        return result;\n    }\n};\nShiftCommand = ShiftCommand_1 = __decorate([\n    __param(2, ILanguageConfigurationService)\n], ShiftCommand);\nexport { ShiftCommand };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class SurroundSelectionCommand {\n    constructor(range, charBeforeSelection, charAfterSelection) {\n        this._range = range;\n        this._charBeforeSelection = charBeforeSelection;\n        this._charAfterSelection = charAfterSelection;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(new Range(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection);\n        builder.addTrackedEditOperation(new Range(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const firstOperationRange = inverseEditOperations[0].range;\n        const secondOperationRange = inverseEditOperations[1].range;\n        return new Selection(firstOperationRange.endLineNumber, firstOperationRange.endColumn, secondOperationRange.endLineNumber, secondOperationRange.endColumn - this._charAfterSelection.length);\n    }\n}\n/**\n * A surround selection command that runs after composition finished.\n */\nexport class CompositionSurroundSelectionCommand {\n    constructor(_position, _text, _charAfter) {\n        this._position = _position;\n        this._text = _text;\n        this._charAfter = _charAfter;\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(new Range(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column), this._text + this._charAfter);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const opRange = inverseEditOperations[0].range;\n        return new Selection(opRange.endLineNumber, opRange.startColumn, opRange.endLineNumber, opRange.endColumn - this._charAfter.length);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { IndentationContextProcessor, isLanguageDifferentFromLineStart, ProcessedIndentRulesSupport } from './supports/indentationLineProcessor.js';\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model, lineNumber, processedIndentRulesSupport) {\n    const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n    if (lineNumber > 1) {\n        let lastLineNumber;\n        let resultLineNumber = -1;\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n            if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                return resultLineNumber;\n            }\n            const text = model.getLineContent(lastLineNumber);\n            if (processedIndentRulesSupport.shouldIgnore(lastLineNumber) || /^\\s+$/.test(text) || text === '') {\n                resultLineNumber = lastLineNumber;\n                continue;\n            }\n            return lastLineNumber;\n        }\n    }\n    return -1;\n}\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const processedIndentRulesSupport = new ProcessedIndentRulesSupport(model, indentRulesSupport, languageConfigurationService);\n    if (lineNumber <= 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    // Use no indent if this is the first non-blank line\n    for (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n        if (model.getLineContent(priorLineNumber) !== '') {\n            break;\n        }\n        if (priorLineNumber === 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n    }\n    const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, processedIndentRulesSupport);\n    if (precedingUnIgnoredLine < 0) {\n        return null;\n    }\n    else if (precedingUnIgnoredLine < 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    if (processedIndentRulesSupport.shouldIncrease(precedingUnIgnoredLine) || processedIndentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLine)) {\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: IndentAction.Indent,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else if (processedIndentRulesSupport.shouldDecrease(precedingUnIgnoredLine)) {\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: null,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else {\n        // precedingUnIgnoredLine can not be ignored.\n        // it doesn't increase indent of following lines\n        // it doesn't increase just next line\n        // so current line is not affect by precedingUnIgnoredLine\n        // and then we should get a correct inheritted indentation from above lines\n        if (precedingUnIgnoredLine === 1) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        const previousLine = precedingUnIgnoredLine - 1;\n        const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n        if (!(previousLineIndentMetadata & (1 /* IndentConsts.INCREASE_MASK */ | 2 /* IndentConsts.DECREASE_MASK */)) &&\n            (previousLineIndentMetadata & 4 /* IndentConsts.INDENT_NEXTLINE_MASK */)) {\n            let stopLine = 0;\n            for (let i = previousLine - 1; i > 0; i--) {\n                if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n                    continue;\n                }\n                stopLine = i;\n                break;\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                action: null,\n                line: stopLine + 1\n            };\n        }\n        if (honorIntentialIndent) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n            for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                if (processedIndentRulesSupport.shouldIncrease(i)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n                        action: IndentAction.Indent,\n                        line: i\n                    };\n                }\n                else if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n                    let stopLine = 0;\n                    for (let j = i - 1; j > 0; j--) {\n                        if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n                            continue;\n                        }\n                        stopLine = j;\n                        break;\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                        action: null,\n                        line: stopLine + 1\n                    };\n                }\n                else if (processedIndentRulesSupport.shouldDecrease(i)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n                        action: null,\n                        line: i\n                    };\n                }\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                action: null,\n                line: 1\n            };\n        }\n    }\n}\nexport function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const processedIndentRulesSupport = new ProcessedIndentRulesSupport(virtualModel, indentRulesSupport, languageConfigurationService);\n    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n    if (indent) {\n        const inheritLine = indent.line;\n        if (inheritLine !== undefined) {\n            // Apply enter action as long as there are only whitespace lines between inherited line and this line.\n            let shouldApplyEnterRules = true;\n            for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n                if (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n                    shouldApplyEnterRules = false;\n                    break;\n                }\n            }\n            if (shouldApplyEnterRules) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n        }\n        if (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n            if (indent.action === IndentAction.Indent) {\n                return indent.indentation;\n            }\n            else {\n                return indentConverter.unshiftIndent(indent.indentation);\n            }\n        }\n        else {\n            if (indent.action === IndentAction.Indent) {\n                return indentConverter.shiftIndent(indent.indentation);\n            }\n            else {\n                return indent.indentation;\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    model.tokenization.forceTokenization(range.startLineNumber);\n    const indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n    const processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n    const afterEnterProcessedTokens = processedContextTokens.afterRangeProcessedTokens;\n    const beforeEnterProcessedTokens = processedContextTokens.beforeRangeProcessedTokens;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterProcessedTokens.getLineContent());\n    const virtualModel = createVirtualModelWithModifiedTokensAtLine(model, range.startLineNumber, beforeEnterProcessedTokens);\n    const languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n    const currentLine = model.getLineContent(range.startLineNumber);\n    const currentLineIndent = strings.getLeadingWhitespace(currentLine);\n    const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n    if (!afterEnterAction) {\n        const beforeEnter = languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent;\n        return {\n            beforeEnter: beforeEnter,\n            afterEnter: beforeEnter\n        };\n    }\n    let afterEnterIndent = languageIsDifferentFromLineStart ? currentLineIndent : afterEnterAction.indentation;\n    if (afterEnterAction.action === IndentAction.Indent) {\n        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n    if (indentRulesSupport.shouldDecrease(afterEnterProcessedTokens.getLineContent())) {\n        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n    return {\n        beforeEnter: languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent,\n        afterEnter: afterEnterIndent\n    };\n}\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(cursorConfig, model, range, ch, indentConverter, languageConfigurationService) {\n    const autoIndent = cursorConfig.autoIndent;\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n    if (languageIsDifferentFromLineStart) {\n        // this line has mixed languages and indentation rules will not work\n        return null;\n    }\n    const languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n    const processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n    const beforeRangeText = processedContextTokens.beforeRangeProcessedTokens.getLineContent();\n    const afterRangeText = processedContextTokens.afterRangeProcessedTokens.getLineContent();\n    const textAroundRange = beforeRangeText + afterRangeText;\n    const textAroundRangeWithCharacter = beforeRangeText + ch + afterRangeText;\n    // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n    if (!indentRulesSupport.shouldDecrease(textAroundRange) && indentRulesSupport.shouldDecrease(textAroundRangeWithCharacter)) {\n        // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n        // 1. Get inherited indent action\n        const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n        if (!r) {\n            return null;\n        }\n        let indentation = r.indentation;\n        if (r.action !== IndentAction.Indent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n        }\n        return indentation;\n    }\n    const previousLineNumber = range.startLineNumber - 1;\n    if (previousLineNumber > 0) {\n        const previousLine = model.getLineContent(previousLineNumber);\n        if (indentRulesSupport.shouldIndentNextLine(previousLine) && indentRulesSupport.shouldIncrease(textAroundRangeWithCharacter)) {\n            const inheritedIndentationData = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n            const inheritedIndentation = inheritedIndentationData?.indentation;\n            if (inheritedIndentation !== undefined) {\n                const currentLine = model.getLineContent(range.startLineNumber);\n                const actualCurrentIndentation = strings.getLeadingWhitespace(currentLine);\n                const inferredCurrentIndentation = indentConverter.shiftIndent(inheritedIndentation);\n                // If the inferred current indentation is not equal to the actual current indentation, then the indentation has been intentionally changed, in that case keep it\n                const inferredIndentationEqualsActual = inferredCurrentIndentation === actualCurrentIndentation;\n                const textAroundRangeContainsOnlyWhitespace = /^\\s*$/.test(textAroundRange);\n                const autoClosingPairs = cursorConfig.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n                const autoClosingPairExists = autoClosingPairs && autoClosingPairs.length > 0;\n                const isChFirstNonWhitespaceCharacterAndInAutoClosingPair = autoClosingPairExists && textAroundRangeContainsOnlyWhitespace;\n                if (inferredIndentationEqualsActual && isChFirstNonWhitespaceCharacterAndInAutoClosingPair) {\n                    return inheritedIndentation;\n                }\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentMetadata(model, lineNumber, languageConfigurationService) {\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n        return null;\n    }\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\nfunction createVirtualModelWithModifiedTokensAtLine(model, modifiedLineNumber, modifiedTokens) {\n    const virtualModel = {\n        tokenization: {\n            getLineTokens: (lineNumber) => {\n                if (lineNumber === modifiedLineNumber) {\n                    return modifiedTokens;\n                }\n                else {\n                    return model.tokenization.getLineTokens(lineNumber);\n                }\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n        },\n        getLineContent: (lineNumber) => {\n            if (lineNumber === modifiedLineNumber) {\n                return modifiedTokens.getLineContent();\n            }\n            else {\n                return model.getLineContent(lineNumber);\n            }\n        }\n    };\n    return virtualModel;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class AutoIndentOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const indentationForSelections = [];\n            for (const selection of selections) {\n                const indentation = this._findActualIndentationForSelection(config, model, selection, ch);\n                if (indentation === null) {\n                    // Auto indentation failed\n                    return;\n                }\n                indentationForSelections.push({ selection, indentation });\n            }\n            const autoClosingPairClose = AutoClosingOpenCharTypeOperation.getAutoClosingPairClose(config, model, selections, ch, false);\n            return this._getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose);\n        }\n        return;\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _findActualIndentationForSelection(config, model, selection, ch) {\n        const actualIndentation = getIndentActionForType(config, model, selection, ch, {\n            shiftIndent: (indentation) => {\n                return shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        const currentIndentation = getIndentationAtPosition(model, selection.startLineNumber, selection.startColumn);\n        if (actualIndentation === config.normalizeIndentation(currentIndentation)) {\n            return null;\n        }\n        return actualIndentation;\n    }\n    static _getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose) {\n        const commands = indentationForSelections.map(({ selection, indentation }) => {\n            if (autoClosingPairClose !== null) {\n                // Apply both auto closing pair edits and auto indentation edits\n                const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, false);\n                return new TypeWithIndentationAndAutoClosingCommand(indentationEdit, selection, ch, autoClosingPairClose);\n            }\n            else {\n                // Apply only auto indentation edits\n                const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, true);\n                return typeCommand(indentationEdit.range, indentationEdit.text, false);\n            }\n        });\n        const editOptions = { shouldPushStackElementBefore: true, shouldPushStackElementAfter: false };\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, editOptions);\n    }\n    static _getEditFromIndentationAndSelection(config, model, indentation, selection, ch, includeChInEdit = true) {\n        const startLineNumber = selection.startLineNumber;\n        const firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(startLineNumber);\n        let text = config.normalizeIndentation(indentation);\n        if (firstNonWhitespaceColumn !== 0) {\n            const startLine = model.getLineContent(startLineNumber);\n            text += startLine.substring(firstNonWhitespaceColumn - 1, selection.startColumn - 1);\n        }\n        text += includeChInEdit ? ch : '';\n        const range = new Range(startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n        return { range, text };\n    }\n}\nexport class AutoClosingOvertypeOperation {\n    static getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, selections, ch);\n        }\n        return;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n    static getEdits(config, model, selections, autoClosedCharacters, ch) {\n        if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        return;\n    }\n}\nexport class AutoClosingOpenCharTypeOperation {\n    static getEdits(config, model, selections, ch, chIsAlreadyTyped, isDoingComposition) {\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this.getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped);\n            if (autoClosingPairClose !== null) {\n                return this._runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose);\n            }\n        }\n        return;\n    }\n    static _runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        let autoCloseConfig;\n        let shouldAutoCloseBefore;\n        const chIsQuote = isQuote(ch);\n        if (chIsQuote) {\n            autoCloseConfig = config.autoClosingQuotes;\n            shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n        }\n        else {\n            const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n            if (pairIsForComments) {\n                autoCloseConfig = config.autoClosingComments;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n            }\n            else {\n                autoCloseConfig = config.autoClosingBrackets;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n            }\n        }\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = this._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n}\nexport class SurroundSelectionOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(config, selections, ch);\n        }\n        return;\n    }\n    static _runSurroundSelectionType(config, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\nexport class InterceptorElectricCharOperation {\n    static getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition) {\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        return;\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n}\nexport class SimpleCharacterTypeOperation {\n    static getEdits(prevEditOperationType, selections, ch) {\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class EnterOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        return;\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = unshiftIndent(config, r.indentation);\n                return typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class PasteOperation {\n    static getEdits(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substring(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substring(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\nexport class CompositionOperation {\n    static getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n}\nexport class TypeWithoutInterceptorsOperation {\n    static getEdits(prevEditOperationType, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class TabOperation {\n    static getCommands(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n}\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter) {\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    _computeCursorStateWithRange(model, range, helper) {\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        const text = (insertOpenCharacter ? openCharacter : '') + closeCharacter;\n        const lineNumberDeltaOffset = 0;\n        const columnDeltaOffset = -closeCharacter.length;\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        return this._computeCursorStateWithRange(model, range, helper);\n    }\n}\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n    constructor(autoIndentationEdit, selection, openCharacter, closeCharacter) {\n        const text = openCharacter + closeCharacter;\n        const lineNumberDeltaOffset = 0;\n        const columnDeltaOffset = openCharacter.length;\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n        this._autoIndentationEdit = autoIndentationEdit;\n        this._autoClosingEdit = { range: selection, text };\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text);\n        builder.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        if (inverseEditOperations.length !== 2) {\n            throw new Error('There should be two inverse edit operations!');\n        }\n        const range1 = inverseEditOperations[0].range;\n        const range2 = inverseEditOperations[1].range;\n        const range = range1.plusRange(range2);\n        return this._computeCursorStateWithRange(model, range, helper);\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\nfunction isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n        return false;\n    }\n    if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n        return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n        const selection = selections[i];\n        if (!selection.isEmpty()) {\n            return false;\n        }\n        const position = selection.getPosition();\n        const lineText = model.getLineContent(position.lineNumber);\n        const afterCharacter = lineText.charAt(position.column - 1);\n        if (afterCharacter !== ch) {\n            return false;\n        }\n        // Do not over-type quotes after a backslash\n        const chIsQuote = isQuote(ch);\n        const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n        if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n            return false;\n        }\n        // Must over-type a closing character typed by the editor\n        if (config.autoClosingOvertype === 'auto') {\n            let found = false;\n            for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                const autoClosedCharacter = autoClosedCharacters[j];\n                if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction typeCommand(range, text, keepPosition) {\n    if (keepPosition) {\n        return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    }\n    else {\n        return new ReplaceCommand(range, text, true);\n    }\n}\nexport function shiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function unshiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function shouldSurroundChar(config, ch) {\n    if (isQuote(ch)) {\n        return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n    }\n    else {\n        // Character is a bracket\n        return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { AutoClosingOpenCharTypeOperation, AutoClosingOvertypeOperation, AutoClosingOvertypeWithInterceptorsOperation, AutoIndentOperation, CompositionOperation, EnterOperation, InterceptorElectricCharOperation, PasteOperation, shouldSurroundChar, SimpleCharacterTypeOperation, SurroundSelectionOperation, TabOperation, TypeWithoutInterceptorsOperation } from './cursorTypeEditOperations.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        return PasteOperation.getEdits(config, model, selections, text, pasteOnNewLine, multicursorText);\n    }\n    static tab(config, model, selections) {\n        return TabOperation.getCommands(config, model, selections);\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        return CompositionOperation.getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingOvertypeEdits = AutoClosingOvertypeWithInterceptorsOperation.getEdits(config, model, selections, autoClosedCharacters, ch);\n        if (autoClosingOvertypeEdits !== undefined) {\n            return autoClosingOvertypeEdits;\n        }\n        const autoClosingOpenCharEdits = AutoClosingOpenCharTypeOperation.getEdits(config, model, selections, ch, true, false);\n        if (autoClosingOpenCharEdits !== undefined) {\n            return autoClosingOpenCharEdits;\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        const enterEdits = EnterOperation.getEdits(config, model, selections, ch, isDoingComposition);\n        if (enterEdits !== undefined) {\n            return enterEdits;\n        }\n        const autoIndentEdits = AutoIndentOperation.getEdits(config, model, selections, ch, isDoingComposition);\n        if (autoIndentEdits !== undefined) {\n            return autoIndentEdits;\n        }\n        const autoClosingOverTypeEdits = AutoClosingOvertypeOperation.getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch);\n        if (autoClosingOverTypeEdits !== undefined) {\n            return autoClosingOverTypeEdits;\n        }\n        const autoClosingOpenCharEdits = AutoClosingOpenCharTypeOperation.getEdits(config, model, selections, ch, false, isDoingComposition);\n        if (autoClosingOpenCharEdits !== undefined) {\n            return autoClosingOpenCharEdits;\n        }\n        const surroundSelectionEdits = SurroundSelectionOperation.getEdits(config, model, selections, ch, isDoingComposition);\n        if (surroundSelectionEdits !== undefined) {\n            return surroundSelectionEdits;\n        }\n        const interceptorElectricCharOperation = InterceptorElectricCharOperation.getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition);\n        if (interceptorElectricCharOperation !== undefined) {\n            return interceptorElectricCharOperation;\n        }\n        return SimpleCharacterTypeOperation.getEdits(prevEditOperationType, selections, ch);\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        return TypeWithoutInterceptorsOperation.getEdits(prevEditOperationType, selections, str);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read-only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', \"Whether the context is an embedded diff editor\"));\n    EditorContextKeys.inMultiDiffEditor = new RawContextKey('inMultiDiffEditor', false, nls.localize('inMultiDiffEditor', \"Whether the context is a multi diff editor\"));\n    EditorContextKeys.multiDiffEditorAllCollapsed = new RawContextKey('multiDiffEditorAllCollapsed', undefined, nls.localize('multiDiffEditorAllCollapsed', \"Whether all files in multi diff editor are collapsed\"));\n    EditorContextKeys.hasChanges = new RawContextKey('diffEditorHasChanges', false, nls.localize('diffEditorHasChanges', \"Whether the diff editor has changes\"));\n    EditorContextKeys.comparingMovedCode = new RawContextKey('comparingMovedCode', false, nls.localize('comparingMovedCode', \"Whether a moved code block is selected for comparison\"));\n    EditorContextKeys.accessibleDiffViewerVisible = new RawContextKey('accessibleDiffViewerVisible', false, nls.localize('accessibleDiffViewerVisible', \"Whether the accessible diff viewer is visible\"));\n    EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached = new RawContextKey('diffEditorRenderSideBySideInlineBreakpointReached', false, nls.localize('diffEditorRenderSideBySideInlineBreakpointReached', \"Whether the diff editor render side by side inline breakpoint is reached\"));\n    EditorContextKeys.diffEditorInlineMode = new RawContextKey('diffEditorInlineMode', false, nls.localize('diffEditorInlineMode', \"Whether inline mode is active\"));\n    EditorContextKeys.diffEditorOriginalWritable = new RawContextKey('diffEditorOriginalWritable', false, nls.localize('diffEditorOriginalWritable', \"Whether modified is writable in the diff editor\"));\n    EditorContextKeys.diffEditorModifiedWritable = new RawContextKey('diffEditorModifiedWritable', false, nls.localize('diffEditorModifiedWritable', \"Whether modified is writable in the diff editor\"));\n    EditorContextKeys.diffEditorOriginalUri = new RawContextKey('diffEditorOriginalUri', '', nls.localize('diffEditorOriginalUri', \"The uri of the original document\"));\n    EditorContextKeys.diffEditorModifiedUri = new RawContextKey('diffEditorModifiedUri', '', nls.localize('diffEditorModifiedUri', \"The uri of the modified document\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInEmbeddedEditor = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', \"Whether the editor hover is focused\"));\n    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', \"Whether the sticky scroll is focused\"));\n    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', \"Whether the sticky scroll is visible\"));\n    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', \"Whether the standalone color picker is visible\"));\n    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', \"Whether the standalone color picker is focused\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    static { this.Empty = new RGBA8(0, 0, 0, 0); }\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, markAsSingleton } from '../../../base/common/lifecycle.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../languages.js';\nexport class MinimapTokensColorTracker extends Disposable {\n    static { this._INSTANCE = null; }\n    static getInstance() {\n        if (!this._INSTANCE) {\n            this._INSTANCE = markAsSingleton(new MinimapTokensColorTracker());\n        }\n        return this._INSTANCE;\n    }\n    constructor() {\n        super();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._updateColorMap();\n        this._register(TokenizationRegistry.onDidChange(e => {\n            if (e.changedColorMap) {\n                this._updateColorMap();\n            }\n        }));\n    }\n    _updateColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        if (!colorMap) {\n            this._colors = [RGBA8.Empty];\n            this._backgroundIsLight = true;\n            return;\n        }\n        this._colors = [RGBA8.Empty];\n        for (let colorId = 1; colorId < colorMap.length; colorId++) {\n            const source = colorMap[colorId].rgba;\n            // Use a VM friendly data-type\n            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n        }\n        const backgroundLuminosity = colorMap[2 /* ColorId.DefaultBackground */].getRelativeLuminance();\n        this._backgroundIsLight = backgroundLuminosity >= 0.5;\n        this._onDidChange.fire(undefined);\n    }\n    getColor(colorId) {\n        if (colorId < 1 || colorId >= this._colors.length) {\n            // background color (basically invisible)\n            colorId = 2 /* ColorId.DefaultBackground */;\n        }\n        return this._colors[colorId];\n    }\n    backgroundIsLight() {\n        return this._backgroundIsLight;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ColorZone {\n    constructor(from, to, colorId) {\n        this._colorZoneBrand = undefined;\n        this.from = from | 0;\n        this.to = to | 0;\n        this.colorId = colorId | 0;\n    }\n    static compare(a, b) {\n        if (a.colorId === b.colorId) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n        return a.colorId - b.colorId;\n    }\n}\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n    constructor(startLineNumber, endLineNumber, heightInLines, color) {\n        this._overviewRulerZoneBrand = undefined;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.heightInLines = heightInLines;\n        this.color = color;\n        this._colorZone = null;\n    }\n    static compare(a, b) {\n        if (a.color === b.color) {\n            if (a.startLineNumber === b.startLineNumber) {\n                if (a.heightInLines === b.heightInLines) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.heightInLines - b.heightInLines;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        }\n        return a.color < b.color ? -1 : 1;\n    }\n    setColorZone(colorZone) {\n        this._colorZone = colorZone;\n    }\n    getColorZones() {\n        return this._colorZone;\n    }\n}\nexport class OverviewZoneManager {\n    constructor(getVerticalOffsetForLine) {\n        this._getVerticalOffsetForLine = getVerticalOffsetForLine;\n        this._zones = [];\n        this._colorZonesInvalid = false;\n        this._lineHeight = 0;\n        this._domWidth = 0;\n        this._domHeight = 0;\n        this._outerHeight = 0;\n        this._pixelRatio = 1;\n        this._lastAssignedId = 0;\n        this._color2Id = Object.create(null);\n        this._id2Color = [];\n    }\n    getId2Color() {\n        return this._id2Color;\n    }\n    setZones(newZones) {\n        this._zones = newZones;\n        this._zones.sort(OverviewRulerZone.compare);\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return false;\n        }\n        this._lineHeight = lineHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this._colorZonesInvalid = true;\n    }\n    getDOMWidth() {\n        return this._domWidth;\n    }\n    getCanvasWidth() {\n        return this._domWidth * this._pixelRatio;\n    }\n    setDOMWidth(width) {\n        if (this._domWidth === width) {\n            return false;\n        }\n        this._domWidth = width;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getDOMHeight() {\n        return this._domHeight;\n    }\n    getCanvasHeight() {\n        return this._domHeight * this._pixelRatio;\n    }\n    setDOMHeight(height) {\n        if (this._domHeight === height) {\n            return false;\n        }\n        this._domHeight = height;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getOuterHeight() {\n        return this._outerHeight;\n    }\n    setOuterHeight(outerHeight) {\n        if (this._outerHeight === outerHeight) {\n            return false;\n        }\n        this._outerHeight = outerHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    resolveColorZones() {\n        const colorZonesInvalid = this._colorZonesInvalid;\n        const lineHeight = Math.floor(this._lineHeight);\n        const totalHeight = Math.floor(this.getCanvasHeight());\n        const outerHeight = Math.floor(this._outerHeight);\n        const heightRatio = totalHeight / outerHeight;\n        const halfMinimumHeight = Math.floor(4 /* Constants.MINIMUM_HEIGHT */ * this._pixelRatio / 2);\n        const allColorZones = [];\n        for (let i = 0, len = this._zones.length; i < len; i++) {\n            const zone = this._zones[i];\n            if (!colorZonesInvalid) {\n                const colorZone = zone.getColorZones();\n                if (colorZone) {\n                    allColorZones.push(colorZone);\n                    continue;\n                }\n            }\n            const offset1 = this._getVerticalOffsetForLine(zone.startLineNumber);\n            const offset2 = (zone.heightInLines === 0\n                ? this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight\n                : offset1 + zone.heightInLines * lineHeight);\n            const y1 = Math.floor(heightRatio * offset1);\n            const y2 = Math.floor(heightRatio * offset2);\n            let ycenter = Math.floor((y1 + y2) / 2);\n            let halfHeight = (y2 - ycenter);\n            if (halfHeight < halfMinimumHeight) {\n                halfHeight = halfMinimumHeight;\n            }\n            if (ycenter - halfHeight < 0) {\n                ycenter = halfHeight;\n            }\n            if (ycenter + halfHeight > totalHeight) {\n                ycenter = totalHeight - halfHeight;\n            }\n            const color = zone.color;\n            let colorId = this._color2Id[color];\n            if (!colorId) {\n                colorId = (++this._lastAssignedId);\n                this._color2Id[color] = colorId;\n                this._id2Color[colorId] = color;\n            }\n            const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);\n            zone.setColorZone(colorZone);\n            allColorZones.push(colorZone);\n        }\n        this._colorZonesInvalid = false;\n        allColorZones.sort(ColorZone.compare);\n        return allColorZones;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n    constructor(selections, partialData, whitespaceViewportData, model) {\n        this.selections = selections;\n        this.startLineNumber = partialData.startLineNumber | 0;\n        this.endLineNumber = partialData.endLineNumber | 0;\n        this.relativeVerticalOffset = partialData.relativeVerticalOffset;\n        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n        this.lineHeight = partialData.lineHeight | 0;\n        this.whitespaceViewportData = whitespaceViewportData;\n        this._model = model;\n        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));\n    }\n    getViewLineRenderingData(lineNumber) {\n        return this._model.getViewportViewLineRenderingData(this.visibleRange, lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this._model.getDecorationsInViewport(this.visibleRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorTheme } from '../editorTheme.js';\nexport class ViewContext {\n    constructor(configuration, theme, model) {\n        this.configuration = configuration;\n        this.theme = new EditorTheme(theme);\n        this.viewModel = model;\n        this.viewLayout = model.viewLayout;\n    }\n    addEventHandler(eventHandler) {\n        this.viewModel.addViewEventHandler(eventHandler);\n    }\n    removeEventHandler(eventHandler) {\n        this.viewModel.removeViewEventHandler(eventHandler);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, metadata, _precondition, _run, _contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this.metadata = metadata;\n        this._precondition = _precondition;\n        this._run = _run;\n        this._contextKeyService = _contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run(args) {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run(args);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(135 /* EditorOption.wordWrapBreakBeforeCharacters */), options.get(134 /* EditorOption.wordWrapBreakAfterCharacters */));\n    }\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* CharacterClass.NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* CharacterClass.BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* CharacterClass.BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* CharacterClass.BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* CharCode.Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* CharacterClass.NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* CharacterClass.NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* CharCode.Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* CharacterClass.NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* CharacterClass.NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* CharCode.Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) {\n    return (charCode !== 32 /* CharCode.Space */\n        && ((prevCharCodeClass === 2 /* CharacterClass.BREAK_AFTER */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */) // break at the end of multiple BREAK_AFTER\n            || (prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */ && charCodeClass === 1 /* CharacterClass.BREAK_BEFORE */) // break at the start of multiple BREAK_BEFORE\n            || (!isKeepAll && prevCharCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */)\n            || (!isKeepAll && charCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n            // Avoid selecting text when recovering from markers\n            return Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n        }\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy } from '../../../base/common/arrays.js';\nimport { findLastMax, findFirstMin } from '../../../base/common/arraysFind.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findFirstMin(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMax(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ViewCompositionStartEvent {\n    constructor() {\n        this.type = 0 /* ViewEventType.ViewCompositionStart */;\n    }\n}\nexport class ViewCompositionEndEvent {\n    constructor() {\n        this.type = 1 /* ViewEventType.ViewCompositionEnd */;\n    }\n}\nexport class ViewConfigurationChangedEvent {\n    constructor(source) {\n        this.type = 2 /* ViewEventType.ViewConfigurationChanged */;\n        this._source = source;\n    }\n    hasChanged(id) {\n        return this._source.hasChanged(id);\n    }\n}\nexport class ViewCursorStateChangedEvent {\n    constructor(selections, modelSelections, reason) {\n        this.selections = selections;\n        this.modelSelections = modelSelections;\n        this.reason = reason;\n        this.type = 3 /* ViewEventType.ViewCursorStateChanged */;\n    }\n}\nexport class ViewDecorationsChangedEvent {\n    constructor(source) {\n        this.type = 4 /* ViewEventType.ViewDecorationsChanged */;\n        if (source) {\n            this.affectsMinimap = source.affectsMinimap;\n            this.affectsOverviewRuler = source.affectsOverviewRuler;\n            this.affectsGlyphMargin = source.affectsGlyphMargin;\n            this.affectsLineNumber = source.affectsLineNumber;\n        }\n        else {\n            this.affectsMinimap = true;\n            this.affectsOverviewRuler = true;\n            this.affectsGlyphMargin = true;\n            this.affectsLineNumber = true;\n        }\n    }\n}\nexport class ViewFlushedEvent {\n    constructor() {\n        this.type = 5 /* ViewEventType.ViewFlushed */;\n        // Nothing to do\n    }\n}\nexport class ViewFocusChangedEvent {\n    constructor(isFocused) {\n        this.type = 6 /* ViewEventType.ViewFocusChanged */;\n        this.isFocused = isFocused;\n    }\n}\nexport class ViewLanguageConfigurationEvent {\n    constructor() {\n        this.type = 7 /* ViewEventType.ViewLanguageConfigurationChanged */;\n    }\n}\nexport class ViewLineMappingChangedEvent {\n    constructor() {\n        this.type = 8 /* ViewEventType.ViewLineMappingChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewLinesChangedEvent {\n    constructor(\n    /**\n     * The first line that has changed.\n     */\n    fromLineNumber, \n    /**\n     * The number of lines that have changed.\n     */\n    count) {\n        this.fromLineNumber = fromLineNumber;\n        this.count = count;\n        this.type = 9 /* ViewEventType.ViewLinesChanged */;\n    }\n}\nexport class ViewLinesDeletedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 10 /* ViewEventType.ViewLinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesInsertedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 11 /* ViewEventType.ViewLinesInserted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewRevealRangeRequestEvent {\n    constructor(\n    /**\n     * Source of the call that caused the event.\n     */\n    source, \n    /**\n     * Reduce the revealing to a minimum (e.g. avoid scrolling if the bounding box is visible and near the viewport edge).\n     */\n    minimalReveal, \n    /**\n     * Range to be reavealed.\n     */\n    range, \n    /**\n     * Selections to be revealed.\n     */\n    selections, \n    /**\n     * The vertical reveal strategy.\n     */\n    verticalType, \n    /**\n     * If true: there should be a horizontal & vertical revealing.\n     * If false: there should be just a vertical revealing.\n     */\n    revealHorizontal, \n    /**\n     * The scroll type.\n     */\n    scrollType) {\n        this.source = source;\n        this.minimalReveal = minimalReveal;\n        this.range = range;\n        this.selections = selections;\n        this.verticalType = verticalType;\n        this.revealHorizontal = revealHorizontal;\n        this.scrollType = scrollType;\n        this.type = 12 /* ViewEventType.ViewRevealRangeRequest */;\n    }\n}\nexport class ViewScrollChangedEvent {\n    constructor(source) {\n        this.type = 13 /* ViewEventType.ViewScrollChanged */;\n        this.scrollWidth = source.scrollWidth;\n        this.scrollLeft = source.scrollLeft;\n        this.scrollHeight = source.scrollHeight;\n        this.scrollTop = source.scrollTop;\n        this.scrollWidthChanged = source.scrollWidthChanged;\n        this.scrollLeftChanged = source.scrollLeftChanged;\n        this.scrollHeightChanged = source.scrollHeightChanged;\n        this.scrollTopChanged = source.scrollTopChanged;\n    }\n}\nexport class ViewThemeChangedEvent {\n    constructor(theme) {\n        this.theme = theme;\n        this.type = 14 /* ViewEventType.ViewThemeChanged */;\n    }\n}\nexport class ViewTokensChangedEvent {\n    constructor(ranges) {\n        this.type = 15 /* ViewEventType.ViewTokensChanged */;\n        this.ranges = ranges;\n    }\n}\nexport class ViewTokensColorsChangedEvent {\n    constructor() {\n        this.type = 16 /* ViewEventType.ViewTokensColorsChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.type = 17 /* ViewEventType.ViewZonesChanged */;\n        // Nothing to do\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewModelEventDispatcher extends Disposable {\n    constructor() {\n        super();\n        this._onEvent = this._register(new Emitter());\n        this.onEvent = this._onEvent.event;\n        this._eventHandlers = [];\n        this._viewEventQueue = null;\n        this._isConsumingViewEventQueue = false;\n        this._collector = null;\n        this._collectorCnt = 0;\n        this._outgoingEvents = [];\n    }\n    emitOutgoingEvent(e) {\n        this._addOutgoingEvent(e);\n        this._emitOutgoingEvents();\n    }\n    _addOutgoingEvent(e) {\n        for (let i = 0, len = this._outgoingEvents.length; i < len; i++) {\n            const mergeResult = (this._outgoingEvents[i].kind === e.kind ? this._outgoingEvents[i].attemptToMerge(e) : null);\n            if (mergeResult) {\n                this._outgoingEvents[i] = mergeResult;\n                return;\n            }\n        }\n        // not merged\n        this._outgoingEvents.push(e);\n    }\n    _emitOutgoingEvents() {\n        while (this._outgoingEvents.length > 0) {\n            if (this._collector || this._isConsumingViewEventQueue) {\n                // right now collecting or emitting view events, so let's postpone emitting\n                return;\n            }\n            const event = this._outgoingEvents.shift();\n            if (event.isNoOp()) {\n                continue;\n            }\n            this._onEvent.fire(event);\n        }\n    }\n    addViewEventHandler(eventHandler) {\n        for (let i = 0, len = this._eventHandlers.length; i < len; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);\n            }\n        }\n        this._eventHandlers.push(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        for (let i = 0; i < this._eventHandlers.length; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                this._eventHandlers.splice(i, 1);\n                break;\n            }\n        }\n    }\n    beginEmitViewEvents() {\n        this._collectorCnt++;\n        if (this._collectorCnt === 1) {\n            this._collector = new ViewModelEventsCollector();\n        }\n        return this._collector;\n    }\n    endEmitViewEvents() {\n        this._collectorCnt--;\n        if (this._collectorCnt === 0) {\n            const outgoingEvents = this._collector.outgoingEvents;\n            const viewEvents = this._collector.viewEvents;\n            this._collector = null;\n            for (const outgoingEvent of outgoingEvents) {\n                this._addOutgoingEvent(outgoingEvent);\n            }\n            if (viewEvents.length > 0) {\n                this._emitMany(viewEvents);\n            }\n        }\n        this._emitOutgoingEvents();\n    }\n    emitSingleViewEvent(event) {\n        try {\n            const eventsCollector = this.beginEmitViewEvents();\n            eventsCollector.emitViewEvent(event);\n        }\n        finally {\n            this.endEmitViewEvents();\n        }\n    }\n    _emitMany(events) {\n        if (this._viewEventQueue) {\n            this._viewEventQueue = this._viewEventQueue.concat(events);\n        }\n        else {\n            this._viewEventQueue = events;\n        }\n        if (!this._isConsumingViewEventQueue) {\n            this._consumeViewEventQueue();\n        }\n    }\n    _consumeViewEventQueue() {\n        try {\n            this._isConsumingViewEventQueue = true;\n            this._doConsumeQueue();\n        }\n        finally {\n            this._isConsumingViewEventQueue = false;\n        }\n    }\n    _doConsumeQueue() {\n        while (this._viewEventQueue) {\n            // Empty event queue, as events might come in while sending these off\n            const events = this._viewEventQueue;\n            this._viewEventQueue = null;\n            // Use a clone of the event handlers list, as they might remove themselves\n            const eventHandlers = this._eventHandlers.slice(0);\n            for (const eventHandler of eventHandlers) {\n                eventHandler.handleEvents(events);\n            }\n        }\n    }\n}\nexport class ViewModelEventsCollector {\n    constructor() {\n        this.viewEvents = [];\n        this.outgoingEvents = [];\n    }\n    emitViewEvent(event) {\n        this.viewEvents.push(event);\n    }\n    emitOutgoingEvent(e) {\n        this.outgoingEvents.push(e);\n    }\n}\nexport class ContentSizeChangedEvent {\n    constructor(oldContentWidth, oldContentHeight, contentWidth, contentHeight) {\n        this.kind = 0 /* OutgoingViewModelEventKind.ContentSizeChanged */;\n        this._oldContentWidth = oldContentWidth;\n        this._oldContentHeight = oldContentHeight;\n        this.contentWidth = contentWidth;\n        this.contentHeight = contentHeight;\n        this.contentWidthChanged = (this._oldContentWidth !== this.contentWidth);\n        this.contentHeightChanged = (this._oldContentHeight !== this.contentHeight);\n    }\n    isNoOp() {\n        return (!this.contentWidthChanged && !this.contentHeightChanged);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new ContentSizeChangedEvent(this._oldContentWidth, this._oldContentHeight, other.contentWidth, other.contentHeight);\n    }\n}\nexport class FocusChangedEvent {\n    constructor(oldHasFocus, hasFocus) {\n        this.kind = 1 /* OutgoingViewModelEventKind.FocusChanged */;\n        this.oldHasFocus = oldHasFocus;\n        this.hasFocus = hasFocus;\n    }\n    isNoOp() {\n        return (this.oldHasFocus === this.hasFocus);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new FocusChangedEvent(this.oldHasFocus, other.hasFocus);\n    }\n}\nexport class ScrollChangedEvent {\n    constructor(oldScrollWidth, oldScrollLeft, oldScrollHeight, oldScrollTop, scrollWidth, scrollLeft, scrollHeight, scrollTop) {\n        this.kind = 2 /* OutgoingViewModelEventKind.ScrollChanged */;\n        this._oldScrollWidth = oldScrollWidth;\n        this._oldScrollLeft = oldScrollLeft;\n        this._oldScrollHeight = oldScrollHeight;\n        this._oldScrollTop = oldScrollTop;\n        this.scrollWidth = scrollWidth;\n        this.scrollLeft = scrollLeft;\n        this.scrollHeight = scrollHeight;\n        this.scrollTop = scrollTop;\n        this.scrollWidthChanged = (this._oldScrollWidth !== this.scrollWidth);\n        this.scrollLeftChanged = (this._oldScrollLeft !== this.scrollLeft);\n        this.scrollHeightChanged = (this._oldScrollHeight !== this.scrollHeight);\n        this.scrollTopChanged = (this._oldScrollTop !== this.scrollTop);\n    }\n    isNoOp() {\n        return (!this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new ScrollChangedEvent(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, other.scrollWidth, other.scrollLeft, other.scrollHeight, other.scrollTop);\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.kind = 3 /* OutgoingViewModelEventKind.ViewZonesChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class HiddenAreasChangedEvent {\n    constructor() {\n        this.kind = 4 /* OutgoingViewModelEventKind.HiddenAreasChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class CursorStateChangedEvent {\n    constructor(oldSelections, selections, oldModelVersionId, modelVersionId, source, reason, reachedMaxCursorCount) {\n        this.kind = 6 /* OutgoingViewModelEventKind.CursorStateChanged */;\n        this.oldSelections = oldSelections;\n        this.selections = selections;\n        this.oldModelVersionId = oldModelVersionId;\n        this.modelVersionId = modelVersionId;\n        this.source = source;\n        this.reason = reason;\n        this.reachedMaxCursorCount = reachedMaxCursorCount;\n    }\n    static _selectionsAreEqual(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!a[i].equalsSelection(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isNoOp() {\n        return (CursorStateChangedEvent._selectionsAreEqual(this.oldSelections, this.selections)\n            && this.oldModelVersionId === this.modelVersionId);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new CursorStateChangedEvent(this.oldSelections, other.selections, this.oldModelVersionId, other.modelVersionId, other.source, other.reason, this.reachedMaxCursorCount || other.reachedMaxCursorCount);\n    }\n}\nexport class ReadOnlyEditAttemptEvent {\n    constructor() {\n        this.kind = 5 /* OutgoingViewModelEventKind.ReadOnlyEditAttempt */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class ModelDecorationsChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 7 /* OutgoingViewModelEventKind.ModelDecorationsChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelLanguageChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 8 /* OutgoingViewModelEventKind.ModelLanguageChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelLanguageConfigurationChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 9 /* OutgoingViewModelEventKind.ModelLanguageConfigurationChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelContentChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 10 /* OutgoingViewModelEventKind.ModelContentChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelOptionsChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 11 /* OutgoingViewModelEventKind.ModelOptionsChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelTokensChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 12 /* OutgoingViewModelEventKind.ModelTokensChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations } from './cursorTypeOperations.js';\nimport { BaseTypeWithAutoClosingCommand } from './cursorTypeEditOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealAll(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const revealViewSelections = [primaryCursor.viewState.selection];\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealAll(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealAll(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof BaseTypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealAll(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexport class CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    static { this.INSTANCE_COUNT = 0; }\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const previousLinesHeight = this._lineHeight * lineNumber;\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n            lineHeight: this._lineHeight,\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Scrollable } from '../../../base/common/scrollable.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { Viewport } from '../viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModelEventDispatcher.js';\nconst SMOOTH_SCROLLING_TIME = 125;\nclass EditorScrollDimensions {\n    constructor(width, contentWidth, height, contentHeight) {\n        width = width | 0;\n        contentWidth = contentWidth | 0;\n        height = height | 0;\n        contentHeight = contentHeight | 0;\n        if (width < 0) {\n            width = 0;\n        }\n        if (contentWidth < 0) {\n            contentWidth = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (contentHeight < 0) {\n            contentHeight = 0;\n        }\n        this.width = width;\n        this.contentWidth = contentWidth;\n        this.scrollWidth = Math.max(width, contentWidth);\n        this.height = height;\n        this.contentHeight = contentHeight;\n        this.scrollHeight = Math.max(height, contentHeight);\n    }\n    equals(other) {\n        return (this.width === other.width\n            && this.contentWidth === other.contentWidth\n            && this.height === other.height\n            && this.contentHeight === other.contentHeight);\n    }\n}\nclass EditorScrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n        this._scrollable = this._register(new Scrollable({\n            forceIntegerValues: true,\n            smoothScrollDuration,\n            scheduleAtNextAnimationFrame\n        }));\n        this.onDidScroll = this._scrollable.onScroll;\n    }\n    getScrollable() {\n        return this._scrollable;\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._dimensions;\n    }\n    setScrollDimensions(dimensions) {\n        if (this._dimensions.equals(dimensions)) {\n            return;\n        }\n        const oldDimensions = this._dimensions;\n        this._dimensions = dimensions;\n        this._scrollable.setScrollDimensions({\n            width: dimensions.width,\n            scrollWidth: dimensions.scrollWidth,\n            height: dimensions.height,\n            scrollHeight: dimensions.scrollHeight\n        }, true);\n        const contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n        const contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n        if (contentWidthChanged || contentHeightChanged) {\n            this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));\n        }\n    }\n    getFutureScrollPosition() {\n        return this._scrollable.getFutureScrollPosition();\n    }\n    getCurrentScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n    setScrollPositionNow(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n    setScrollPositionSmooth(update) {\n        this._scrollable.setScrollPositionSmooth(update);\n    }\n    hasPendingScrollAnimation() {\n        return this._scrollable.hasPendingScrollAnimation();\n    }\n}\nexport class ViewLayout extends Disposable {\n    constructor(configuration, lineCount, scheduleAtNextAnimationFrame) {\n        super();\n        this._configuration = configuration;\n        const options = this._configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        const padding = options.get(84 /* EditorOption.padding */);\n        this._linesLayout = new LinesLayout(lineCount, options.get(67 /* EditorOption.lineHeight */), padding.top, padding.bottom);\n        this._maxLineWidth = 0;\n        this._overlayWidgetsMinWidth = 0;\n        this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n        this._configureSmoothScrollDuration();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));\n        this.onDidScroll = this._scrollable.onDidScroll;\n        this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n        this._updateHeight();\n    }\n    dispose() {\n        super.dispose();\n    }\n    getScrollable() {\n        return this._scrollable.getScrollable();\n    }\n    onHeightMaybeChanged() {\n        this._updateHeight();\n    }\n    _configureSmoothScrollDuration() {\n        this._scrollable.setSmoothScrollDuration(this._configuration.options.get(115 /* EditorOption.smoothScrolling */) ? SMOOTH_SCROLLING_TIME : 0);\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._configuration.options;\n        if (e.hasChanged(67 /* EditorOption.lineHeight */)) {\n            this._linesLayout.setLineHeight(options.get(67 /* EditorOption.lineHeight */));\n        }\n        if (e.hasChanged(84 /* EditorOption.padding */)) {\n            const padding = options.get(84 /* EditorOption.padding */);\n            this._linesLayout.setPadding(padding.top, padding.bottom);\n        }\n        if (e.hasChanged(146 /* EditorOption.layoutInfo */)) {\n            const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n            const width = layoutInfo.contentWidth;\n            const height = layoutInfo.height;\n            const scrollDimensions = this._scrollable.getScrollDimensions();\n            const contentWidth = scrollDimensions.contentWidth;\n            this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n        }\n        else {\n            this._updateHeight();\n        }\n        if (e.hasChanged(115 /* EditorOption.smoothScrolling */)) {\n            this._configureSmoothScrollDuration();\n        }\n    }\n    onFlushed(lineCount) {\n        this._linesLayout.onFlushed(lineCount);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    // ---- end view event handlers\n    _getHorizontalScrollbarHeight(width, scrollWidth) {\n        const options = this._configuration.options;\n        const scrollbar = options.get(104 /* EditorOption.scrollbar */);\n        if (scrollbar.horizontal === 2 /* ScrollbarVisibility.Hidden */) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        if (width >= scrollWidth) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        return scrollbar.horizontalScrollbarSize;\n    }\n    _getContentHeight(width, height, contentWidth) {\n        const options = this._configuration.options;\n        let result = this._linesLayout.getLinesTotalHeight();\n        if (options.get(106 /* EditorOption.scrollBeyondLastLine */)) {\n            result += Math.max(0, height - options.get(67 /* EditorOption.lineHeight */) - options.get(84 /* EditorOption.padding */).bottom);\n        }\n        else if (!options.get(104 /* EditorOption.scrollbar */).ignoreHorizontalScrollbarInContentHeight) {\n            result += this._getHorizontalScrollbarHeight(width, contentWidth);\n        }\n        return result;\n    }\n    _updateHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const width = scrollDimensions.width;\n        const height = scrollDimensions.height;\n        const contentWidth = scrollDimensions.contentWidth;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n    }\n    // ---- Layouting logic\n    getCurrentViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    getFutureViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    _computeContentWidth() {\n        const options = this._configuration.options;\n        const maxLineWidth = this._maxLineWidth;\n        const wrappingInfo = options.get(147 /* EditorOption.wrappingInfo */);\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        if (wrappingInfo.isViewportWrapping) {\n            const minimap = options.get(73 /* EditorOption.minimap */);\n            if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n                // This is a case where viewport wrapping is on, but the line extends above the viewport\n                if (minimap.enabled && minimap.side === 'right') {\n                    // We need to accomodate the scrollbar width\n                    return maxLineWidth + layoutInfo.verticalScrollbarWidth;\n                }\n            }\n            return maxLineWidth;\n        }\n        else {\n            const extraHorizontalSpace = options.get(105 /* EditorOption.scrollBeyondLastColumn */) * fontInfo.typicalHalfwidthCharacterWidth;\n            const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n            return Math.max(maxLineWidth + extraHorizontalSpace + layoutInfo.verticalScrollbarWidth, whitespaceMinWidth, this._overlayWidgetsMinWidth);\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        this._maxLineWidth = maxLineWidth;\n        this._updateContentWidth();\n    }\n    setOverlayWidgetsMinWidth(maxMinWidth) {\n        this._overlayWidgetsMinWidth = maxMinWidth;\n        this._updateContentWidth();\n    }\n    _updateContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(), scrollDimensions.height, scrollDimensions.contentHeight));\n        // The height might depend on the fact that there is a horizontal scrollbar or not\n        this._updateHeight();\n    }\n    // ---- view state\n    saveState() {\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        const scrollTop = currentScrollPosition.scrollTop;\n        const firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n        const whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n        return {\n            scrollTop: scrollTop,\n            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n            scrollLeft: currentScrollPosition.scrollLeft\n        };\n    }\n    // ----\n    changeWhitespace(callback) {\n        const hadAChange = this._linesLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber, includeViewZones);\n    }\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones);\n    }\n    isAfterLines(verticalOffset) {\n        return this._linesLayout.isAfterLines(verticalOffset);\n    }\n    isInTopPadding(verticalOffset) {\n        return this._linesLayout.isInTopPadding(verticalOffset);\n    }\n    isInBottomPadding(verticalOffset) {\n        return this._linesLayout.isInBottomPadding(verticalOffset);\n    }\n    getLineNumberAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n    }\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n    }\n    getLinesViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getLinesViewportDataAtScrollTop(scrollTop) {\n        // do some minimal validations on scrollTop\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n    }\n    getWhitespaceViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getWhitespaces() {\n        return this._linesLayout.getWhitespaces();\n    }\n    // ----\n    getContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentWidth;\n    }\n    getScrollWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollWidth;\n    }\n    getContentHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentHeight;\n    }\n    getScrollHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollHeight;\n    }\n    getCurrentScrollLeft() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollLeft;\n    }\n    getCurrentScrollTop() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollTop;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    setScrollPosition(position, type) {\n        if (type === 1 /* ScrollType.Immediate */) {\n            this._scrollable.setScrollPositionNow(position);\n        }\n        else {\n            this._scrollable.setScrollPositionSmooth(position);\n        }\n    }\n    hasPendingScrollAnimation() {\n        return this._scrollable.hasPendingScrollAnimation();\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        this._scrollable.setScrollPositionNow({\n            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from '../viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* PositionAffinity.Left */, false, true);\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* PositionAffinity.Right */);\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                // For backwards compatibility reasons, we want injected text before any decoration.\n                // Thus, move decorations to the right.\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* PositionAffinity.Right */);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._getDecorationsInRange(range, true, false).decorations;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsInRange(viewRange, false, false);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    getInlineDecorationsOnLine(lineNumber, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const range = new Range(lineNumber, this._linesCollection.getViewLineMinColumn(lineNumber), lineNumber, this._linesCollection.getViewLineMaxColumn(lineNumber));\n        return this._getDecorationsInRange(range, onlyMinimapDecorations, onlyMarginDecorations).inlineDecorations[0];\n    }\n    _getDecorationsInRange(viewRange, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewRange, this.editorId, filterValidationDecorations(this.configuration.options), onlyMinimapDecorations, onlyMarginDecorations);\n        const startLineNumber = viewRange.startLineNumber;\n        const endLineNumber = viewRange.endLineNumber;\n        const decorationsInViewport = [];\n        let decorationsInViewportLen = 0;\n        const inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            const modelDecoration = modelDecorations[i];\n            const decorationOptions = modelDecoration.options;\n            if (!isModelDecorationVisible(this.model, modelDecoration)) {\n                continue;\n            }\n            const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            const viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n                const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* InlineDecorationType.Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* InlineDecorationType.After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\nexport function isModelDecorationVisible(model, decoration) {\n    if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n        return false;\n    }\n    if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n        return false;\n    }\n    return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 1 /* StandardTokenType.Comment */);\n}\nexport function isModelDecorationInString(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 2 /* StandardTokenType.String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        const lineTokens = model.tokenization.getLineTokens(lineNumber);\n        const isFirstLine = lineNumber === range.startLineNumber;\n        const isEndLine = lineNumber === range.endLineNumber;\n        let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n        while (tokenIdx < lineTokens.getCount()) {\n            if (isEndLine) {\n                const startOffset = lineTokens.getStartOffset(tokenIdx);\n                if (startOffset > range.endColumn - 1) {\n                    break;\n                }\n            }\n            const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n            if (!callbackResult) {\n                return false;\n            }\n            tokenIdx++;\n        }\n    }\n    return true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* PositionAffinity.None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    static { this.INSTANCE = new IdentityModelLineProjection(); }\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    static { this.INSTANCE = new HiddenModelLineProjection(); }\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nconst _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        const equalWordBreak = (this.wordBreak === wordBreak);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getMaxColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                // model-columns must be converted to view-model columns.\n                const result = bracketGuides.map(g => {\n                    if (g.forWrappedLinesAfterColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                        if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                        if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (!g.horizontalLine) {\n                        return g;\n                    }\n                    let column = -1;\n                    if (g.column !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                        if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                            column = p.column;\n                        }\n                        else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            column = this.getMinColumnOfViewLine(viewLineInfo);\n                        }\n                        else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                    const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                    if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                    }\n                    else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                        return undefined;\n                    }\n                    else {\n                        if (g.visibleColumn !== -1) {\n                            // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                            return undefined;\n                        }\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                    }\n                });\n                resultPerViewLine.push(result.filter((r) => !!r));\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */, allowZeroLineNumber = false, belowHiddenRanges = false) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        if (belowHiddenRanges) {\n            while (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex++;\n                lineIndexChanged = true;\n            }\n        }\n        else {\n            while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex--;\n                lineIndexChanged = true;\n            }\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            // TODO@alexdima@hediet this isn't soo pretty\n            return new Position(allowZeroLineNumber ? 0 : 1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            if (belowHiddenRanges) {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n            }\n            else {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n            }\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        const finalResult = [];\n        let finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlyphMarginLane } from '../model.js';\nconst MAX_LANE = GlyphMarginLane.Right;\nexport class GlyphMarginLanesModel {\n    constructor(maxLine) {\n        this.persist = 0;\n        this._requiredLanes = 1; // always render at least one lane\n        this.lanes = new Uint8Array(Math.ceil(((maxLine + 1) * MAX_LANE) / 8));\n    }\n    reset(maxLine) {\n        const bytes = Math.ceil(((maxLine + 1) * MAX_LANE) / 8);\n        if (this.lanes.length < bytes) {\n            this.lanes = new Uint8Array(bytes);\n        }\n        else {\n            this.lanes.fill(0);\n        }\n        this._requiredLanes = 1;\n    }\n    get requiredLanes() {\n        return this._requiredLanes;\n    }\n    push(lane, range, persist) {\n        if (persist) {\n            this.persist |= (1 << (lane - 1));\n        }\n        for (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n            const bit = (MAX_LANE * i) + (lane - 1);\n            this.lanes[bit >>> 3] |= (1 << (bit % 8));\n            this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(i));\n        }\n    }\n    getLanesAtLine(lineNumber) {\n        const lanes = [];\n        let bit = MAX_LANE * lineNumber;\n        for (let i = 0; i < MAX_LANE; i++) {\n            if (this.persist & (1 << i) || this.lanes[bit >>> 3] & (1 << (bit % 8))) {\n                lanes.push(i + 1);\n            }\n            bit++;\n        }\n        return lanes.length ? lanes : [GlyphMarginLane.Center];\n    }\n    countAtLine(lineNumber) {\n        let bit = MAX_LANE * lineNumber;\n        let count = 0;\n        for (let i = 0; i < MAX_LANE; i++) {\n            if (this.persist & (1 << i) || this.lanes[bit >>> 3] & (1 << (bit % 8))) {\n                count++;\n            }\n            bit++;\n        }\n        return count;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nimport { GlyphMarginLanesModel } from './glyphLanesModel.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService, _attachedView, _transactionalTarget) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._attachedView = _attachedView;\n        this._transactionalTarget = _transactionalTarget;\n        this.hiddenAreasModel = new HiddenAreasModel();\n        this.previousHiddenAreas = [];\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        this.glyphLanes = new GlyphMarginLanesModel(0);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(140 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(147 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(139 /* EditorOption.wrappingIndent */);\n            const wordBreak = options.get(130 /* EditorOption.wordBreak */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._handleVisibleLinesChanged();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    getModelVisibleRanges() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        return modelVisibleRanges;\n    }\n    visibleLinesStabilized() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, true);\n    }\n    _handleVisibleLinesChanged() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, false);\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _captureStableViewport() {\n        // We might need to restore the current start view range, so save it (if available)\n        // But only if the scroll position is not at the top of the file\n        if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            const previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n            return new StableViewport(previousViewportStartModelPosition, this._viewportStart.startLineDelta);\n        }\n        return new StableViewport(null, 0);\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        const stableViewport = this._captureStableViewport();\n        const options = this._configuration.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(140 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(147 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(139 /* EditorOption.wrappingIndent */);\n        const wordBreak = options.get(130 /* EditorOption.wordBreak */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(92 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        if (e.hasChanged(99 /* EditorOption.renderValidationDecorations */)) {\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._handleVisibleLinesChanged();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges, source) {\n        this.hiddenAreasModel.setHiddenAreas(source, ranges);\n        const mergedRanges = this.hiddenAreasModel.getMergedRanges();\n        if (mergedRanges === this.previousHiddenAreas) {\n            return;\n        }\n        this.previousHiddenAreas = mergedRanges;\n        const stableViewport = this._captureStableViewport();\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(mergedRanges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n            const firstModelLineInViewPort = stableViewport.viewportStartModelPosition?.lineNumber;\n            const firstModelLineIsHidden = firstModelLineInViewPort && mergedRanges.some(range => range.startLineNumber <= firstModelLineInViewPort && firstModelLineInViewPort <= range.endLineNumber);\n            if (!firstModelLineIsHidden) {\n                stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(146 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(67 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._decorations.getMinimapDecorationsInRange(range);\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            opts1?.invalidateCachedColor();\n            const opts2 = decoration.options.minimap;\n            opts2?.invalidateCachedColor();\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getValueLengthInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueLengthInRange(modelRange, eol);\n    }\n    modifyPosition(position, offset) {\n        const modelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(position);\n        const resultModelPosition = this.model.modifyPosition(modelPosition, offset);\n        return this.coordinatesConverter.convertModelPositionToViewPosition(resultModelPosition);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(50 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealAllCursors(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealAll(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        return this._transactionalTarget.batchChanges(() => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                return callback(eventsCollector);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        });\n    }\n    batchEvents(callback) {\n        this._withViewEventsCollector(() => { callback(); });\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\nclass HiddenAreasModel {\n    constructor() {\n        this.hiddenAreas = new Map();\n        this.shouldRecompute = false;\n        this.ranges = [];\n    }\n    setHiddenAreas(source, ranges) {\n        const existing = this.hiddenAreas.get(source);\n        if (existing && rangeArraysEqual(existing, ranges)) {\n            return;\n        }\n        this.hiddenAreas.set(source, ranges);\n        this.shouldRecompute = true;\n    }\n    /**\n     * The returned array is immutable.\n    */\n    getMergedRanges() {\n        if (!this.shouldRecompute) {\n            return this.ranges;\n        }\n        this.shouldRecompute = false;\n        const newRanges = Array.from(this.hiddenAreas.values()).reduce((r, hiddenAreas) => mergeLineRangeArray(r, hiddenAreas), []);\n        if (rangeArraysEqual(this.ranges, newRanges)) {\n            return this.ranges;\n        }\n        this.ranges = newRanges;\n        return this.ranges;\n    }\n}\nfunction mergeLineRangeArray(arr1, arr2) {\n    const result = [];\n    let i = 0;\n    let j = 0;\n    while (i < arr1.length && j < arr2.length) {\n        const item1 = arr1[i];\n        const item2 = arr2[j];\n        if (item1.endLineNumber < item2.startLineNumber - 1) {\n            result.push(arr1[i++]);\n        }\n        else if (item2.endLineNumber < item1.startLineNumber - 1) {\n            result.push(arr2[j++]);\n        }\n        else {\n            const startLineNumber = Math.min(item1.startLineNumber, item2.startLineNumber);\n            const endLineNumber = Math.max(item1.endLineNumber, item2.endLineNumber);\n            result.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            i++;\n            j++;\n        }\n    }\n    while (i < arr1.length) {\n        result.push(arr1[i++]);\n    }\n    while (j < arr2.length) {\n        result.push(arr2[j++]);\n    }\n    return result;\n}\nfunction rangeArraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!arr1[i].equalsRange(arr2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Maintain a stable viewport by trying to keep the first line in the viewport constant.\n */\nclass StableViewport {\n    constructor(viewportStartModelPosition, startLineDelta) {\n        this.viewportStartModelPosition = viewportStartModelPosition;\n        this.startLineDelta = startLineDelta;\n    }\n    recoverViewportStart(coordinatesConverter, viewLayout) {\n        if (!this.viewportStartModelPosition) {\n            return;\n        }\n        const viewPosition = coordinatesConverter.convertModelPositionToViewPosition(this.viewportStartModelPosition);\n        const viewPositionTop = viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n        viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this.startLineDelta }, 1 /* ScrollType.Immediate */);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { AbstractText } from '../core/textEdit.js';\nimport { TextLength } from '../core/textLength.js';\nexport class TextModelText extends AbstractText {\n    constructor(_textModel) {\n        super();\n        this._textModel = _textModel;\n    }\n    getValueOfRange(range) {\n        return this._textModel.getValueInRange(range);\n    }\n    get length() {\n        const lastLineNumber = this._textModel.getLineCount();\n        const lastLineLen = this._textModel.getLineLength(lastLineNumber);\n        return new TextLength(lastLineNumber - 1, lastLineLen);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeViewsDnDService {\n    constructor() {\n        this._dragOperations = new Map();\n    }\n    removeDragOperationTransfer(uuid) {\n        if ((uuid && this._dragOperations.has(uuid))) {\n            const operation = this._dragOperations.get(uuid);\n            this._dragOperations.delete(uuid);\n            return operation;\n        }\n        return undefined;\n    }\n}\nexport class DraggedTreeItemsIdentifier {\n    constructor(identifier) {\n        this.identifier = identifier;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { TreeViewsDnDService } from './treeViewsDnd.js';\nexport const ITreeViewsDnDService = createDecorator('treeViewsDndService');\nregisterSingleton(ITreeViewsDnDService, TreeViewsDnDService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nexport function fixBracketsInLine(tokens, languageConfigurationService) {\n    const denseKeyProvider = new DenseKeyProvider();\n    const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));\n    const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);\n    const node = parseDocument(tokenizer, [], undefined, true);\n    let str = '';\n    const line = tokens.getLineContent();\n    function processNode(node, offset) {\n        if (node.kind === 2 /* AstNodeKind.Pair */) {\n            processNode(node.openingBracket, offset);\n            offset = lengthAdd(offset, node.openingBracket.length);\n            if (node.child) {\n                processNode(node.child, offset);\n                offset = lengthAdd(offset, node.child.length);\n            }\n            if (node.closingBracket) {\n                processNode(node.closingBracket, offset);\n                offset = lengthAdd(offset, node.closingBracket.length);\n            }\n            else {\n                const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n                const closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n                str += closingTokenText;\n            }\n        }\n        else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n            // remove the bracket\n        }\n        else if (node.kind === 0 /* AstNodeKind.Text */ || node.kind === 1 /* AstNodeKind.Bracket */) {\n            str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length)));\n        }\n        else if (node.kind === 4 /* AstNodeKind.List */) {\n            for (const child of node.children) {\n                processNode(child, offset);\n                offset = lengthAdd(offset, child.length);\n            }\n        }\n    }\n    processNode(node, lengthZero);\n    return str;\n}\nclass StaticTokenizerSource {\n    constructor(lines) {\n        this.lines = lines;\n        this.tokenization = {\n            getLineTokens: (lineNumber) => {\n                return this.lines[lineNumber - 1];\n            }\n        };\n    }\n    getLineCount() {\n        return this.lines.length;\n    }\n    getLineLength(lineNumber) {\n        return this.lines[lineNumber - 1].getLineContent().length;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Schemas } from '../../../base/common/network.js';\nimport { DataUri } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { FileKind } from '../../../platform/files/common/files.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nconst fileIconDirectoryRegex = /(?:\\/|^)(?:([^\\/]+)\\/)?([^\\/]+)$/;\nexport function getIconClasses(modelService, languageService, resource, fileKind, icon) {\n    if (ThemeIcon.isThemeIcon(icon)) {\n        return [`codicon-${icon.id}`, 'predefined-file-icon'];\n    }\n    if (URI.isUri(icon)) {\n        return [];\n    }\n    // we always set these base classes even if we do not have a path\n    const classes = fileKind === FileKind.ROOT_FOLDER ? ['rootfolder-icon'] : fileKind === FileKind.FOLDER ? ['folder-icon'] : ['file-icon'];\n    if (resource) {\n        // Get the path and name of the resource. For data-URIs, we need to parse specially\n        let name;\n        if (resource.scheme === Schemas.data) {\n            const metadata = DataUri.parseMetaData(resource);\n            name = metadata.get(DataUri.META_DATA_LABEL);\n        }\n        else {\n            const match = resource.path.match(fileIconDirectoryRegex);\n            if (match) {\n                name = cssEscape(match[2].toLowerCase());\n                if (match[1]) {\n                    classes.push(`${cssEscape(match[1].toLowerCase())}-name-dir-icon`); // parent directory\n                }\n            }\n            else {\n                name = cssEscape(resource.authority.toLowerCase());\n            }\n        }\n        // Root Folders\n        if (fileKind === FileKind.ROOT_FOLDER) {\n            classes.push(`${name}-root-name-folder-icon`);\n        }\n        // Folders\n        else if (fileKind === FileKind.FOLDER) {\n            classes.push(`${name}-name-folder-icon`);\n        }\n        // Files\n        else {\n            // Name & Extension(s)\n            if (name) {\n                classes.push(`${name}-name-file-icon`);\n                classes.push(`name-file-icon`); // extra segment to increase file-name score\n                // Avoid doing an explosive combination of extensions for very long filenames\n                // (most file systems do not allow files > 255 length) with lots of `.` characters\n                // https://github.com/microsoft/vscode/issues/116199\n                if (name.length <= 255) {\n                    const dotSegments = name.split('.');\n                    for (let i = 1; i < dotSegments.length; i++) {\n                        classes.push(`${dotSegments.slice(i).join('.')}-ext-file-icon`); // add each combination of all found extensions if more than one\n                    }\n                }\n                classes.push(`ext-file-icon`); // extra segment to increase file-ext score\n            }\n            // Detected Mode\n            const detectedLanguageId = detectLanguageId(modelService, languageService, resource);\n            if (detectedLanguageId) {\n                classes.push(`${cssEscape(detectedLanguageId)}-lang-file-icon`);\n            }\n        }\n    }\n    return classes;\n}\nfunction detectLanguageId(modelService, languageService, resource) {\n    if (!resource) {\n        return null; // we need a resource at least\n    }\n    let languageId = null;\n    // Data URI: check for encoded metadata\n    if (resource.scheme === Schemas.data) {\n        const metadata = DataUri.parseMetaData(resource);\n        const mime = metadata.get(DataUri.META_DATA_MIME);\n        if (mime) {\n            languageId = languageService.getLanguageIdByMimeType(mime);\n        }\n    }\n    // Any other URI: check for model if existing\n    else {\n        const model = modelService.getModel(resource);\n        if (model) {\n            languageId = model.getLanguageId();\n        }\n    }\n    // only take if the language id is specific (aka no just plain text)\n    if (languageId && languageId !== PLAINTEXT_LANGUAGE_ID) {\n        return languageId;\n    }\n    // otherwise fallback to path based detection\n    return languageService.guessLanguageIdByFilepathOrFirstLine(resource);\n}\nfunction cssEscape(str) {\n    return str.replace(/[\\s]/g, '/'); // HTML class names can not contain certain whitespace characters (https://dom.spec.whatwg.org/#interface-domtokenlist), use / instead, which doesn't exist in file names.\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../core/editOperation.js';\nimport { Range } from '../core/range.js';\nexport class TrimTrailingWhitespaceCommand {\n    constructor(selection, cursors, trimInRegexesAndStrings) {\n        this._selection = selection;\n        this._cursors = cursors;\n        this._selectionId = null;\n        this._trimInRegexesAndStrings = trimInRegexesAndStrings;\n    }\n    getEditOperations(model, builder) {\n        const ops = trimTrailingWhitespace(model, this._cursors, this._trimInRegexesAndStrings);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            const op = ops[i];\n            builder.addEditOperation(op.range, op.text);\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this._selectionId);\n    }\n}\n/**\n * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.\n */\nexport function trimTrailingWhitespace(model, cursors, trimInRegexesAndStrings) {\n    // Sort cursors ascending\n    cursors.sort((a, b) => {\n        if (a.lineNumber === b.lineNumber) {\n            return a.column - b.column;\n        }\n        return a.lineNumber - b.lineNumber;\n    });\n    // Reduce multiple cursors on the same line and only keep the last one on the line\n    for (let i = cursors.length - 2; i >= 0; i--) {\n        if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {\n            // Remove cursor at `i`\n            cursors.splice(i, 1);\n        }\n    }\n    const r = [];\n    let rLen = 0;\n    let cursorIndex = 0;\n    const cursorLen = cursors.length;\n    for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const maxLineColumn = lineContent.length + 1;\n        let minEditColumn = 0;\n        if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {\n            minEditColumn = cursors[cursorIndex].column;\n            cursorIndex++;\n            if (minEditColumn === maxLineColumn) {\n                // The cursor is at the end of the line => no edits for sure on this line\n                continue;\n            }\n        }\n        if (lineContent.length === 0) {\n            continue;\n        }\n        const lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n        let fromColumn = 0;\n        if (lastNonWhitespaceIndex === -1) {\n            // Entire line is whitespace\n            fromColumn = 1;\n        }\n        else if (lastNonWhitespaceIndex !== lineContent.length - 1) {\n            // There is trailing whitespace\n            fromColumn = lastNonWhitespaceIndex + 2;\n        }\n        else {\n            // There is no trailing whitespace\n            continue;\n        }\n        if (!trimInRegexesAndStrings) {\n            if (!model.tokenization.hasAccurateTokensForLine(lineNumber)) {\n                // We don't want to force line tokenization, as that can be expensive, but we also don't want to trim\n                // trailing whitespace in lines that are not tokenized yet, as that can be wrong and trim whitespace from\n                // lines that the user requested we don't. So we bail out if the tokens are not accurate for this line.\n                continue;\n            }\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const fromColumnType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(fromColumn));\n            if (fromColumnType === 2 /* StandardTokenType.String */ || fromColumnType === 3 /* StandardTokenType.RegEx */) {\n                continue;\n            }\n        }\n        fromColumn = Math.max(minEditColumn, fromColumn);\n        r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));\n    }\n    return r;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* EncodedSemanticTokensType.Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* EncodedSemanticTokensType.Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\n"],"file":"assets/monaco-editor-esm-vs-editor-common-BH3S_Qrw.js"}