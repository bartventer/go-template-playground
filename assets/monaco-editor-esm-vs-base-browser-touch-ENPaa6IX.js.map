{"version":3,"file":"monaco-editor-esm-vs-base-browser-touch-ENPaa6IX.js","sources":["../../../node_modules/monaco-editor/esm/vs/base/browser/touch.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport * as DomUtils from './dom.js';\nimport { mainWindow } from './window.js';\nimport * as arrays from '../common/arrays.js';\nimport { memoize } from '../common/decorators.js';\nimport { Event as EventUtils } from '../common/event.js';\nimport { Disposable, markAsSingleton, toDisposable } from '../common/lifecycle.js';\nimport { LinkedList } from '../common/linkedList.js';\nexport var EventType;\n(function (EventType) {\n    EventType.Tap = '-monaco-gesturetap';\n    EventType.Change = '-monaco-gesturechange';\n    EventType.Start = '-monaco-gesturestart';\n    EventType.End = '-monaco-gesturesend';\n    EventType.Contextmenu = '-monaco-gesturecontextmenu';\n})(EventType || (EventType = {}));\nexport class Gesture extends Disposable {\n    static { this.SCROLL_FRICTION = -0.005; }\n    static { this.HOLD_DELAY = 700; }\n    static { this.CLEAR_TAP_COUNT_TIME = 400; } // ms\n    constructor() {\n        super();\n        this.dispatched = false;\n        this.targets = new LinkedList();\n        this.ignoreTargets = new LinkedList();\n        this.activeTouches = {};\n        this.handle = null;\n        this._lastSetTapCountTime = 0;\n        this._register(EventUtils.runAndSubscribe(DomUtils.onDidRegisterWindow, ({ window, disposables }) => {\n            disposables.add(DomUtils.addDisposableListener(window.document, 'touchstart', (e) => this.onTouchStart(e), { passive: false }));\n            disposables.add(DomUtils.addDisposableListener(window.document, 'touchend', (e) => this.onTouchEnd(window, e)));\n            disposables.add(DomUtils.addDisposableListener(window.document, 'touchmove', (e) => this.onTouchMove(e), { passive: false }));\n        }, { window: mainWindow, disposables: this._store }));\n    }\n    static addTarget(element) {\n        if (!Gesture.isTouchDevice()) {\n            return Disposable.None;\n        }\n        if (!Gesture.INSTANCE) {\n            Gesture.INSTANCE = markAsSingleton(new Gesture());\n        }\n        const remove = Gesture.INSTANCE.targets.push(element);\n        return toDisposable(remove);\n    }\n    static ignoreTarget(element) {\n        if (!Gesture.isTouchDevice()) {\n            return Disposable.None;\n        }\n        if (!Gesture.INSTANCE) {\n            Gesture.INSTANCE = markAsSingleton(new Gesture());\n        }\n        const remove = Gesture.INSTANCE.ignoreTargets.push(element);\n        return toDisposable(remove);\n    }\n    static isTouchDevice() {\n        // `'ontouchstart' in window` always evaluates to true with typescript's modern typings. This causes `window` to be\n        // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n        return 'ontouchstart' in mainWindow || navigator.maxTouchPoints > 0;\n    }\n    dispose() {\n        if (this.handle) {\n            this.handle.dispose();\n            this.handle = null;\n        }\n        super.dispose();\n    }\n    onTouchStart(e) {\n        const timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        if (this.handle) {\n            this.handle.dispose();\n            this.handle = null;\n        }\n        for (let i = 0, len = e.targetTouches.length; i < len; i++) {\n            const touch = e.targetTouches.item(i);\n            this.activeTouches[touch.identifier] = {\n                id: touch.identifier,\n                initialTarget: touch.target,\n                initialTimeStamp: timestamp,\n                initialPageX: touch.pageX,\n                initialPageY: touch.pageY,\n                rollingTimestamps: [timestamp],\n                rollingPageX: [touch.pageX],\n                rollingPageY: [touch.pageY]\n            };\n            const evt = this.newGestureEvent(EventType.Start, touch.target);\n            evt.pageX = touch.pageX;\n            evt.pageY = touch.pageY;\n            this.dispatchEvent(evt);\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n    onTouchEnd(targetWindow, e) {\n        const timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        const activeTouchCount = Object.keys(this.activeTouches).length;\n        for (let i = 0, len = e.changedTouches.length; i < len; i++) {\n            const touch = e.changedTouches.item(i);\n            if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n                console.warn('move of an UNKNOWN touch', touch);\n                continue;\n            }\n            const data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;\n            if (holdTime < Gesture.HOLD_DELAY\n                && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30\n                && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n                const evt = this.newGestureEvent(EventType.Tap, data.initialTarget);\n                evt.pageX = arrays.tail(data.rollingPageX);\n                evt.pageY = arrays.tail(data.rollingPageY);\n                this.dispatchEvent(evt);\n            }\n            else if (holdTime >= Gesture.HOLD_DELAY\n                && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30\n                && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n                const evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);\n                evt.pageX = arrays.tail(data.rollingPageX);\n                evt.pageY = arrays.tail(data.rollingPageY);\n                this.dispatchEvent(evt);\n            }\n            else if (activeTouchCount === 1) {\n                const finalX = arrays.tail(data.rollingPageX);\n                const finalY = arrays.tail(data.rollingPageY);\n                const deltaT = arrays.tail(data.rollingTimestamps) - data.rollingTimestamps[0];\n                const deltaX = finalX - data.rollingPageX[0];\n                const deltaY = finalY - data.rollingPageY[0];\n                // We need to get all the dispatch targets on the start of the inertia event\n                const dispatchTo = [...this.targets].filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));\n                this.inertia(targetWindow, dispatchTo, timestamp, // time now\n                Math.abs(deltaX) / deltaT, // speed\n                deltaX > 0 ? 1 : -1, // x direction\n                finalX, // x now\n                Math.abs(deltaY) / deltaT, // y speed\n                deltaY > 0 ? 1 : -1, // y direction\n                finalY // y now\n                );\n            }\n            this.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget));\n            // forget about this touch\n            delete this.activeTouches[touch.identifier];\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n    newGestureEvent(type, initialTarget) {\n        const event = document.createEvent('CustomEvent');\n        event.initEvent(type, false, true);\n        event.initialTarget = initialTarget;\n        event.tapCount = 0;\n        return event;\n    }\n    dispatchEvent(event) {\n        if (event.type === EventType.Tap) {\n            const currentTime = (new Date()).getTime();\n            let setTapCount = 0;\n            if (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {\n                setTapCount = 1;\n            }\n            else {\n                setTapCount = 2;\n            }\n            this._lastSetTapCountTime = currentTime;\n            event.tapCount = setTapCount;\n        }\n        else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {\n            // tap is canceled by scrolling or context menu\n            this._lastSetTapCountTime = 0;\n        }\n        if (event.initialTarget instanceof Node) {\n            for (const ignoreTarget of this.ignoreTargets) {\n                if (ignoreTarget.contains(event.initialTarget)) {\n                    return;\n                }\n            }\n            const targets = [];\n            for (const target of this.targets) {\n                if (target.contains(event.initialTarget)) {\n                    let depth = 0;\n                    let now = event.initialTarget;\n                    while (now && now !== target) {\n                        depth++;\n                        now = now.parentElement;\n                    }\n                    targets.push([depth, target]);\n                }\n            }\n            targets.sort((a, b) => a[0] - b[0]);\n            for (const [_, target] of targets) {\n                target.dispatchEvent(event);\n                this.dispatched = true;\n            }\n        }\n    }\n    inertia(targetWindow, dispatchTo, t1, vX, dirX, x, vY, dirY, y) {\n        this.handle = DomUtils.scheduleAtNextAnimationFrame(targetWindow, () => {\n            const now = Date.now();\n            // velocity: old speed + accel_over_time\n            const deltaT = now - t1;\n            let delta_pos_x = 0, delta_pos_y = 0;\n            let stopped = true;\n            vX += Gesture.SCROLL_FRICTION * deltaT;\n            vY += Gesture.SCROLL_FRICTION * deltaT;\n            if (vX > 0) {\n                stopped = false;\n                delta_pos_x = dirX * vX * deltaT;\n            }\n            if (vY > 0) {\n                stopped = false;\n                delta_pos_y = dirY * vY * deltaT;\n            }\n            // dispatch translation event\n            const evt = this.newGestureEvent(EventType.Change);\n            evt.translationX = delta_pos_x;\n            evt.translationY = delta_pos_y;\n            dispatchTo.forEach(d => d.dispatchEvent(evt));\n            if (!stopped) {\n                this.inertia(targetWindow, dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);\n            }\n        });\n    }\n    onTouchMove(e) {\n        const timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        for (let i = 0, len = e.changedTouches.length; i < len; i++) {\n            const touch = e.changedTouches.item(i);\n            if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n                console.warn('end of an UNKNOWN touch', touch);\n                continue;\n            }\n            const data = this.activeTouches[touch.identifier];\n            const evt = this.newGestureEvent(EventType.Change, data.initialTarget);\n            evt.translationX = touch.pageX - arrays.tail(data.rollingPageX);\n            evt.translationY = touch.pageY - arrays.tail(data.rollingPageY);\n            evt.pageX = touch.pageX;\n            evt.pageY = touch.pageY;\n            this.dispatchEvent(evt);\n            // only keep a few data points, to average the final speed\n            if (data.rollingPageX.length > 3) {\n                data.rollingPageX.shift();\n                data.rollingPageY.shift();\n                data.rollingTimestamps.shift();\n            }\n            data.rollingPageX.push(touch.pageX);\n            data.rollingPageY.push(touch.pageY);\n            data.rollingTimestamps.push(timestamp);\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n}\n__decorate([\n    memoize\n], Gesture, \"isTouchDevice\", null);\n"],"names":["onDidRegisterWindow","addDisposableListener","scheduleAtNextAnimationFrame","mainWindow","Disposable","LinkedList","Event","markAsSingleton","toDisposable","tail","memoize","__decorate","decorators","target","key","desc","c","r","d","i","EventType","_Gesture","EventUtils","DomUtils.onDidRegisterWindow","window","disposables","DomUtils.addDisposableListener","e","element","remove","timestamp","len","touch","evt","targetWindow","activeTouchCount","data","holdTime","arrays.tail","finalX","finalY","deltaT","deltaX","deltaY","dispatchTo","t","type","initialTarget","event","currentTime","setTapCount","ignoreTarget","targets","depth","now","a","b","_","t1","vX","dirX","x","vY","dirY","y","DomUtils.scheduleAtNextAnimationFrame","delta_pos_x","delta_pos_y","stopped","Gesture"],"mappings":"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","x_google_ignoreList":[0]}