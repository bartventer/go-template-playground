{"version":3,"file":"monaco-editor-esm-vs-base-browser-markdownRenderer-BB65ORmS.js","sources":["../../../node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nimport * as dompurify from './dompurify/dompurify.js';\nimport { DomEmitter } from './event.js';\nimport { createElement } from './formattedTextRenderer.js';\nimport { StandardKeyboardEvent } from './keyboardEvent.js';\nimport { StandardMouseEvent } from './mouseEvent.js';\nimport { renderLabelWithIcons } from './ui/iconLabel/iconLabels.js';\nimport { onUnexpectedError } from '../common/errors.js';\nimport { Event } from '../common/event.js';\nimport { escapeDoubleQuotes, parseHrefAndDimensions, removeMarkdownEscapes } from '../common/htmlContent.js';\nimport { markdownEscapeEscapedIcons } from '../common/iconLabels.js';\nimport { defaultGenerator } from '../common/idGenerator.js';\nimport { Lazy } from '../common/lazy.js';\nimport { DisposableStore, toDisposable } from '../common/lifecycle.js';\nimport * as marked from '../common/marked/marked.js';\nimport { parse } from '../common/marshalling.js';\nimport { FileAccess, Schemas } from '../common/network.js';\nimport { cloneAndChange } from '../common/objects.js';\nimport { dirname, resolvePath } from '../common/resources.js';\nimport { escape } from '../common/strings.js';\nimport { URI } from '../common/uri.js';\nconst defaultMarkedRenderers = Object.freeze({\n    image: ({ href, title, text }) => {\n        let dimensions = [];\n        let attributes = [];\n        if (href) {\n            ({ href, dimensions } = parseHrefAndDimensions(href));\n            attributes.push(`src=\"${escapeDoubleQuotes(href)}\"`);\n        }\n        if (text) {\n            attributes.push(`alt=\"${escapeDoubleQuotes(text)}\"`);\n        }\n        if (title) {\n            attributes.push(`title=\"${escapeDoubleQuotes(title)}\"`);\n        }\n        if (dimensions.length) {\n            attributes = attributes.concat(dimensions);\n        }\n        return '<img ' + attributes.join(' ') + '>';\n    },\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>`;\n    },\n    link({ href, title, tokens }) {\n        let text = this.parser.parseInline(tokens);\n        if (typeof href !== 'string') {\n            return '';\n        }\n        // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\n        if (href === text) { // raw link case\n            text = removeMarkdownEscapes(text);\n        }\n        title = typeof title === 'string' ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : '';\n        href = removeMarkdownEscapes(href);\n        // HTML Encode href\n        href = href.replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n        return `<a href=\"${href}\" title=\"${title || href}\" draggable=\"false\">${text}</a>`;\n    },\n});\n/**\n * Low-level way create a html element from a markdown string.\n *\n * **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.ts)\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\n */\nexport function renderMarkdown(markdown, options = {}, markedOptions = {}) {\n    const disposables = new DisposableStore();\n    let isDisposed = false;\n    const element = createElement(options);\n    const _uriMassage = function (part) {\n        let data;\n        try {\n            data = parse(decodeURIComponent(part));\n        }\n        catch (e) {\n            // ignore\n        }\n        if (!data) {\n            return part;\n        }\n        data = cloneAndChange(data, value => {\n            if (markdown.uris && markdown.uris[value]) {\n                return URI.revive(markdown.uris[value]);\n            }\n            else {\n                return undefined;\n            }\n        });\n        return encodeURIComponent(JSON.stringify(data));\n    };\n    const _href = function (href, isDomUri) {\n        const data = markdown.uris && markdown.uris[href];\n        let uri = URI.revive(data);\n        if (isDomUri) {\n            if (href.startsWith(Schemas.data + ':')) {\n                return href;\n            }\n            if (!uri) {\n                uri = URI.parse(href);\n            }\n            // this URI will end up as \"src\"-attribute of a dom node\n            // and because of that special rewriting needs to be done\n            // so that the URI uses a protocol that's understood by\n            // browsers (like http or https)\n            return FileAccess.uriToBrowserUri(uri).toString(true);\n        }\n        if (!uri) {\n            return href;\n        }\n        if (URI.parse(href).toString() === uri.toString()) {\n            return href; // no transformation performed\n        }\n        if (uri.query) {\n            uri = uri.with({ query: _uriMassage(uri.query) });\n        }\n        return uri.toString();\n    };\n    const renderer = new marked.Renderer();\n    renderer.image = defaultMarkedRenderers.image;\n    renderer.link = defaultMarkedRenderers.link;\n    renderer.paragraph = defaultMarkedRenderers.paragraph;\n    // Will collect [id, renderedElement] tuples\n    const codeBlocks = [];\n    const syncCodeBlocks = [];\n    if (options.codeBlockRendererSync) {\n        renderer.code = ({ text, lang }) => {\n            const id = defaultGenerator.nextId();\n            const value = options.codeBlockRendererSync(postProcessCodeBlockLanguageId(lang), text);\n            syncCodeBlocks.push([id, value]);\n            return `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n        };\n    }\n    else if (options.codeBlockRenderer) {\n        renderer.code = ({ text, lang }) => {\n            const id = defaultGenerator.nextId();\n            const value = options.codeBlockRenderer(postProcessCodeBlockLanguageId(lang), text);\n            codeBlocks.push(value.then(element => [id, element]));\n            return `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n        };\n    }\n    if (options.actionHandler) {\n        const _activateLink = function (event) {\n            let target = event.target;\n            if (target.tagName !== 'A') {\n                target = target.parentElement;\n                if (!target || target.tagName !== 'A') {\n                    return;\n                }\n            }\n            try {\n                let href = target.dataset['href'];\n                if (href) {\n                    if (markdown.baseUri) {\n                        href = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n                    }\n                    options.actionHandler.callback(href, event);\n                }\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n            finally {\n                event.preventDefault();\n            }\n        };\n        const onClick = options.actionHandler.disposables.add(new DomEmitter(element, 'click'));\n        const onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, 'auxclick'));\n        options.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)(e => {\n            const mouseEvent = new StandardMouseEvent(DOM.getWindow(element), e);\n            if (!mouseEvent.leftButton && !mouseEvent.middleButton) {\n                return;\n            }\n            _activateLink(mouseEvent);\n        }));\n        options.actionHandler.disposables.add(DOM.addDisposableListener(element, 'keydown', (e) => {\n            const keyboardEvent = new StandardKeyboardEvent(e);\n            if (!keyboardEvent.equals(10 /* KeyCode.Space */) && !keyboardEvent.equals(3 /* KeyCode.Enter */)) {\n                return;\n            }\n            _activateLink(keyboardEvent);\n        }));\n    }\n    if (!markdown.supportHtml) {\n        // Note: we always pass the output through dompurify after this so that we don't rely on\n        // marked for real sanitization.\n        renderer.html = ({ text }) => {\n            if (options.sanitizerOptions?.replaceWithPlaintext) {\n                return escape(text);\n            }\n            const match = markdown.isTrusted ? text.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\n            return match ? text : '';\n        };\n    }\n    markedOptions.renderer = renderer;\n    // values that are too long will freeze the UI\n    let value = markdown.value ?? '';\n    if (value.length > 100_000) {\n        value = `${value.substr(0, 100_000)}â€¦`;\n    }\n    // escape theme icons\n    if (markdown.supportThemeIcons) {\n        value = markdownEscapeEscapedIcons(value);\n    }\n    let renderedMarkdown;\n    if (options.fillInIncompleteTokens) {\n        // The defaults are applied by parse but not lexer()/parser(), and they need to be present\n        const opts = {\n            ...marked.defaults,\n            ...markedOptions\n        };\n        const tokens = marked.lexer(value, opts);\n        const newTokens = fillInIncompleteTokens(tokens);\n        renderedMarkdown = marked.parser(newTokens, opts);\n    }\n    else {\n        renderedMarkdown = marked.parse(value, { ...markedOptions, async: false });\n    }\n    // Rewrite theme icons\n    if (markdown.supportThemeIcons) {\n        const elements = renderLabelWithIcons(renderedMarkdown);\n        renderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');\n    }\n    const htmlParser = new DOMParser();\n    const markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown({ isTrusted: markdown.isTrusted, ...options.sanitizerOptions }, renderedMarkdown), 'text/html');\n    markdownHtmlDoc.body.querySelectorAll('img, audio, video, source')\n        .forEach(img => {\n        const src = img.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'\n        if (src) {\n            let href = src;\n            try {\n                if (markdown.baseUri) { // absolute or relative local path, or file: uri\n                    href = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n                }\n            }\n            catch (err) { }\n            img.setAttribute('src', _href(href, true));\n            if (options.remoteImageIsAllowed) {\n                const uri = URI.parse(href);\n                if (uri.scheme !== Schemas.file && uri.scheme !== Schemas.data && !options.remoteImageIsAllowed(uri)) {\n                    img.replaceWith(DOM.$('', undefined, img.outerHTML));\n                }\n            }\n        }\n    });\n    markdownHtmlDoc.body.querySelectorAll('a')\n        .forEach(a => {\n        const href = a.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'\n        a.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead\n        if (!href\n            || /^data:|javascript:/i.test(href)\n            || (/^command:/i.test(href) && !markdown.isTrusted)\n            || /^command:(\\/\\/\\/)?_workbench\\.downloadResource/i.test(href)) {\n            // drop the link\n            a.replaceWith(...a.childNodes);\n        }\n        else {\n            let resolvedHref = _href(href, false);\n            if (markdown.baseUri) {\n                resolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n            }\n            a.dataset.href = resolvedHref;\n        }\n    });\n    element.innerHTML = sanitizeRenderedMarkdown({ isTrusted: markdown.isTrusted, ...options.sanitizerOptions }, markdownHtmlDoc.body.innerHTML);\n    if (codeBlocks.length > 0) {\n        Promise.all(codeBlocks).then((tuples) => {\n            if (isDisposed) {\n                return;\n            }\n            const renderedElements = new Map(tuples);\n            const placeholderElements = element.querySelectorAll(`div[data-code]`);\n            for (const placeholderElement of placeholderElements) {\n                const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n                if (renderedElement) {\n                    DOM.reset(placeholderElement, renderedElement);\n                }\n            }\n            options.asyncRenderCallback?.();\n        });\n    }\n    else if (syncCodeBlocks.length > 0) {\n        const renderedElements = new Map(syncCodeBlocks);\n        const placeholderElements = element.querySelectorAll(`div[data-code]`);\n        for (const placeholderElement of placeholderElements) {\n            const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n            if (renderedElement) {\n                DOM.reset(placeholderElement, renderedElement);\n            }\n        }\n    }\n    // signal size changes for image tags\n    if (options.asyncRenderCallback) {\n        for (const img of element.getElementsByTagName('img')) {\n            const listener = disposables.add(DOM.addDisposableListener(img, 'load', () => {\n                listener.dispose();\n                options.asyncRenderCallback();\n            }));\n        }\n    }\n    return {\n        element,\n        dispose: () => {\n            isDisposed = true;\n            disposables.dispose();\n        }\n    };\n}\nfunction postProcessCodeBlockLanguageId(lang) {\n    if (!lang) {\n        return '';\n    }\n    const parts = lang.split(/[\\s+|:|,|\\{|\\?]/, 1);\n    if (parts.length) {\n        return parts[0];\n    }\n    return lang;\n}\nfunction resolveWithBaseUri(baseUri, href) {\n    const hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\n    if (hasScheme) {\n        return href;\n    }\n    if (baseUri.path.endsWith('/')) {\n        return resolvePath(baseUri, href).toString();\n    }\n    else {\n        return resolvePath(dirname(baseUri), href).toString();\n    }\n}\nconst selfClosingTags = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\nfunction sanitizeRenderedMarkdown(options, renderedMarkdown) {\n    const { config, allowedSchemes } = getSanitizerOptions(options);\n    const store = new DisposableStore();\n    store.add(addDompurifyHook('uponSanitizeAttribute', (element, e) => {\n        if (e.attrName === 'style' || e.attrName === 'class') {\n            if (element.tagName === 'SPAN') {\n                if (e.attrName === 'style') {\n                    e.keepAttr = /^(color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(background-color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(border-radius:[0-9]+px;)?$/.test(e.attrValue);\n                    return;\n                }\n                else if (e.attrName === 'class') {\n                    e.keepAttr = /^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/.test(e.attrValue);\n                    return;\n                }\n            }\n            e.keepAttr = false;\n            return;\n        }\n        else if (element.tagName === 'INPUT' && element.attributes.getNamedItem('type')?.value === 'checkbox') {\n            if ((e.attrName === 'type' && e.attrValue === 'checkbox') || e.attrName === 'disabled' || e.attrName === 'checked') {\n                e.keepAttr = true;\n                return;\n            }\n            e.keepAttr = false;\n        }\n    }));\n    store.add(addDompurifyHook('uponSanitizeElement', (element, e) => {\n        if (e.tagName === 'input') {\n            if (element.attributes.getNamedItem('type')?.value === 'checkbox') {\n                element.setAttribute('disabled', '');\n            }\n            else if (!options.replaceWithPlaintext) {\n                element.remove();\n            }\n        }\n        if (options.replaceWithPlaintext && !e.allowedTags[e.tagName] && e.tagName !== 'body') {\n            if (element.parentElement) {\n                let startTagText;\n                let endTagText;\n                if (e.tagName === '#comment') {\n                    startTagText = `<!--${element.textContent}-->`;\n                }\n                else {\n                    const isSelfClosing = selfClosingTags.includes(e.tagName);\n                    const attrString = element.attributes.length ?\n                        ' ' + Array.from(element.attributes)\n                            .map(attr => `${attr.name}=\"${attr.value}\"`)\n                            .join(' ')\n                        : '';\n                    startTagText = `<${e.tagName}${attrString}>`;\n                    if (!isSelfClosing) {\n                        endTagText = `</${e.tagName}>`;\n                    }\n                }\n                const fragment = document.createDocumentFragment();\n                const textNode = element.parentElement.ownerDocument.createTextNode(startTagText);\n                fragment.appendChild(textNode);\n                const endTagTextNode = endTagText ? element.parentElement.ownerDocument.createTextNode(endTagText) : undefined;\n                while (element.firstChild) {\n                    fragment.appendChild(element.firstChild);\n                }\n                if (endTagTextNode) {\n                    fragment.appendChild(endTagTextNode);\n                }\n                if (element.nodeType === Node.COMMENT_NODE) {\n                    // Workaround for https://github.com/cure53/DOMPurify/issues/1005\n                    // The comment will be deleted in the next phase. However if we try to remove it now, it will cause\n                    // an exception. Instead we insert the text node before the comment.\n                    element.parentElement.insertBefore(fragment, element);\n                }\n                else {\n                    element.parentElement.replaceChild(fragment, element);\n                }\n            }\n        }\n    }));\n    store.add(DOM.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes));\n    try {\n        return dompurify.sanitize(renderedMarkdown, { ...config, RETURN_TRUSTED_TYPE: true });\n    }\n    finally {\n        store.dispose();\n    }\n}\nexport const allowedMarkdownAttr = [\n    'align',\n    'autoplay',\n    'alt',\n    'checked',\n    'class',\n    'colspan',\n    'controls',\n    'data-code',\n    'data-href',\n    'disabled',\n    'draggable',\n    'height',\n    'href',\n    'loop',\n    'muted',\n    'playsinline',\n    'poster',\n    'rowspan',\n    'src',\n    'style',\n    'target',\n    'title',\n    'type',\n    'width',\n    'start',\n];\nfunction getSanitizerOptions(options) {\n    const allowedSchemes = [\n        Schemas.http,\n        Schemas.https,\n        Schemas.mailto,\n        Schemas.data,\n        Schemas.file,\n        Schemas.vscodeFileResource,\n        Schemas.vscodeRemote,\n        Schemas.vscodeRemoteResource,\n    ];\n    if (options.isTrusted) {\n        allowedSchemes.push(Schemas.command);\n    }\n    return {\n        config: {\n            // allowedTags should included everything that markdown renders to.\n            // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.\n            // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\n            // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\n            ALLOWED_TAGS: options.allowedTags ?? [...DOM.basicMarkupHtmlTags],\n            ALLOWED_ATTR: allowedMarkdownAttr,\n            ALLOW_UNKNOWN_PROTOCOLS: true,\n        },\n        allowedSchemes\n    };\n}\n/**\n * Strips all markdown from `string`, if it's an IMarkdownString. For example\n * `# Header` would be output as `Header`. If it's not, the string is returned.\n */\nexport function renderStringAsPlaintext(string) {\n    return typeof string === 'string' ? string : renderMarkdownAsPlaintext(string);\n}\n/**\n * Strips all markdown from `markdown`. For example `# Header` would be output as `Header`.\n * provide @param withCodeBlocks to retain code blocks\n */\nexport function renderMarkdownAsPlaintext(markdown, withCodeBlocks) {\n    // values that are too long will freeze the UI\n    let value = markdown.value ?? '';\n    if (value.length > 100_000) {\n        value = `${value.substr(0, 100_000)}â€¦`;\n    }\n    const html = marked.parse(value, { async: false, renderer: withCodeBlocks ? plainTextWithCodeBlocksRenderer.value : plainTextRenderer.value }).replace(/&(#\\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m);\n    return sanitizeRenderedMarkdown({ isTrusted: false }, html).toString();\n}\nconst unescapeInfo = new Map([\n    ['&quot;', '\"'],\n    ['&nbsp;', ' '],\n    ['&amp;', '&'],\n    ['&#39;', '\\''],\n    ['&lt;', '<'],\n    ['&gt;', '>'],\n]);\nfunction createRenderer() {\n    const renderer = new marked.Renderer();\n    renderer.code = ({ text }) => {\n        return text;\n    };\n    renderer.blockquote = ({ text }) => {\n        return text + '\\n';\n    };\n    renderer.html = (_) => {\n        return '';\n    };\n    renderer.heading = function ({ tokens }) {\n        return this.parser.parseInline(tokens) + '\\n';\n    };\n    renderer.hr = () => {\n        return '';\n    };\n    renderer.list = function ({ items }) {\n        return items.map(x => this.listitem(x)).join('\\n') + '\\n';\n    };\n    renderer.listitem = ({ text }) => {\n        return text + '\\n';\n    };\n    renderer.paragraph = function ({ tokens }) {\n        return this.parser.parseInline(tokens) + '\\n';\n    };\n    renderer.table = function ({ header, rows }) {\n        return header.map(cell => this.tablecell(cell)).join(' ') + '\\n' + rows.map(cells => cells.map(cell => this.tablecell(cell)).join(' ')).join('\\n') + '\\n';\n    };\n    renderer.tablerow = ({ text }) => {\n        return text;\n    };\n    renderer.tablecell = function ({ tokens }) {\n        return this.parser.parseInline(tokens);\n    };\n    renderer.strong = ({ text }) => {\n        return text;\n    };\n    renderer.em = ({ text }) => {\n        return text;\n    };\n    renderer.codespan = ({ text }) => {\n        return text;\n    };\n    renderer.br = (_) => {\n        return '\\n';\n    };\n    renderer.del = ({ text }) => {\n        return text;\n    };\n    renderer.image = (_) => {\n        return '';\n    };\n    renderer.text = ({ text }) => {\n        return text;\n    };\n    renderer.link = ({ text }) => {\n        return text;\n    };\n    return renderer;\n}\nconst plainTextRenderer = new Lazy((withCodeBlocks) => createRenderer());\nconst plainTextWithCodeBlocksRenderer = new Lazy(() => {\n    const renderer = createRenderer();\n    renderer.code = ({ text }) => {\n        return `\\n\\`\\`\\`\\n${text}\\n\\`\\`\\`\\n`;\n    };\n    return renderer;\n});\nfunction mergeRawTokenText(tokens) {\n    let mergedTokenText = '';\n    tokens.forEach(token => {\n        mergedTokenText += token.raw;\n    });\n    return mergedTokenText;\n}\nfunction completeSingleLinePattern(token) {\n    if (!token.tokens) {\n        return undefined;\n    }\n    for (let i = token.tokens.length - 1; i >= 0; i--) {\n        const subtoken = token.tokens[i];\n        if (subtoken.type === 'text') {\n            const lines = subtoken.raw.split('\\n');\n            const lastLine = lines[lines.length - 1];\n            if (lastLine.includes('`')) {\n                return completeCodespan(token);\n            }\n            else if (lastLine.includes('**')) {\n                return completeDoublestar(token);\n            }\n            else if (lastLine.match(/\\*\\w/)) {\n                return completeStar(token);\n            }\n            else if (lastLine.match(/(^|\\s)__\\w/)) {\n                return completeDoubleUnderscore(token);\n            }\n            else if (lastLine.match(/(^|\\s)_\\w/)) {\n                return completeUnderscore(token);\n            }\n            else if (\n            // Text with start of link target\n            hasLinkTextAndStartOfLinkTarget(lastLine) ||\n                // This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.\n                // But some preceding token does have an unbalanced [ at least\n                hasStartOfLinkTargetAndNoLinkText(lastLine) && token.tokens.slice(0, i).some(t => t.type === 'text' && t.raw.match(/\\[[^\\]]*$/))) {\n                const nextTwoSubTokens = token.tokens.slice(i + 1);\n                // A markdown link can look like\n                // [link text](https://microsoft.com \"more text\")\n                // Where \"more text\" is a title for the link or an argument to a vscode command link\n                if (\n                // If the link was parsed as a link, then look for a link token and a text token with a quote\n                nextTwoSubTokens[0]?.type === 'link' && nextTwoSubTokens[1]?.type === 'text' && nextTwoSubTokens[1].raw.match(/^ *\"[^\"]*$/) ||\n                    // And if the link was not parsed as a link (eg command link), just look for a single quote in this token\n                    lastLine.match(/^[^\"]* +\"[^\"]*$/)) {\n                    return completeLinkTargetArg(token);\n                }\n                return completeLinkTarget(token);\n            }\n            // Contains the start of link text, and no following tokens contain the link target\n            else if (lastLine.match(/(^|\\s)\\[\\w*/)) {\n                return completeLinkText(token);\n            }\n        }\n    }\n    return undefined;\n}\nfunction hasLinkTextAndStartOfLinkTarget(str) {\n    return !!str.match(/(^|\\s)\\[.*\\]\\(\\w*/);\n}\nfunction hasStartOfLinkTargetAndNoLinkText(str) {\n    return !!str.match(/^[^\\[]*\\]\\([^\\)]*$/);\n}\nfunction completeListItemPattern(list) {\n    // Patch up this one list item\n    const lastListItem = list.items[list.items.length - 1];\n    const lastListSubToken = lastListItem.tokens ? lastListItem.tokens[lastListItem.tokens.length - 1] : undefined;\n    /*\n    Example list token structures:\n\n    list\n        list_item\n            text\n                text\n                codespan\n                link\n        list_item\n            text\n            code // Complete indented codeblock\n        list_item\n            text\n            space\n            text\n                text // Incomplete indented codeblock\n        list_item\n            text\n            list // Nested list\n                list_item\n                    text\n                        text\n\n    Contrast with paragraph:\n    paragraph\n        text\n        codespan\n    */\n    let newToken;\n    if (lastListSubToken?.type === 'text' && !('inRawBlock' in lastListItem)) { // Why does Tag have a type of 'text'\n        newToken = completeSingleLinePattern(lastListSubToken);\n    }\n    if (!newToken || newToken.type !== 'paragraph') { // 'text' item inside the list item turns into paragraph\n        // Nothing to fix, or not a pattern we were expecting\n        return;\n    }\n    const previousListItemsText = mergeRawTokenText(list.items.slice(0, -1));\n    // Grabbing the `- ` or `1. ` or `* ` off the list item because I can't find a better way to do this\n    const lastListItemLead = lastListItem.raw.match(/^(\\s*(-|\\d+\\.|\\*) +)/)?.[0];\n    if (!lastListItemLead) {\n        // Is badly formatted\n        return;\n    }\n    const newListItemText = lastListItemLead +\n        mergeRawTokenText(lastListItem.tokens.slice(0, -1)) +\n        newToken.raw;\n    const newList = marked.lexer(previousListItemsText + newListItemText)[0];\n    if (newList.type !== 'list') {\n        // Something went wrong\n        return;\n    }\n    return newList;\n}\nconst maxIncompleteTokensFixRounds = 3;\nexport function fillInIncompleteTokens(tokens) {\n    for (let i = 0; i < maxIncompleteTokensFixRounds; i++) {\n        const newTokens = fillInIncompleteTokensOnce(tokens);\n        if (newTokens) {\n            tokens = newTokens;\n        }\n        else {\n            break;\n        }\n    }\n    return tokens;\n}\nfunction fillInIncompleteTokensOnce(tokens) {\n    let i;\n    let newTokens;\n    for (i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        if (token.type === 'paragraph' && token.raw.match(/(\\n|^)\\|/)) {\n            newTokens = completeTable(tokens.slice(i));\n            break;\n        }\n        if (i === tokens.length - 1 && token.type === 'list') {\n            const newListToken = completeListItemPattern(token);\n            if (newListToken) {\n                newTokens = [newListToken];\n                break;\n            }\n        }\n        if (i === tokens.length - 1 && token.type === 'paragraph') {\n            // Only operates on a single token, because any newline that follows this should break these patterns\n            const newToken = completeSingleLinePattern(token);\n            if (newToken) {\n                newTokens = [newToken];\n                break;\n            }\n        }\n    }\n    if (newTokens) {\n        const newTokensList = [\n            ...tokens.slice(0, i),\n            ...newTokens\n        ];\n        newTokensList.links = tokens.links;\n        return newTokensList;\n    }\n    return null;\n}\nfunction completeCodespan(token) {\n    return completeWithString(token, '`');\n}\nfunction completeStar(tokens) {\n    return completeWithString(tokens, '*');\n}\nfunction completeUnderscore(tokens) {\n    return completeWithString(tokens, '_');\n}\nfunction completeLinkTarget(tokens) {\n    return completeWithString(tokens, ')');\n}\nfunction completeLinkTargetArg(tokens) {\n    return completeWithString(tokens, '\")');\n}\nfunction completeLinkText(tokens) {\n    return completeWithString(tokens, '](https://microsoft.com)');\n}\nfunction completeDoublestar(tokens) {\n    return completeWithString(tokens, '**');\n}\nfunction completeDoubleUnderscore(tokens) {\n    return completeWithString(tokens, '__');\n}\nfunction completeWithString(tokens, closingString) {\n    const mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);\n    // If it was completed correctly, this should be a single token.\n    // Expecting either a Paragraph or a List\n    return marked.lexer(mergedRawText + closingString)[0];\n}\nfunction completeTable(tokens) {\n    const mergedRawText = mergeRawTokenText(tokens);\n    const lines = mergedRawText.split('\\n');\n    let numCols; // The number of line1 col headers\n    let hasSeparatorRow = false;\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (typeof numCols === 'undefined' && line.match(/^\\s*\\|/)) {\n            const line1Matches = line.match(/(\\|[^\\|]+)(?=\\||$)/g);\n            if (line1Matches) {\n                numCols = line1Matches.length;\n            }\n        }\n        else if (typeof numCols === 'number') {\n            if (line.match(/^\\s*\\|/)) {\n                if (i !== lines.length - 1) {\n                    // We got the line1 header row, and the line2 separator row, but there are more lines, and it wasn't parsed as a table!\n                    // That's strange and means that the table is probably malformed in the source, so I won't try to patch it up.\n                    return undefined;\n                }\n                // Got a line2 separator row- partial or complete, doesn't matter, we'll replace it with a correct one\n                hasSeparatorRow = true;\n            }\n            else {\n                // The line after the header row isn't a valid separator row, so the table is malformed, don't fix it up\n                return undefined;\n            }\n        }\n    }\n    if (typeof numCols === 'number' && numCols > 0) {\n        const prefixText = hasSeparatorRow ? lines.slice(0, -1).join('\\n') : mergedRawText;\n        const line1EndsInPipe = !!prefixText.match(/\\|\\s*$/);\n        const newRawText = prefixText + (line1EndsInPipe ? '' : '|') + `\\n|${' --- |'.repeat(numCols)}`;\n        return marked.lexer(newRawText);\n    }\n    return undefined;\n}\nfunction addDompurifyHook(hook, cb) {\n    dompurify.addHook(hook, cb);\n    return toDisposable(() => dompurify.removeHook(hook));\n}\n"],"names":["getWindow","addDisposableListener","$","reset","hookDomPurifyHrefAndSrcSanitizer","sanitize","basicMarkupHtmlTags","addHook","removeHook","createElement","StandardMouseEvent","StandardKeyboardEvent","renderLabelWithIcons","DisposableStore","Renderer","defaultGenerator","escape","Event","markdownEscapeEscapedIcons","defaults","lexer","parser","parse","URI","Schemas","removeMarkdownEscapes","escapeDoubleQuotes","parseHrefAndDimensions","onUnexpectedError","resolvePath","dirname","FileAccess","toDisposable","parse$1","cloneAndChange","Lazy","defaultMarkedRenderers","href","title","text","dimensions","attributes","tokens","renderMarkdown","markdown","options","markedOptions","disposables","isDisposed","element","_uriMassage","part","data","value","_href","isDomUri","uri","renderer","marked.Renderer","codeBlocks","syncCodeBlocks","lang","id","postProcessCodeBlockLanguageId","_activateLink","event","target","resolveWithBaseUri","err","onClick","DomEmitter","onAuxClick","e","mouseEvent","DOM.getWindow","DOM.addDisposableListener","keyboardEvent","_a","renderedMarkdown","opts","marked.defaults","marked.lexer","newTokens","fillInIncompleteTokens","marked.parser","marked.parse","markdownHtmlDoc","sanitizeRenderedMarkdown","img","src","DOM.$","a","resolvedHref","tuples","renderedElements","placeholderElements","placeholderElement","renderedElement","DOM.reset","listener","parts","baseUri","selfClosingTags","config","allowedSchemes","getSanitizerOptions","store","addDompurifyHook","startTagText","endTagText","isSelfClosing","attrString","attr","fragment","textNode","endTagTextNode","DOM.hookDomPurifyHrefAndSrcSanitizer","dompurify.sanitize","allowedMarkdownAttr","DOM.basicMarkupHtmlTags","renderStringAsPlaintext","string","renderMarkdownAsPlaintext","withCodeBlocks","html","plainTextRenderer","m","unescapeInfo","createRenderer","_","items","x","header","rows","cell","cells","mergeRawTokenText","mergedTokenText","token","completeSingleLinePattern","_b","i","subtoken","lines","lastLine","completeCodespan","completeDoublestar","completeStar","completeDoubleUnderscore","completeUnderscore","hasLinkTextAndStartOfLinkTarget","hasStartOfLinkTargetAndNoLinkText","t","nextTwoSubTokens","completeLinkTargetArg","completeLinkTarget","completeLinkText","str","completeListItemPattern","list","lastListItem","lastListSubToken","newToken","previousListItemsText","lastListItemLead","newListItemText","newList","maxIncompleteTokensFixRounds","fillInIncompleteTokensOnce","completeTable","newListToken","newTokensList","completeWithString","closingString","mergedRawText","numCols","hasSeparatorRow","line","line1Matches","prefixText","line1EndsInPipe","newRawText","hook","cb","dompurify.addHook","dompurify.removeHook"],"mappings":"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","x_google_ignoreList":[0]}